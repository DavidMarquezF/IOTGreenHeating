
/home/david/Documents/IOT/IOTGreenHeating/Display/target/1.5.2/photon/Display.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .module_info  00000018  080a0000  080a0000  00010000  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .dynalib      00000004  080a0018  080a0018  00010018  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  2 .text         00004eb4  080a001c  080a001c  0001001c  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .backup       00000004  40024000  080a4ed0  00024000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  4 .data         00000074  20000000  080a4ed4  00030000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  5 .bss          00000650  20000074  20000074  00040074  2**2
                  ALLOC
  6 .module_info_suffix 00000028  080a4f48  080a4f48  00034f48  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  7 .module_info_crc 00000004  080a4f70  080a4f70  00034f70  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  8 .debug_info   000eb04a  00000000  00000000  00034f74  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_abbrev 00014df3  00000000  00000000  0011ffbe  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_aranges 000028f8  00000000  00000000  00134db1  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_macro  0002ec77  00000000  00000000  001376a9  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_line   00031fd5  00000000  00000000  00166320  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_str    000b268d  00000000  00000000  001982f5  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_loc    00023aeb  00000000  00000000  0024a982  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_ranges 000046d0  00000000  00000000  0026e46d  2**0
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_frame  0000dbe8  00000000  00000000  00272b40  2**2
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

080a001c <module_user_pre_init>:
/**
 * Initializes this user module. Returns the start of the heap.
 */
void* module_user_pre_init() {

    if ( (&link_global_data_start!=&link_global_data_initial_values) && (link_global_data_size != 0))
 80a001c:	4809      	ldr	r0, [pc, #36]	; (80a0044 <link_dynalib_end+0x28>)
 80a001e:	490a      	ldr	r1, [pc, #40]	; (80a0048 <link_dynalib_end+0x2c>)
extern constructor_ptr_t link_constructors_end;

/**
 * Initializes this user module. Returns the start of the heap.
 */
void* module_user_pre_init() {
 80a0020:	b508      	push	{r3, lr}

    if ( (&link_global_data_start!=&link_global_data_initial_values) && (link_global_data_size != 0))
 80a0022:	4288      	cmp	r0, r1
 80a0024:	d005      	beq.n	80a0032 <module_user_pre_init+0x16>
 80a0026:	4a09      	ldr	r2, [pc, #36]	; (80a004c <link_dynalib_end+0x30>)
 80a0028:	4282      	cmp	r2, r0
 80a002a:	d002      	beq.n	80a0032 <module_user_pre_init+0x16>
    {
        memcpy(&link_global_data_start, &link_global_data_initial_values, link_global_data_size);
 80a002c:	1a12      	subs	r2, r2, r0
 80a002e:	f003 fe45 	bl	80a3cbc <memcpy>
    }

    memset(&link_bss_location, 0, link_bss_size );
 80a0032:	4807      	ldr	r0, [pc, #28]	; (80a0050 <link_dynalib_end+0x34>)
 80a0034:	4a07      	ldr	r2, [pc, #28]	; (80a0054 <link_dynalib_end+0x38>)
 80a0036:	2100      	movs	r1, #0
 80a0038:	1a12      	subs	r2, r2, r0
 80a003a:	f003 fe65 	bl	80a3d08 <memset>
    return &link_heap_start;
}
 80a003e:	4806      	ldr	r0, [pc, #24]	; (80a0058 <link_dynalib_end+0x3c>)
 80a0040:	bd08      	pop	{r3, pc}
 80a0042:	bf00      	nop
 80a0044:	20000000 	.word	0x20000000
 80a0048:	080a4ed4 	.word	0x080a4ed4
 80a004c:	20000074 	.word	0x20000074
 80a0050:	20000074 	.word	0x20000074
 80a0054:	200006c4 	.word	0x200006c4
 80a0058:	200006c4 	.word	0x200006c4

080a005c <module_user_init>:
extern constructor_ptr_t link_constructors_location[];
extern constructor_ptr_t link_constructors_end;
#define link_constructors_size   ((unsigned long)&link_constructors_end  -  (unsigned long)&link_constructors_location )

void module_user_init()
{
 80a005c:	b570      	push	{r4, r5, r6, lr}
    module_user_init_hook();
 80a005e:	f002 f965 	bl	80a232c <module_user_init_hook>
 80a0062:	4b07      	ldr	r3, [pc, #28]	; (80a0080 <module_user_init+0x24>)
 80a0064:	4c07      	ldr	r4, [pc, #28]	; (80a0084 <module_user_init+0x28>)
 80a0066:	461e      	mov	r6, r3
 80a0068:	1ae4      	subs	r4, r4, r3
 80a006a:	08a4      	lsrs	r4, r4, #2

    // invoke constructors
    int ctor_num;
    for (ctor_num=0; ctor_num < link_constructors_size/sizeof(constructor_ptr_t); ctor_num++ )
 80a006c:	2500      	movs	r5, #0
 80a006e:	42a5      	cmp	r5, r4
 80a0070:	d004      	beq.n	80a007c <module_user_init+0x20>
    {
        link_constructors_location[ctor_num]();
 80a0072:	f856 3025 	ldr.w	r3, [r6, r5, lsl #2]
 80a0076:	4798      	blx	r3
{
    module_user_init_hook();

    // invoke constructors
    int ctor_num;
    for (ctor_num=0; ctor_num < link_constructors_size/sizeof(constructor_ptr_t); ctor_num++ )
 80a0078:	3501      	adds	r5, #1
 80a007a:	e7f8      	b.n	80a006e <module_user_init+0x12>
    {
        link_constructors_location[ctor_num]();
    }
}
 80a007c:	bd70      	pop	{r4, r5, r6, pc}
 80a007e:	bf00      	nop
 80a0080:	080a4e78 	.word	0x080a4e78
 80a0084:	080a4ec4 	.word	0x080a4ec4

080a0088 <module_user_setup>:

/**
 * Export these functions with a fuller name so they don't clash with the setup/loop wrappers in the system module.
 */
void module_user_setup() {
    setup();
 80a0088:	f000 b85e 	b.w	80a0148 <setup>

080a008c <module_user_loop>:
}

void module_user_loop() {
 80a008c:	b508      	push	{r3, lr}
    loop();
 80a008e:	f000 f87f 	bl	80a0190 <loop>
    _post_loop();
}
 80a0092:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    setup();
}

void module_user_loop() {
    loop();
    _post_loop();
 80a0096:	f002 b90b 	b.w	80a22b0 <_post_loop>

080a009a <_ZdlPv>:
 80a009a:	f001 bc59 	b.w	80a1950 <free>
	...

080a00a0 <__cxa_pure_virtual>:
char* strerror(int errnum) {
    return (char*)"";
}

/* Default implementation for call made to pure virtual function. */
void __cxa_pure_virtual() {
 80a00a0:	b508      	push	{r3, lr}
  PANIC(PureVirtualCall,"Call on pure virtual");
 80a00a2:	4a03      	ldr	r2, [pc, #12]	; (80a00b0 <__cxa_pure_virtual+0x10>)
 80a00a4:	2100      	movs	r1, #0
 80a00a6:	200c      	movs	r0, #12
 80a00a8:	f001 fbae 	bl	80a1808 <panic_>
 80a00ac:	e7fe      	b.n	80a00ac <__cxa_pure_virtual+0xc>
 80a00ae:	bf00      	nop
 80a00b0:	080a1749 	.word	0x080a1749

080a00b4 <__cxa_guard_acquire>:

/* Provide default implemenation for __cxa_guard_acquire() and
 * __cxa_guard_release(). Note: these must be revisited if a multitasking
 * OS is ported to this platform. */
__extension__ typedef int __guard __attribute__((mode (__DI__)));
int __cxa_guard_acquire(__guard *g) {return !*(char *)(g);};
 80a00b4:	7800      	ldrb	r0, [r0, #0]
 80a00b6:	fab0 f080 	clz	r0, r0
 80a00ba:	0940      	lsrs	r0, r0, #5
 80a00bc:	4770      	bx	lr

080a00be <__cxa_guard_release>:
void __cxa_guard_release (__guard *g) {*(char *)g = 1;};
 80a00be:	2301      	movs	r3, #1
 80a00c0:	7003      	strb	r3, [r0, #0]
 80a00c2:	4770      	bx	lr

080a00c4 <_ZN5spark10LogHandler5writeEPKcj>:
    if (level >= filter_.level(category)) {
        write(data, size);
    }
}

inline void spark::LogHandler::write(const char *data, size_t size) {
 80a00c4:	4770      	bx	lr

080a00c6 <_ZN5spark16StreamLogHandler5writeEPKcj>:
inline Print* spark::StreamLogHandler::stream() const {
    return stream_;
}

inline void spark::StreamLogHandler::write(const char *data, size_t size) {
    stream_->write((const uint8_t*)data, size);
 80a00c6:	6a00      	ldr	r0, [r0, #32]
 80a00c8:	6803      	ldr	r3, [r0, #0]
 80a00ca:	68db      	ldr	r3, [r3, #12]
 80a00cc:	4718      	bx	r3
	...

080a00d0 <_ZN5spark16SerialLogHandlerD1Ev>:
            StreamLogHandler(Serial, level, filters) {
        Serial.begin(baud);
        LogManager::instance()->addHandler(this);
    }

    virtual ~SerialLogHandler() {
 80a00d0:	b510      	push	{r4, lr}
 80a00d2:	4604      	mov	r4, r0
 80a00d4:	4b09      	ldr	r3, [pc, #36]	; (80a00fc <_ZN5spark16SerialLogHandlerD1Ev+0x2c>)
 80a00d6:	6003      	str	r3, [r0, #0]
        LogManager::instance()->removeHandler(this);
 80a00d8:	f002 faba 	bl	80a2650 <_ZN5spark10LogManager8instanceEv>
 80a00dc:	4621      	mov	r1, r4
 80a00de:	f002 fcb6 	bl	80a2a4e <_ZN5spark10LogManager13removeHandlerEPNS_10LogHandlerE>
        Serial.end();
 80a00e2:	f001 ffd9 	bl	80a2098 <_Z16_fetch_usbserialv>
 80a00e6:	f001 ffbd 	bl	80a2064 <_ZN9USBSerial3endEv>
    */
    LogHandler(LogLevel level, LogCategoryFilters filters);
    /*!
        \brief Destructor.
    */
    virtual ~LogHandler() = default;
 80a00ea:	4620      	mov	r0, r4
 80a00ec:	4b04      	ldr	r3, [pc, #16]	; (80a0100 <_ZN5spark16SerialLogHandlerD1Ev+0x30>)
 80a00ee:	f840 3b04 	str.w	r3, [r0], #4
 80a00f2:	f002 fbb3 	bl	80a285c <_ZN5spark6detail9LogFilterD1Ev>
    }
 80a00f6:	4620      	mov	r0, r4
 80a00f8:	bd10      	pop	{r4, pc}
 80a00fa:	bf00      	nop
 80a00fc:	080a3f60 	.word	0x080a3f60
 80a0100:	080a3f48 	.word	0x080a3f48

080a0104 <_ZN5spark16SerialLogHandlerD0Ev>:
            StreamLogHandler(Serial, level, filters) {
        Serial.begin(baud);
        LogManager::instance()->addHandler(this);
    }

    virtual ~SerialLogHandler() {
 80a0104:	b510      	push	{r4, lr}
 80a0106:	4604      	mov	r4, r0
        LogManager::instance()->removeHandler(this);
        Serial.end();
    }
 80a0108:	f7ff ffe2 	bl	80a00d0 <_ZN5spark16SerialLogHandlerD1Ev>
 80a010c:	4620      	mov	r0, r4
 80a010e:	2124      	movs	r1, #36	; 0x24
 80a0110:	f003 fc6a 	bl	80a39e8 <_ZdlPvj>
 80a0114:	4620      	mov	r0, r4
 80a0116:	bd10      	pop	{r4, pc}

080a0118 <_ZNK5spark6Logger4infoEPKcz>:
    va_start(args, fmt);
    log(LOG_LEVEL_TRACE, fmt, args);
    va_end(args);
}

inline void spark::Logger::info(const char *fmt, ...) const {
 80a0118:	b40e      	push	{r1, r2, r3}
 80a011a:	b500      	push	{lr}
 80a011c:	b08c      	sub	sp, #48	; 0x30
 80a011e:	aa0d      	add	r2, sp, #52	; 0x34
 80a0120:	f852 1b04 	ldr.w	r1, [r2], #4
    va_end(args);
}

inline void spark::Logger::log(LogLevel level, const char *fmt, va_list args) const {
    LogAttributes attr;
    attr.size = sizeof(LogAttributes);
 80a0124:	2320      	movs	r3, #32
    attr.flags = 0;
    log_message_v(level, name_, &attr, nullptr, fmt, args);
 80a0126:	e88d 0006 	stmia.w	sp, {r1, r2}
    va_end(args);
}

inline void spark::Logger::info(const char *fmt, ...) const {
    va_list args;
    va_start(args, fmt);
 80a012a:	9203      	str	r2, [sp, #12]
    va_end(args);
}

inline void spark::Logger::log(LogLevel level, const char *fmt, va_list args) const {
    LogAttributes attr;
    attr.size = sizeof(LogAttributes);
 80a012c:	9304      	str	r3, [sp, #16]
    attr.flags = 0;
    log_message_v(level, name_, &attr, nullptr, fmt, args);
 80a012e:	6801      	ldr	r1, [r0, #0]
}

inline void spark::Logger::log(LogLevel level, const char *fmt, va_list args) const {
    LogAttributes attr;
    attr.size = sizeof(LogAttributes);
    attr.flags = 0;
 80a0130:	2300      	movs	r3, #0
    log_message_v(level, name_, &attr, nullptr, fmt, args);
 80a0132:	aa04      	add	r2, sp, #16
 80a0134:	201e      	movs	r0, #30
}

inline void spark::Logger::log(LogLevel level, const char *fmt, va_list args) const {
    LogAttributes attr;
    attr.size = sizeof(LogAttributes);
    attr.flags = 0;
 80a0136:	9305      	str	r3, [sp, #20]
    log_message_v(level, name_, &attr, nullptr, fmt, args);
 80a0138:	f001 fb6e 	bl	80a1818 <log_message_v>
inline void spark::Logger::info(const char *fmt, ...) const {
    va_list args;
    va_start(args, fmt);
    log(LOG_LEVEL_INFO, fmt, args);
    va_end(args);
}
 80a013c:	b00c      	add	sp, #48	; 0x30
 80a013e:	f85d eb04 	ldr.w	lr, [sp], #4
 80a0142:	b003      	add	sp, #12
 80a0144:	4770      	bx	lr
	...

080a0148 <setup>:

Adafruit_SSD1306 display(SCREEN_WIDTH, SCREEN_HEIGHT, OLED_MOSI, OLED_CLK, OLED_DC, OLED_RESET, OLED_CS);
SerialLogHandler logHandler;

void setup()
{
 80a0148:	b507      	push	{r0, r1, r2, lr}
    if (!display.begin(SSD1306_SWITCHCAPVCC))
 80a014a:	2301      	movs	r3, #1
 80a014c:	9300      	str	r3, [sp, #0]
 80a014e:	2200      	movs	r2, #0
 80a0150:	2102      	movs	r1, #2
 80a0152:	480c      	ldr	r0, [pc, #48]	; (80a0184 <setup+0x3c>)
 80a0154:	f000 fab2 	bl	80a06bc <_ZN16Adafruit_SSD13065beginEhhbb>
 80a0158:	b918      	cbnz	r0, 80a0162 <setup+0x1a>
    {
        Log.info("SSD1306 allocation failed");
 80a015a:	490b      	ldr	r1, [pc, #44]	; (80a0188 <setup+0x40>)
 80a015c:	480b      	ldr	r0, [pc, #44]	; (80a018c <setup+0x44>)
 80a015e:	f7ff ffdb 	bl	80a0118 <_ZNK5spark6Logger4infoEPKcz>
        //TODO: Stop the execution of the program
    }
    // Show initial display buffer contents on the screen --
    // the library initializes this with an Adafruit splash screen.
    display.display();
 80a0162:	4808      	ldr	r0, [pc, #32]	; (80a0184 <setup+0x3c>)
 80a0164:	f000 fd58 	bl	80a0c18 <_ZN16Adafruit_SSD13067displayEv>
    delay(2000); // Pause for 2 seconds
 80a0168:	f44f 60fa 	mov.w	r0, #2000	; 0x7d0
 80a016c:	f002 f86a 	bl	80a2244 <delay>

    // Clear the buffer
    display.clearDisplay();
 80a0170:	4804      	ldr	r0, [pc, #16]	; (80a0184 <setup+0x3c>)
 80a0172:	f000 fa96 	bl	80a06a2 <_ZN16Adafruit_SSD130612clearDisplayEv>
    // Show the display buffer on the screen. You MUST call display() after
    // drawing commands to make them visible on screen!
    display.display();
 80a0176:	4803      	ldr	r0, [pc, #12]	; (80a0184 <setup+0x3c>)
}
 80a0178:	b003      	add	sp, #12
 80a017a:	f85d eb04 	ldr.w	lr, [sp], #4

    // Clear the buffer
    display.clearDisplay();
    // Show the display buffer on the screen. You MUST call display() after
    // drawing commands to make them visible on screen!
    display.display();
 80a017e:	f000 bd4b 	b.w	80a0c18 <_ZN16Adafruit_SSD13067displayEv>
 80a0182:	bf00      	nop
 80a0184:	2000009c 	.word	0x2000009c
 80a0188:	080a3f70 	.word	0x080a3f70
 80a018c:	200004bc 	.word	0x200004bc

080a0190 <loop>:
}

void loop()
{
 80a0190:	4770      	bx	lr

080a0192 <_ZN5spark6VectorINS_17LogCategoryFilterENS_16DefaultAllocatorEED1Ev>:
inline spark::Vector<T, AllocatorT>::Vector(Vector<T, AllocatorT>&& vector) : Vector() {
    swap(*this, vector);
}

template<typename T, typename AllocatorT>
inline spark::Vector<T, AllocatorT>::~Vector() {
 80a0192:	b570      	push	{r4, r5, r6, lr}
 80a0194:	4605      	mov	r5, r0
    destruct(data_, data_ + size_);
 80a0196:	6804      	ldr	r4, [r0, #0]
 80a0198:	6843      	ldr	r3, [r0, #4]
 80a019a:	2614      	movs	r6, #20
 80a019c:	fb06 4603 	mla	r6, r6, r3, r4
            new(p) T(std::forward<ArgsT>(args)...);
        }
    }

    static void destruct(T* p, const T* end) {
        for (; p != end; ++p) {
 80a01a0:	42a6      	cmp	r6, r4
 80a01a2:	d004      	beq.n	80a01ae <_ZN5spark6VectorINS_17LogCategoryFilterENS_16DefaultAllocatorEED1Ev+0x1c>
    static int nodeIndex(const Vector<Node> &nodes, const char *name, size_t size, bool &found);
};

} // namespace spark::detail

class LogCategoryFilter {
 80a01a4:	4620      	mov	r0, r4
 80a01a6:	f003 faef 	bl	80a3788 <_ZN6StringD1Ev>
 80a01aa:	3414      	adds	r4, #20
 80a01ac:	e7f8      	b.n	80a01a0 <_ZN5spark6VectorINS_17LogCategoryFilterENS_16DefaultAllocatorEED1Ev+0xe>
inline void* spark::DefaultAllocator::realloc(void* ptr, size_t size) {
    return ::realloc(ptr, size);
}

inline void spark::DefaultAllocator::free(void* ptr) {
    ::free(ptr);
 80a01ae:	6828      	ldr	r0, [r5, #0]
 80a01b0:	f001 fbce 	bl	80a1950 <free>

template<typename T, typename AllocatorT>
inline spark::Vector<T, AllocatorT>::~Vector() {
    destruct(data_, data_ + size_);
    AllocatorT::free(data_);
}
 80a01b4:	4628      	mov	r0, r5
 80a01b6:	bd70      	pop	{r4, r5, r6, pc}

080a01b8 <_ZN5spark6VectorINS_17LogCategoryFilterENS_16DefaultAllocatorEE4moveIS1_Li0EEEvPS1_S5_S5_>:
        ::memmove(dest, p, (end - p) * sizeof(T));
    }

    template<PARTICLE_VECTOR_ENABLE_IF_NOT_TRIVIALLY_COPYABLE(T)>
    static void move(T* dest, T* p, T* end) {
        if (dest > p && dest < end) {
 80a01b8:	4288      	cmp	r0, r1
    static void move(T* dest, const T* p, const T* end) {
        ::memmove(dest, p, (end - p) * sizeof(T));
    }

    template<PARTICLE_VECTOR_ENABLE_IF_NOT_TRIVIALLY_COPYABLE(T)>
    static void move(T* dest, T* p, T* end) {
 80a01ba:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80a01bc:	4606      	mov	r6, r0
 80a01be:	460c      	mov	r4, r1
 80a01c0:	4615      	mov	r5, r2
        if (dest > p && dest < end) {
 80a01c2:	d916      	bls.n	80a01f2 <_ZN5spark6VectorINS_17LogCategoryFilterENS_16DefaultAllocatorEE4moveIS1_Li0EEEvPS1_S5_S5_+0x3a>
 80a01c4:	4290      	cmp	r0, r2
 80a01c6:	d215      	bcs.n	80a01f4 <_ZN5spark6VectorINS_17LogCategoryFilterENS_16DefaultAllocatorEE4moveIS1_Li0EEEvPS1_S5_S5_+0x3c>
            // Move elements in reverse order
            --p;
            --end;
 80a01c8:	f1a2 0514 	sub.w	r5, r2, #20
            dest += end - p - 1;
 80a01cc:	1a6c      	subs	r4, r5, r1
 80a01ce:	f1a1 0714 	sub.w	r7, r1, #20
 80a01d2:	4404      	add	r4, r0
            for (; end != p; --end, --dest) {
 80a01d4:	42af      	cmp	r7, r5
 80a01d6:	d01c      	beq.n	80a0212 <_ZN5spark6VectorINS_17LogCategoryFilterENS_16DefaultAllocatorEE4moveIS1_Li0EEEvPS1_S5_S5_+0x5a>
                new(dest) T(std::move(*end));
 80a01d8:	b12c      	cbz	r4, 80a01e6 <_ZN5spark6VectorINS_17LogCategoryFilterENS_16DefaultAllocatorEE4moveIS1_Li0EEEvPS1_S5_S5_+0x2e>
 80a01da:	4629      	mov	r1, r5
 80a01dc:	4620      	mov	r0, r4
 80a01de:	f003 fac3 	bl	80a3768 <_ZN6StringC1EOS_>
 80a01e2:	7c2b      	ldrb	r3, [r5, #16]
 80a01e4:	7423      	strb	r3, [r4, #16]
 80a01e6:	4628      	mov	r0, r5
 80a01e8:	f003 face 	bl	80a3788 <_ZN6StringD1Ev>
        if (dest > p && dest < end) {
            // Move elements in reverse order
            --p;
            --end;
            dest += end - p - 1;
            for (; end != p; --end, --dest) {
 80a01ec:	3d14      	subs	r5, #20
 80a01ee:	3c14      	subs	r4, #20
 80a01f0:	e7f0      	b.n	80a01d4 <_ZN5spark6VectorINS_17LogCategoryFilterENS_16DefaultAllocatorEE4moveIS1_Li0EEEvPS1_S5_S5_+0x1c>
                new(dest) T(std::move(*end));
                end->~T();
            }
        } else if (dest != p) {
 80a01f2:	d00e      	beq.n	80a0212 <_ZN5spark6VectorINS_17LogCategoryFilterENS_16DefaultAllocatorEE4moveIS1_Li0EEEvPS1_S5_S5_+0x5a>
            for (; p != end; ++p, ++dest) {
 80a01f4:	42ac      	cmp	r4, r5
 80a01f6:	d00c      	beq.n	80a0212 <_ZN5spark6VectorINS_17LogCategoryFilterENS_16DefaultAllocatorEE4moveIS1_Li0EEEvPS1_S5_S5_+0x5a>
                new(dest) T(std::move(*p));
 80a01f8:	b12e      	cbz	r6, 80a0206 <_ZN5spark6VectorINS_17LogCategoryFilterENS_16DefaultAllocatorEE4moveIS1_Li0EEEvPS1_S5_S5_+0x4e>
 80a01fa:	4621      	mov	r1, r4
 80a01fc:	4630      	mov	r0, r6
 80a01fe:	f003 fab3 	bl	80a3768 <_ZN6StringC1EOS_>
 80a0202:	7c23      	ldrb	r3, [r4, #16]
 80a0204:	7433      	strb	r3, [r6, #16]
 80a0206:	4620      	mov	r0, r4
 80a0208:	f003 fabe 	bl	80a3788 <_ZN6StringD1Ev>
            for (; end != p; --end, --dest) {
                new(dest) T(std::move(*end));
                end->~T();
            }
        } else if (dest != p) {
            for (; p != end; ++p, ++dest) {
 80a020c:	3414      	adds	r4, #20
 80a020e:	3614      	adds	r6, #20
 80a0210:	e7f0      	b.n	80a01f4 <_ZN5spark6VectorINS_17LogCategoryFilterENS_16DefaultAllocatorEE4moveIS1_Li0EEEvPS1_S5_S5_+0x3c>
 80a0212:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

080a0214 <_ZN5spark6VectorINS_17LogCategoryFilterENS_16DefaultAllocatorEEC1ERKS3_>:
        size_ = n;
    }
}

template<typename T, typename AllocatorT>
inline spark::Vector<T, AllocatorT>::Vector(const Vector<T, AllocatorT>& vector) : Vector() {
 80a0214:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
// spark::Vector
template<typename T, typename AllocatorT>
inline spark::Vector<T, AllocatorT>::Vector() :
        data_(nullptr),
        size_(0),
        capacity_(0) {
 80a0218:	2300      	movs	r3, #0
 80a021a:	6003      	str	r3, [r0, #0]
 80a021c:	6043      	str	r3, [r0, #4]
 80a021e:	6083      	str	r3, [r0, #8]
    }
}

template<typename T, typename AllocatorT>
inline spark::Vector<T, AllocatorT>::Vector(const Vector<T, AllocatorT>& vector) : Vector() {
    if (vector.size_ > 0 && realloc(vector.size_)) {
 80a0220:	684e      	ldr	r6, [r1, #4]
        size_ = n;
    }
}

template<typename T, typename AllocatorT>
inline spark::Vector<T, AllocatorT>::Vector(const Vector<T, AllocatorT>& vector) : Vector() {
 80a0222:	4604      	mov	r4, r0
    if (vector.size_ > 0 && realloc(vector.size_)) {
 80a0224:	429e      	cmp	r6, r3
        size_ = n;
    }
}

template<typename T, typename AllocatorT>
inline spark::Vector<T, AllocatorT>::Vector(const Vector<T, AllocatorT>& vector) : Vector() {
 80a0226:	460f      	mov	r7, r1
    if (vector.size_ > 0 && realloc(vector.size_)) {
 80a0228:	dd24      	ble.n	80a0274 <_ZN5spark6VectorINS_17LogCategoryFilterENS_16DefaultAllocatorEEC1ERKS3_+0x60>

} // particle

// spark::DefaultAllocator
inline void* spark::DefaultAllocator::malloc(size_t size) {
    return ::malloc(size);
 80a022a:	f04f 0814 	mov.w	r8, #20
 80a022e:	fb08 f006 	mul.w	r0, r8, r6
 80a0232:	f001 fb85 	bl	80a1940 <malloc>
    template<PARTICLE_VECTOR_ENABLE_IF_NOT_TRIVIALLY_COPYABLE(T)>
    bool realloc(int n) {
        T* d = nullptr;
        if (n > 0) {
            d = (T*)AllocatorT::malloc(n * sizeof(T));
            if (!d) {
 80a0236:	4605      	mov	r5, r0
 80a0238:	b1e0      	cbz	r0, 80a0274 <_ZN5spark6VectorINS_17LogCategoryFilterENS_16DefaultAllocatorEEC1ERKS3_+0x60>
                return false;
            }
            move(d, data_, data_ + size_);
 80a023a:	e894 0006 	ldmia.w	r4, {r1, r2}
 80a023e:	fb08 1202 	mla	r2, r8, r2, r1
 80a0242:	f7ff ffb9 	bl	80a01b8 <_ZN5spark6VectorINS_17LogCategoryFilterENS_16DefaultAllocatorEE4moveIS1_Li0EEEvPS1_S5_S5_>
inline void* spark::DefaultAllocator::realloc(void* ptr, size_t size) {
    return ::realloc(ptr, size);
}

inline void spark::DefaultAllocator::free(void* ptr) {
    ::free(ptr);
 80a0246:	6820      	ldr	r0, [r4, #0]
 80a0248:	f001 fb82 	bl	80a1950 <free>
                return false;
            }
            move(d, data_, data_ + size_);
        }
        AllocatorT::free(data_);
        data_ = d;
 80a024c:	6025      	str	r5, [r4, #0]
        capacity_ = n;
 80a024e:	60a6      	str	r6, [r4, #8]
}

template<typename T, typename AllocatorT>
inline spark::Vector<T, AllocatorT>::Vector(const Vector<T, AllocatorT>& vector) : Vector() {
    if (vector.size_ > 0 && realloc(vector.size_)) {
        copy(data_, vector.data_, vector.data_ + vector.size_);
 80a0250:	683e      	ldr	r6, [r7, #0]
 80a0252:	687b      	ldr	r3, [r7, #4]
 80a0254:	fb08 6803 	mla	r8, r8, r3, r6
        }
    }

    template<typename IteratorT>
    static void copy(IteratorT dest, IteratorT it, IteratorT end) {
        for (; it != end; ++it, ++dest) {
 80a0258:	4546      	cmp	r6, r8
 80a025a:	d009      	beq.n	80a0270 <_ZN5spark6VectorINS_17LogCategoryFilterENS_16DefaultAllocatorEEC1ERKS3_+0x5c>
            new(dest) T(*it);
 80a025c:	b12d      	cbz	r5, 80a026a <_ZN5spark6VectorINS_17LogCategoryFilterENS_16DefaultAllocatorEEC1ERKS3_+0x56>
 80a025e:	4631      	mov	r1, r6
 80a0260:	4628      	mov	r0, r5
 80a0262:	f003 fae7 	bl	80a3834 <_ZN6StringC1ERKS_>
 80a0266:	7c33      	ldrb	r3, [r6, #16]
 80a0268:	742b      	strb	r3, [r5, #16]
        }
    }

    template<typename IteratorT>
    static void copy(IteratorT dest, IteratorT it, IteratorT end) {
        for (; it != end; ++it, ++dest) {
 80a026a:	3614      	adds	r6, #20
 80a026c:	3514      	adds	r5, #20
 80a026e:	e7f3      	b.n	80a0258 <_ZN5spark6VectorINS_17LogCategoryFilterENS_16DefaultAllocatorEEC1ERKS3_+0x44>

template<typename T, typename AllocatorT>
inline spark::Vector<T, AllocatorT>::Vector(const Vector<T, AllocatorT>& vector) : Vector() {
    if (vector.size_ > 0 && realloc(vector.size_)) {
        copy(data_, vector.data_, vector.data_ + vector.size_);
        size_ = vector.size_;
 80a0270:	687b      	ldr	r3, [r7, #4]
 80a0272:	6063      	str	r3, [r4, #4]
    }
}
 80a0274:	4620      	mov	r0, r4
 80a0276:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	...

080a027c <_GLOBAL__sub_I_display>:
}
 80a027c:	b5f0      	push	{r4, r5, r6, r7, lr}
#define OLED_CLK (int8_t) D1
#define OLED_DC (int8_t) D2
#define OLED_RESET (int8_t) D3
#define OLED_CS (int8_t) D4

Adafruit_SSD1306 display(SCREEN_WIDTH, SCREEN_HEIGHT, OLED_MOSI, OLED_CLK, OLED_DC, OLED_RESET, OLED_CS);
 80a027e:	4c2b      	ldr	r4, [pc, #172]	; (80a032c <_GLOBAL__sub_I_display+0xb0>)
    display.display();
}

void loop()
{
}
 80a0280:	b091      	sub	sp, #68	; 0x44
inline int32_t pinReadFast(pin_t _pin)
{
    return ((PIN_MAP[_pin].gpio_peripheral->IDR & PIN_MAP[_pin].gpio_pin) == 0 ? LOW : HIGH);
}
#elif defined(STM32F2XX)
static Hal_Pin_Info* PIN_MAP = HAL_Pin_Map();
 80a0282:	f001 faa1 	bl	80a17c8 <HAL_Pin_Map>
#define OLED_CLK (int8_t) D1
#define OLED_DC (int8_t) D2
#define OLED_RESET (int8_t) D3
#define OLED_CS (int8_t) D4

Adafruit_SSD1306 display(SCREEN_WIDTH, SCREEN_HEIGHT, OLED_MOSI, OLED_CLK, OLED_DC, OLED_RESET, OLED_CS);
 80a0286:	4e2a      	ldr	r6, [pc, #168]	; (80a0330 <_GLOBAL__sub_I_display+0xb4>)
 80a0288:	2001      	movs	r0, #1
 80a028a:	2102      	movs	r1, #2
 80a028c:	2203      	movs	r2, #3
 80a028e:	2304      	movs	r3, #4
 80a0290:	e88d 000f 	stmia.w	sp, {r0, r1, r2, r3}
 80a0294:	2300      	movs	r3, #0
 80a0296:	2240      	movs	r2, #64	; 0x40
 80a0298:	2180      	movs	r1, #128	; 0x80
 80a029a:	4620      	mov	r0, r4
 80a029c:	f000 f904 	bl	80a04a8 <_ZN16Adafruit_SSD1306C1Ehhaaaaa>
 80a02a0:	4632      	mov	r2, r6
 80a02a2:	4924      	ldr	r1, [pc, #144]	; (80a0334 <_GLOBAL__sub_I_display+0xb8>)
 80a02a4:	4620      	mov	r0, r4
 80a02a6:	f003 fb91 	bl	80a39cc <__aeabi_atexit>
// spark::Vector
template<typename T, typename AllocatorT>
inline spark::Vector<T, AllocatorT>::Vector() :
        data_(nullptr),
        size_(0),
        capacity_(0) {
 80a02aa:	2300      	movs	r3, #0
 80a02ac:	9304      	str	r3, [sp, #16]
 80a02ae:	9305      	str	r3, [sp, #20]
 80a02b0:	9306      	str	r3, [sp, #24]
namespace spark {

class SerialLogHandler: public StreamLogHandler {
public:
    explicit SerialLogHandler(LogLevel level = LOG_LEVEL_INFO, LogCategoryFilters filters = {}) :
            StreamLogHandler(Serial, level, filters) {
 80a02b2:	f001 fef1 	bl	80a2098 <_Z16_fetch_usbserialv>
inline spark::LogHandler::LogHandler(LogLevel level) :
        filter_(level) {
}

inline spark::LogHandler::LogHandler(LogLevel level, LogCategoryFilters filters) :
        filter_(level, filters) {
 80a02b6:	4c20      	ldr	r4, [pc, #128]	; (80a0338 <_GLOBAL__sub_I_display+0xbc>)
 80a02b8:	4607      	mov	r7, r0
 80a02ba:	4625      	mov	r5, r4
 80a02bc:	a904      	add	r1, sp, #16
 80a02be:	a807      	add	r0, sp, #28
 80a02c0:	f7ff ffa8 	bl	80a0214 <_ZN5spark6VectorINS_17LogCategoryFilterENS_16DefaultAllocatorEEC1ERKS3_>
}

// spark::StreamLogHandler
inline spark::StreamLogHandler::StreamLogHandler(Print &stream, LogLevel level, LogCategoryFilters filters) :
        LogHandler(level, filters),
        stream_(&stream) {
 80a02c4:	a907      	add	r1, sp, #28
 80a02c6:	a80a      	add	r0, sp, #40	; 0x28
 80a02c8:	f7ff ffa4 	bl	80a0214 <_ZN5spark6VectorINS_17LogCategoryFilterENS_16DefaultAllocatorEEC1ERKS3_>
inline spark::LogHandler::LogHandler(LogLevel level) :
        filter_(level) {
}

inline spark::LogHandler::LogHandler(LogLevel level, LogCategoryFilters filters) :
        filter_(level, filters) {
 80a02cc:	4b1b      	ldr	r3, [pc, #108]	; (80a033c <_GLOBAL__sub_I_display+0xc0>)
 80a02ce:	a90a      	add	r1, sp, #40	; 0x28
 80a02d0:	f845 3b04 	str.w	r3, [r5], #4
 80a02d4:	a80d      	add	r0, sp, #52	; 0x34
 80a02d6:	f7ff ff9d 	bl	80a0214 <_ZN5spark6VectorINS_17LogCategoryFilterENS_16DefaultAllocatorEEC1ERKS3_>
 80a02da:	aa0d      	add	r2, sp, #52	; 0x34
 80a02dc:	211e      	movs	r1, #30
 80a02de:	4628      	mov	r0, r5
 80a02e0:	f002 fd1b 	bl	80a2d1a <_ZN5spark6detail9LogFilterC1E8LogLevelNS_6VectorINS_17LogCategoryFilterENS_16DefaultAllocatorEEE>
 80a02e4:	a80d      	add	r0, sp, #52	; 0x34
 80a02e6:	f7ff ff54 	bl	80a0192 <_ZN5spark6VectorINS_17LogCategoryFilterENS_16DefaultAllocatorEED1Ev>
}

// spark::StreamLogHandler
inline spark::StreamLogHandler::StreamLogHandler(Print &stream, LogLevel level, LogCategoryFilters filters) :
        LogHandler(level, filters),
        stream_(&stream) {
 80a02ea:	a80a      	add	r0, sp, #40	; 0x28
 80a02ec:	f7ff ff51 	bl	80a0192 <_ZN5spark6VectorINS_17LogCategoryFilterENS_16DefaultAllocatorEED1Ev>
 80a02f0:	4b13      	ldr	r3, [pc, #76]	; (80a0340 <_GLOBAL__sub_I_display+0xc4>)
 80a02f2:	6227      	str	r7, [r4, #32]
 80a02f4:	6023      	str	r3, [r4, #0]
 80a02f6:	a807      	add	r0, sp, #28
 80a02f8:	f7ff ff4b 	bl	80a0192 <_ZN5spark6VectorINS_17LogCategoryFilterENS_16DefaultAllocatorEED1Ev>
 80a02fc:	4b11      	ldr	r3, [pc, #68]	; (80a0344 <_GLOBAL__sub_I_display+0xc8>)
 80a02fe:	6023      	str	r3, [r4, #0]
        Serial.begin();
 80a0300:	f001 feca 	bl	80a2098 <_Z16_fetch_usbserialv>
 80a0304:	f44f 5116 	mov.w	r1, #9600	; 0x2580
 80a0308:	f001 fea8 	bl	80a205c <_ZN9USBSerial5beginEl>
        LogManager::instance()->addHandler(this);
 80a030c:	f002 f9a0 	bl	80a2650 <_ZN5spark10LogManager8instanceEv>
 80a0310:	4621      	mov	r1, r4
 80a0312:	f002 fc96 	bl	80a2c42 <_ZN5spark10LogManager10addHandlerEPNS_10LogHandlerE>
SerialLogHandler logHandler;
 80a0316:	a804      	add	r0, sp, #16
 80a0318:	f7ff ff3b 	bl	80a0192 <_ZN5spark6VectorINS_17LogCategoryFilterENS_16DefaultAllocatorEED1Ev>
 80a031c:	4632      	mov	r2, r6
 80a031e:	490a      	ldr	r1, [pc, #40]	; (80a0348 <_GLOBAL__sub_I_display+0xcc>)
 80a0320:	4620      	mov	r0, r4
 80a0322:	f003 fb53 	bl	80a39cc <__aeabi_atexit>
    display.display();
}

void loop()
{
}
 80a0326:	b011      	add	sp, #68	; 0x44
 80a0328:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80a032a:	bf00      	nop
 80a032c:	2000009c 	.word	0x2000009c
 80a0330:	20000074 	.word	0x20000074
 80a0334:	080a03b5 	.word	0x080a03b5
 80a0338:	20000078 	.word	0x20000078
 80a033c:	080a3f48 	.word	0x080a3f48
 80a0340:	080a4c98 	.word	0x080a4c98
 80a0344:	080a3f60 	.word	0x080a3f60
 80a0348:	080a00d1 	.word	0x080a00d1

080a034c <_ZNK8particle13__SPISettings7printToER5Print>:
  bool operator!=(const __SPISettings& other) const
  {
    return !(other == *this);
  }

  virtual size_t printTo(Print& p) const
 80a034c:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
 80a034e:	4602      	mov	r2, r0
  {
    if (default_ && clock_ == 0)
 80a0350:	7913      	ldrb	r3, [r2, #4]
  bool operator!=(const __SPISettings& other) const
  {
    return !(other == *this);
  }

  virtual size_t printTo(Print& p) const
 80a0352:	4608      	mov	r0, r1
 80a0354:	6895      	ldr	r5, [r2, #8]
  {
    if (default_ && clock_ == 0)
 80a0356:	b133      	cbz	r3, 80a0366 <_ZNK8particle13__SPISettings7printToER5Print+0x1a>
 80a0358:	b93d      	cbnz	r5, 80a036a <_ZNK8particle13__SPISettings7printToER5Print+0x1e>
      return p.print("<SPISettings default>");
 80a035a:	490c      	ldr	r1, [pc, #48]	; (80a038c <_ZNK8particle13__SPISettings7printToER5Print+0x40>)
    else
      return p.printf("<SPISettings %s%lu %s MODE%d>", default_ ? "default " : "", clock_, bitOrder_ == MSBFIRST ? "MSB" : "LSB", dataMode_);
  }
 80a035c:	b004      	add	sp, #16
 80a035e:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
  }

  virtual size_t printTo(Print& p) const
  {
    if (default_ && clock_ == 0)
      return p.print("<SPISettings default>");
 80a0362:	f003 b829 	b.w	80a33b8 <_ZN5Print5printEPKc>
    else
      return p.printf("<SPISettings %s%lu %s MODE%d>", default_ ? "default " : "", clock_, bitOrder_ == MSBFIRST ? "MSB" : "LSB", dataMode_);
 80a0366:	4b0a      	ldr	r3, [pc, #40]	; (80a0390 <_ZNK8particle13__SPISettings7printToER5Print+0x44>)
 80a0368:	e000      	b.n	80a036c <_ZNK8particle13__SPISettings7printToER5Print+0x20>
 80a036a:	4b0a      	ldr	r3, [pc, #40]	; (80a0394 <_ZNK8particle13__SPISettings7printToER5Print+0x48>)
 80a036c:	7b16      	ldrb	r6, [r2, #12]
 80a036e:	4c0a      	ldr	r4, [pc, #40]	; (80a0398 <_ZNK8particle13__SPISettings7printToER5Print+0x4c>)
 80a0370:	490a      	ldr	r1, [pc, #40]	; (80a039c <_ZNK8particle13__SPISettings7printToER5Print+0x50>)
    size_t println(const __FlashStringHelper*);

    template <typename... Args>
    inline size_t printf(const char* format, Args... args)
    {
        return this->printf_impl(false, format, args...);
 80a0372:	7b52      	ldrb	r2, [r2, #13]
 80a0374:	2e01      	cmp	r6, #1
 80a0376:	bf08      	it	eq
 80a0378:	4621      	moveq	r1, r4
 80a037a:	9202      	str	r2, [sp, #8]
 80a037c:	9101      	str	r1, [sp, #4]
 80a037e:	9500      	str	r5, [sp, #0]
 80a0380:	4a07      	ldr	r2, [pc, #28]	; (80a03a0 <_ZNK8particle13__SPISettings7printToER5Print+0x54>)
 80a0382:	2100      	movs	r1, #0
 80a0384:	f003 f84a 	bl	80a341c <_ZN5Print11printf_implEbPKcz>
  }
 80a0388:	b004      	add	sp, #16
 80a038a:	bd70      	pop	{r4, r5, r6, pc}
 80a038c:	080a3fb1 	.word	0x080a3fb1
 80a0390:	080a4c57 	.word	0x080a4c57
 80a0394:	080a3fa0 	.word	0x080a3fa0
 80a0398:	080a3fa9 	.word	0x080a3fa9
 80a039c:	080a3fad 	.word	0x080a3fad
 80a03a0:	080a3fc7 	.word	0x080a3fc7

080a03a4 <_ZN8SPIClassD1Ev>:
  RecursiveMutex _mutex;
#endif

public:
  SPIClass(HAL_SPI_Interface spi);
  ~SPIClass() = default;
 80a03a4:	b510      	push	{r4, lr}
 80a03a6:	4604      	mov	r4, r0
        dispose();
    }

    void dispose()
    {
        if (handle_) {
 80a03a8:	6880      	ldr	r0, [r0, #8]
 80a03aa:	b108      	cbz	r0, 80a03b0 <_ZN8SPIClassD1Ev+0xc>
            os_mutex_recursive_destroy(handle_);
 80a03ac:	f001 f9ac 	bl	80a1708 <os_mutex_recursive_destroy>
 80a03b0:	4620      	mov	r0, r4
 80a03b2:	bd10      	pop	{r4, pc}

080a03b4 <_ZN16Adafruit_SSD1306D1Ev>:
      rstPin(rst_pin) {}

/*!
    @brief  Destructor for Adafruit_SSD1306 object.
*/
Adafruit_SSD1306::~Adafruit_SSD1306(void) {
 80a03b4:	b510      	push	{r4, lr}
 80a03b6:	4b04      	ldr	r3, [pc, #16]	; (80a03c8 <_ZN16Adafruit_SSD1306D1Ev+0x14>)
 80a03b8:	4604      	mov	r4, r0
 80a03ba:	6003      	str	r3, [r0, #0]
  if (buffer) {
 80a03bc:	6ac0      	ldr	r0, [r0, #44]	; 0x2c
 80a03be:	b108      	cbz	r0, 80a03c4 <_ZN16Adafruit_SSD1306D1Ev+0x10>
    free(buffer);
 80a03c0:	f001 fac6 	bl	80a1950 <free>
    buffer = NULL;
  }
}
 80a03c4:	4620      	mov	r0, r4
 80a03c6:	bd10      	pop	{r4, pc}
 80a03c8:	080a400c 	.word	0x080a400c

080a03cc <_ZN16Adafruit_SSD1306D0Ev>:
      rstPin(rst_pin) {}

/*!
    @brief  Destructor for Adafruit_SSD1306 object.
*/
Adafruit_SSD1306::~Adafruit_SSD1306(void) {
 80a03cc:	b510      	push	{r4, lr}
 80a03ce:	4604      	mov	r4, r0
  if (buffer) {
    free(buffer);
    buffer = NULL;
  }
}
 80a03d0:	f7ff fff0 	bl	80a03b4 <_ZN16Adafruit_SSD1306D1Ev>
 80a03d4:	4620      	mov	r0, r4
 80a03d6:	2174      	movs	r1, #116	; 0x74
 80a03d8:	f003 fb06 	bl	80a39e8 <_ZdlPvj>
 80a03dc:	4620      	mov	r0, r4
 80a03de:	bd10      	pop	{r4, pc}

080a03e0 <_ZN16Adafruit_SSD13069drawPixelEsst>:
    @note   Changes buffer contents only, no immediate effect on display.
            Follow up with a call to display(), or with other graphics
            commands as needed by one's own application.
*/
void Adafruit_SSD1306::drawPixel(int16_t x, int16_t y, uint16_t color) {
  if ((x >= 0) && (x < width()) && (y >= 0) && (y < height())) {
 80a03e0:	2900      	cmp	r1, #0
    @return None (void).
    @note   Changes buffer contents only, no immediate effect on display.
            Follow up with a call to display(), or with other graphics
            commands as needed by one's own application.
*/
void Adafruit_SSD1306::drawPixel(int16_t x, int16_t y, uint16_t color) {
 80a03e2:	b530      	push	{r4, r5, lr}
  if ((x >= 0) && (x < width()) && (y >= 0) && (y < height())) {
 80a03e4:	db5e      	blt.n	80a04a4 <_ZN16Adafruit_SSD13069drawPixelEsst+0xc4>
 80a03e6:	f9b0 400c 	ldrsh.w	r4, [r0, #12]
 80a03ea:	428c      	cmp	r4, r1
 80a03ec:	dd5a      	ble.n	80a04a4 <_ZN16Adafruit_SSD13069drawPixelEsst+0xc4>
 80a03ee:	2a00      	cmp	r2, #0
 80a03f0:	db58      	blt.n	80a04a4 <_ZN16Adafruit_SSD13069drawPixelEsst+0xc4>
 80a03f2:	f9b0 400e 	ldrsh.w	r4, [r0, #14]
 80a03f6:	4294      	cmp	r4, r2
 80a03f8:	dc00      	bgt.n	80a03fc <_ZN16Adafruit_SSD13069drawPixelEsst+0x1c>
 80a03fa:	bd30      	pop	{r4, r5, pc}
    // Pixel is in-bounds. Rotate coordinates if needed.
    switch (getRotation()) {
 80a03fc:	7e84      	ldrb	r4, [r0, #26]
 80a03fe:	2c02      	cmp	r4, #2
 80a0400:	d107      	bne.n	80a0412 <_ZN16Adafruit_SSD13069drawPixelEsst+0x32>
    case 1:
      ssd1306_swap(x, y);
      x = WIDTH - x - 1;
      break;
    case 2:
      x = WIDTH - x - 1;
 80a0402:	8904      	ldrh	r4, [r0, #8]
 80a0404:	3c01      	subs	r4, #1
 80a0406:	1a61      	subs	r1, r4, r1
      y = HEIGHT - y - 1;
 80a0408:	8944      	ldrh	r4, [r0, #10]
    case 1:
      ssd1306_swap(x, y);
      x = WIDTH - x - 1;
      break;
    case 2:
      x = WIDTH - x - 1;
 80a040a:	b209      	sxth	r1, r1
      y = HEIGHT - y - 1;
 80a040c:	3c01      	subs	r4, #1
 80a040e:	1aa2      	subs	r2, r4, r2
 80a0410:	e006      	b.n	80a0420 <_ZN16Adafruit_SSD13069drawPixelEsst+0x40>
            commands as needed by one's own application.
*/
void Adafruit_SSD1306::drawPixel(int16_t x, int16_t y, uint16_t color) {
  if ((x >= 0) && (x < width()) && (y >= 0) && (y < height())) {
    // Pixel is in-bounds. Rotate coordinates if needed.
    switch (getRotation()) {
 80a0412:	2c03      	cmp	r4, #3
 80a0414:	d13c      	bne.n	80a0490 <_ZN16Adafruit_SSD13069drawPixelEsst+0xb0>
    case 2:
      x = WIDTH - x - 1;
      y = HEIGHT - y - 1;
      break;
    case 3:
      ssd1306_swap(x, y);
 80a0416:	460d      	mov	r5, r1
      y = HEIGHT - y - 1;
 80a0418:	8944      	ldrh	r4, [r0, #10]
    case 2:
      x = WIDTH - x - 1;
      y = HEIGHT - y - 1;
      break;
    case 3:
      ssd1306_swap(x, y);
 80a041a:	4611      	mov	r1, r2
      y = HEIGHT - y - 1;
 80a041c:	3c01      	subs	r4, #1
 80a041e:	1b62      	subs	r2, r4, r5
 80a0420:	b212      	sxth	r2, r2
      break;
    }
    switch (color) {
 80a0422:	2b01      	cmp	r3, #1
 80a0424:	d003      	beq.n	80a042e <_ZN16Adafruit_SSD13069drawPixelEsst+0x4e>
 80a0426:	d311      	bcc.n	80a044c <_ZN16Adafruit_SSD13069drawPixelEsst+0x6c>
 80a0428:	2b02      	cmp	r3, #2
 80a042a:	d020      	beq.n	80a046e <_ZN16Adafruit_SSD13069drawPixelEsst+0x8e>
 80a042c:	bd30      	pop	{r4, r5, pc}
    case SSD1306_WHITE:
      buffer[x + (y / 8) * WIDTH] |= (1 << (y & 7));
 80a042e:	2408      	movs	r4, #8
 80a0430:	fb92 f4f4 	sdiv	r4, r2, r4
 80a0434:	f9b0 5008 	ldrsh.w	r5, [r0, #8]
 80a0438:	f002 0207 	and.w	r2, r2, #7
 80a043c:	fb05 1104 	mla	r1, r5, r4, r1
 80a0440:	6ac4      	ldr	r4, [r0, #44]	; 0x2c
 80a0442:	4093      	lsls	r3, r2
 80a0444:	5c60      	ldrb	r0, [r4, r1]
 80a0446:	4303      	orrs	r3, r0
 80a0448:	5463      	strb	r3, [r4, r1]
 80a044a:	bd30      	pop	{r4, r5, pc}
      break;
    case SSD1306_BLACK:
      buffer[x + (y / 8) * WIDTH] &= ~(1 << (y & 7));
 80a044c:	2308      	movs	r3, #8
 80a044e:	fb92 f3f3 	sdiv	r3, r2, r3
 80a0452:	f9b0 4008 	ldrsh.w	r4, [r0, #8]
 80a0456:	f002 0207 	and.w	r2, r2, #7
 80a045a:	fb04 1103 	mla	r1, r4, r3, r1
 80a045e:	6ac4      	ldr	r4, [r0, #44]	; 0x2c
 80a0460:	2001      	movs	r0, #1
 80a0462:	5c63      	ldrb	r3, [r4, r1]
 80a0464:	fa00 f202 	lsl.w	r2, r0, r2
 80a0468:	ea23 0202 	bic.w	r2, r3, r2
 80a046c:	e00e      	b.n	80a048c <_ZN16Adafruit_SSD13069drawPixelEsst+0xac>
      break;
    case SSD1306_INVERSE:
      buffer[x + (y / 8) * WIDTH] ^= (1 << (y & 7));
 80a046e:	2308      	movs	r3, #8
 80a0470:	fb92 f3f3 	sdiv	r3, r2, r3
 80a0474:	f9b0 4008 	ldrsh.w	r4, [r0, #8]
 80a0478:	f002 0207 	and.w	r2, r2, #7
 80a047c:	fb04 1103 	mla	r1, r4, r3, r1
 80a0480:	6ac4      	ldr	r4, [r0, #44]	; 0x2c
 80a0482:	2001      	movs	r0, #1
 80a0484:	5c63      	ldrb	r3, [r4, r1]
 80a0486:	fa00 f202 	lsl.w	r2, r0, r2
 80a048a:	405a      	eors	r2, r3
 80a048c:	5462      	strb	r2, [r4, r1]
      break;
    }
  }
}
 80a048e:	bd30      	pop	{r4, r5, pc}
            commands as needed by one's own application.
*/
void Adafruit_SSD1306::drawPixel(int16_t x, int16_t y, uint16_t color) {
  if ((x >= 0) && (x < width()) && (y >= 0) && (y < height())) {
    // Pixel is in-bounds. Rotate coordinates if needed.
    switch (getRotation()) {
 80a0490:	2c01      	cmp	r4, #1
 80a0492:	d1c6      	bne.n	80a0422 <_ZN16Adafruit_SSD13069drawPixelEsst+0x42>
    case 1:
      ssd1306_swap(x, y);
 80a0494:	4051      	eors	r1, r2
      x = WIDTH - x - 1;
 80a0496:	8904      	ldrh	r4, [r0, #8]
void Adafruit_SSD1306::drawPixel(int16_t x, int16_t y, uint16_t color) {
  if ((x >= 0) && (x < width()) && (y >= 0) && (y < height())) {
    // Pixel is in-bounds. Rotate coordinates if needed.
    switch (getRotation()) {
    case 1:
      ssd1306_swap(x, y);
 80a0498:	404a      	eors	r2, r1
      x = WIDTH - x - 1;
 80a049a:	3c01      	subs	r4, #1
 80a049c:	4051      	eors	r1, r2
 80a049e:	1a61      	subs	r1, r4, r1
 80a04a0:	b209      	sxth	r1, r1
 80a04a2:	e7be      	b.n	80a0422 <_ZN16Adafruit_SSD13069drawPixelEsst+0x42>
 80a04a4:	bd30      	pop	{r4, r5, pc}
	...

080a04a8 <_ZN16Adafruit_SSD1306C1Ehhaaaaa>:
            bus with other devices. Active low.
    @return Adafruit_SSD1306 object.
    @note   Call the object's begin() function before use -- buffer
            allocation is performed there!
*/
Adafruit_SSD1306::Adafruit_SSD1306(uint8_t w, uint8_t h, int8_t mosi_pin,
 80a04a8:	b538      	push	{r3, r4, r5, lr}
 80a04aa:	4604      	mov	r4, r0
 80a04ac:	461d      	mov	r5, r3
                                   int8_t sclk_pin, int8_t dc_pin,
                                   int8_t rst_pin, int8_t cs_pin)
    : Adafruit_GFX(w, h), spi(NULL), wire(NULL), buffer(NULL),
      mosiPin(mosi_pin), clkPin(sclk_pin), dcPin(dc_pin), csPin(cs_pin),
      rstPin(rst_pin) {}
 80a04ae:	f000 fdd5 	bl	80a105c <_ZN12Adafruit_GFXC1Ess>
 80a04b2:	4b12      	ldr	r3, [pc, #72]	; (80a04fc <_ZN16Adafruit_SSD1306C1Ehhaaaaa+0x54>)
 80a04b4:	2200      	movs	r2, #0
 80a04b6:	6023      	str	r3, [r4, #0]
 80a04b8:	f99d 3010 	ldrsb.w	r3, [sp, #16]
 80a04bc:	6262      	str	r2, [r4, #36]	; 0x24
 80a04be:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34
 80a04c2:	f99d 3014 	ldrsb.w	r3, [sp, #20]
 80a04c6:	62a2      	str	r2, [r4, #40]	; 0x28
 80a04c8:	f884 3035 	strb.w	r3, [r4, #53]	; 0x35
 80a04cc:	f99d 301c 	ldrsb.w	r3, [sp, #28]
 80a04d0:	62e2      	str	r2, [r4, #44]	; 0x2c
 80a04d2:	f884 3036 	strb.w	r3, [r4, #54]	; 0x36
 80a04d6:	f99d 3018 	ldrsb.w	r3, [sp, #24]
 80a04da:	f884 5033 	strb.w	r5, [r4, #51]	; 0x33
 80a04de:	f884 3037 	strb.w	r3, [r4, #55]	; 0x37
      dataMode_{dataMode}
  {
  }

  __SPISettings()
  {
 80a04e2:	4b07      	ldr	r3, [pc, #28]	; (80a0500 <_ZN16Adafruit_SSD1306C1Ehhaaaaa+0x58>)
 80a04e4:	66e2      	str	r2, [r4, #108]	; 0x6c
 80a04e6:	6663      	str	r3, [r4, #100]	; 0x64
 80a04e8:	2301      	movs	r3, #1
 80a04ea:	f884 3068 	strb.w	r3, [r4, #104]	; 0x68
 80a04ee:	f884 2070 	strb.w	r2, [r4, #112]	; 0x70
 80a04f2:	f884 2071 	strb.w	r2, [r4, #113]	; 0x71
 80a04f6:	4620      	mov	r0, r4
 80a04f8:	bd38      	pop	{r3, r4, r5, pc}
 80a04fa:	bf00      	nop
 80a04fc:	080a400c 	.word	0x080a400c
 80a0500:	080a3f94 	.word	0x080a3f94

080a0504 <_ZN16Adafruit_SSD130616ssd1306_command1Eh>:

// Issue single command to SSD1306, using I2C or hard/soft SPI as needed.
// Because command calls are often grouped, SPI transaction and selection
// must be started/ended in calling function for efficiency.
// This is a private function, not exposed (see ssd1306_command() instead).
void Adafruit_SSD1306::ssd1306_command1(uint8_t c) {
 80a0504:	b570      	push	{r4, r5, r6, lr}
 80a0506:	4604      	mov	r4, r0
  if (wire) { // I2C
 80a0508:	6a80      	ldr	r0, [r0, #40]	; 0x28

// Issue single command to SSD1306, using I2C or hard/soft SPI as needed.
// Because command calls are often grouped, SPI transaction and selection
// must be started/ended in calling function for efficiency.
// This is a private function, not exposed (see ssd1306_command() instead).
void Adafruit_SSD1306::ssd1306_command1(uint8_t c) {
 80a050a:	460d      	mov	r5, r1
  if (wire) { // I2C
 80a050c:	b190      	cbz	r0, 80a0534 <_ZN16Adafruit_SSD130616ssd1306_command1Eh+0x30>
    wire->beginTransmission(i2caddr);
 80a050e:	f994 1030 	ldrsb.w	r1, [r4, #48]	; 0x30
 80a0512:	f001 fd3f 	bl	80a1f94 <_ZN7TwoWire17beginTransmissionEi>
    WIRE_WRITE((uint8_t)0x00); // Co = 0, D/C = 0
 80a0516:	6aa0      	ldr	r0, [r4, #40]	; 0x28
 80a0518:	2100      	movs	r1, #0
 80a051a:	6803      	ldr	r3, [r0, #0]
 80a051c:	689b      	ldr	r3, [r3, #8]
 80a051e:	4798      	blx	r3
    WIRE_WRITE(c);
 80a0520:	6aa0      	ldr	r0, [r4, #40]	; 0x28
 80a0522:	4629      	mov	r1, r5
 80a0524:	6803      	ldr	r3, [r0, #0]
 80a0526:	689b      	ldr	r3, [r3, #8]
 80a0528:	4798      	blx	r3
    wire->endTransmission();
 80a052a:	6aa0      	ldr	r0, [r4, #40]	; 0x28
  } else { // SPI (hw or soft) -- transaction started in calling function
    SSD1306_MODE_COMMAND
    SPIwrite(c);
  }
}
 80a052c:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
void Adafruit_SSD1306::ssd1306_command1(uint8_t c) {
  if (wire) { // I2C
    wire->beginTransmission(i2caddr);
    WIRE_WRITE((uint8_t)0x00); // Co = 0, D/C = 0
    WIRE_WRITE(c);
    wire->endTransmission();
 80a0530:	f001 bd37 	b.w	80a1fa2 <_ZN7TwoWire15endTransmissionEv>
  } else { // SPI (hw or soft) -- transaction started in calling function
    SSD1306_MODE_COMMAND
 80a0534:	6c22      	ldr	r2, [r4, #64]	; 0x40
 80a0536:	6d20      	ldr	r0, [r4, #80]	; 0x50
 80a0538:	6813      	ldr	r3, [r2, #0]
 80a053a:	ea23 0300 	bic.w	r3, r3, r0
 80a053e:	6013      	str	r3, [r2, #0]
// LOW-LEVEL UTILS ---------------------------------------------------------

// Issue single byte out SPI, either soft or hardware as appropriate.
// SPI transaction/selection must be performed in calling function.
inline void Adafruit_SSD1306::SPIwrite(uint8_t d) {
  if (spi) {
 80a0540:	6a60      	ldr	r0, [r4, #36]	; 0x24
 80a0542:	b118      	cbz	r0, 80a054c <_ZN16Adafruit_SSD130616ssd1306_command1Eh+0x48>
    wire->endTransmission();
  } else { // SPI (hw or soft) -- transaction started in calling function
    SSD1306_MODE_COMMAND
    SPIwrite(c);
  }
}
 80a0544:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}

// Issue single byte out SPI, either soft or hardware as appropriate.
// SPI transaction/selection must be performed in calling function.
inline void Adafruit_SSD1306::SPIwrite(uint8_t d) {
  if (spi) {
    (void)spi->transfer(d);
 80a0548:	f003 b905 	b.w	80a3756 <_ZN8SPIClass8transferEh>
// LOW-LEVEL UTILS ---------------------------------------------------------

// Issue single byte out SPI, either soft or hardware as appropriate.
// SPI transaction/selection must be performed in calling function.
inline void Adafruit_SSD1306::SPIwrite(uint8_t d) {
  if (spi) {
 80a054c:	2108      	movs	r1, #8
 80a054e:	2080      	movs	r0, #128	; 0x80
 80a0550:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 80a0552:	6ca2      	ldr	r2, [r4, #72]	; 0x48
    (void)spi->transfer(d);
  } else {
    for (uint8_t bit = 0x80; bit; bit >>= 1) {
#ifdef HAVE_PORTREG
      if (d & bit)
        *mosiPort |= mosiPinMask;
 80a0554:	681e      	ldr	r6, [r3, #0]
  if (spi) {
    (void)spi->transfer(d);
  } else {
    for (uint8_t bit = 0x80; bit; bit >>= 1) {
#ifdef HAVE_PORTREG
      if (d & bit)
 80a0556:	4205      	tst	r5, r0
        *mosiPort |= mosiPinMask;
 80a0558:	bf14      	ite	ne
 80a055a:	4332      	orrne	r2, r6
      else
        *mosiPort &= ~mosiPinMask;
 80a055c:	ea26 0202 	biceq.w	r2, r6, r2
 80a0560:	601a      	str	r2, [r3, #0]
      *clkPort |= clkPinMask;  // Clock high
 80a0562:	6be2      	ldr	r2, [r4, #60]	; 0x3c
 80a0564:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
 80a0566:	6816      	ldr	r6, [r2, #0]
// SPI transaction/selection must be performed in calling function.
inline void Adafruit_SSD1306::SPIwrite(uint8_t d) {
  if (spi) {
    (void)spi->transfer(d);
  } else {
    for (uint8_t bit = 0x80; bit; bit >>= 1) {
 80a0568:	3901      	subs	r1, #1
#ifdef HAVE_PORTREG
      if (d & bit)
        *mosiPort |= mosiPinMask;
      else
        *mosiPort &= ~mosiPinMask;
      *clkPort |= clkPinMask;  // Clock high
 80a056a:	ea43 0306 	orr.w	r3, r3, r6
 80a056e:	6013      	str	r3, [r2, #0]
      *clkPort &= ~clkPinMask; // Clock low
 80a0570:	6be2      	ldr	r2, [r4, #60]	; 0x3c
 80a0572:	6ce6      	ldr	r6, [r4, #76]	; 0x4c
 80a0574:	6813      	ldr	r3, [r2, #0]
// SPI transaction/selection must be performed in calling function.
inline void Adafruit_SSD1306::SPIwrite(uint8_t d) {
  if (spi) {
    (void)spi->transfer(d);
  } else {
    for (uint8_t bit = 0x80; bit; bit >>= 1) {
 80a0576:	ea4f 0050 	mov.w	r0, r0, lsr #1
      if (d & bit)
        *mosiPort |= mosiPinMask;
      else
        *mosiPort &= ~mosiPinMask;
      *clkPort |= clkPinMask;  // Clock high
      *clkPort &= ~clkPinMask; // Clock low
 80a057a:	ea23 0306 	bic.w	r3, r3, r6
 80a057e:	6013      	str	r3, [r2, #0]
// SPI transaction/selection must be performed in calling function.
inline void Adafruit_SSD1306::SPIwrite(uint8_t d) {
  if (spi) {
    (void)spi->transfer(d);
  } else {
    for (uint8_t bit = 0x80; bit; bit >>= 1) {
 80a0580:	d1e6      	bne.n	80a0550 <_ZN16Adafruit_SSD130616ssd1306_command1Eh+0x4c>
    wire->endTransmission();
  } else { // SPI (hw or soft) -- transaction started in calling function
    SSD1306_MODE_COMMAND
    SPIwrite(c);
  }
}
 80a0582:	bd70      	pop	{r4, r5, r6, pc}

080a0584 <_ZN16Adafruit_SSD130613invertDisplayEb>:
            display() function -- buffer contents are not changed, rather a
            different pixel mode of the display hardware is used. When
            enabled, drawing SSD1306_BLACK (value 0) pixels will actually draw
   white, SSD1306_WHITE (value 1) will draw black.
*/
void Adafruit_SSD1306::invertDisplay(bool i) {
 80a0584:	b538      	push	{r3, r4, r5, lr}
 80a0586:	4604      	mov	r4, r0
  TRANSACTION_START
 80a0588:	6a80      	ldr	r0, [r0, #40]	; 0x28
            display() function -- buffer contents are not changed, rather a
            different pixel mode of the display hardware is used. When
            enabled, drawing SSD1306_BLACK (value 0) pixels will actually draw
   white, SSD1306_WHITE (value 1) will draw black.
*/
void Adafruit_SSD1306::invertDisplay(bool i) {
 80a058a:	460d      	mov	r5, r1
  TRANSACTION_START
 80a058c:	b118      	cbz	r0, 80a0596 <_ZN16Adafruit_SSD130613invertDisplayEb+0x12>

public:
  TwoWire(HAL_I2C_Interface i2c, const HAL_I2C_Config& config);
  virtual ~TwoWire() {};
  inline void setClock(uint32_t speed) {
	  setSpeed(speed);
 80a058e:	6da1      	ldr	r1, [r4, #88]	; 0x58
 80a0590:	f001 fcf2 	bl	80a1f78 <_ZN7TwoWire8setSpeedEm>
 80a0594:	e00b      	b.n	80a05ae <_ZN16Adafruit_SSD130613invertDisplayEb+0x2a>
 80a0596:	6a60      	ldr	r0, [r4, #36]	; 0x24
 80a0598:	b118      	cbz	r0, 80a05a2 <_ZN16Adafruit_SSD130613invertDisplayEb+0x1e>
 80a059a:	f104 0164 	add.w	r1, r4, #100	; 0x64
 80a059e:	f003 f86b 	bl	80a3678 <_ZN8SPIClass16beginTransactionERKN8particle13__SPISettingsE>
 80a05a2:	6c62      	ldr	r2, [r4, #68]	; 0x44
 80a05a4:	6d61      	ldr	r1, [r4, #84]	; 0x54
 80a05a6:	6813      	ldr	r3, [r2, #0]
 80a05a8:	ea23 0301 	bic.w	r3, r3, r1
 80a05ac:	6013      	str	r3, [r2, #0]
  ssd1306_command1(i ? SSD1306_INVERTDISPLAY : SSD1306_NORMALDISPLAY);
 80a05ae:	2d00      	cmp	r5, #0
 80a05b0:	4620      	mov	r0, r4
 80a05b2:	bf14      	ite	ne
 80a05b4:	21a7      	movne	r1, #167	; 0xa7
 80a05b6:	21a6      	moveq	r1, #166	; 0xa6
 80a05b8:	f7ff ffa4 	bl	80a0504 <_ZN16Adafruit_SSD130616ssd1306_command1Eh>
  TRANSACTION_END
 80a05bc:	6aa0      	ldr	r0, [r4, #40]	; 0x28
 80a05be:	b120      	cbz	r0, 80a05ca <_ZN16Adafruit_SSD130613invertDisplayEb+0x46>
 80a05c0:	6de1      	ldr	r1, [r4, #92]	; 0x5c
}
 80a05c2:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
 80a05c6:	f001 bcd7 	b.w	80a1f78 <_ZN7TwoWire8setSpeedEm>
   white, SSD1306_WHITE (value 1) will draw black.
*/
void Adafruit_SSD1306::invertDisplay(bool i) {
  TRANSACTION_START
  ssd1306_command1(i ? SSD1306_INVERTDISPLAY : SSD1306_NORMALDISPLAY);
  TRANSACTION_END
 80a05ca:	6c62      	ldr	r2, [r4, #68]	; 0x44
 80a05cc:	6d63      	ldr	r3, [r4, #84]	; 0x54
 80a05ce:	6811      	ldr	r1, [r2, #0]
 80a05d0:	430b      	orrs	r3, r1
 80a05d2:	6013      	str	r3, [r2, #0]
 80a05d4:	6a60      	ldr	r0, [r4, #36]	; 0x24
 80a05d6:	b118      	cbz	r0, 80a05e0 <_ZN16Adafruit_SSD130613invertDisplayEb+0x5c>
}
 80a05d8:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
   white, SSD1306_WHITE (value 1) will draw black.
*/
void Adafruit_SSD1306::invertDisplay(bool i) {
  TRANSACTION_START
  ssd1306_command1(i ? SSD1306_INVERTDISPLAY : SSD1306_NORMALDISPLAY);
  TRANSACTION_END
 80a05dc:	f003 b830 	b.w	80a3640 <_ZN8SPIClass14endTransactionEv>
 80a05e0:	bd38      	pop	{r3, r4, r5, pc}

080a05e2 <_ZN16Adafruit_SSD130619ssd1306_commandListEPKhh>:
  }
}

// Issue list of commands to SSD1306, same rules as above re: transactions.
// This is a private function, not exposed.
void Adafruit_SSD1306::ssd1306_commandList(const uint8_t *c, uint8_t n) {
 80a05e2:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80a05e4:	4604      	mov	r4, r0
  if (wire) { // I2C
 80a05e6:	6a80      	ldr	r0, [r0, #40]	; 0x28
  }
}

// Issue list of commands to SSD1306, same rules as above re: transactions.
// This is a private function, not exposed.
void Adafruit_SSD1306::ssd1306_commandList(const uint8_t *c, uint8_t n) {
 80a05e8:	460d      	mov	r5, r1
 80a05ea:	188f      	adds	r7, r1, r2
  if (wire) { // I2C
 80a05ec:	b348      	cbz	r0, 80a0642 <_ZN16Adafruit_SSD130619ssd1306_commandListEPKhh+0x60>
    wire->beginTransmission(i2caddr);
 80a05ee:	f994 1030 	ldrsb.w	r1, [r4, #48]	; 0x30
 80a05f2:	f001 fccf 	bl	80a1f94 <_ZN7TwoWire17beginTransmissionEi>
    WIRE_WRITE((uint8_t)0x00); // Co = 0, D/C = 0
 80a05f6:	6aa0      	ldr	r0, [r4, #40]	; 0x28
 80a05f8:	2100      	movs	r1, #0
 80a05fa:	6803      	ldr	r3, [r0, #0]
    uint8_t bytesOut = 1;
 80a05fc:	2601      	movs	r6, #1
// Issue list of commands to SSD1306, same rules as above re: transactions.
// This is a private function, not exposed.
void Adafruit_SSD1306::ssd1306_commandList(const uint8_t *c, uint8_t n) {
  if (wire) { // I2C
    wire->beginTransmission(i2caddr);
    WIRE_WRITE((uint8_t)0x00); // Co = 0, D/C = 0
 80a05fe:	689b      	ldr	r3, [r3, #8]
 80a0600:	4798      	blx	r3
    uint8_t bytesOut = 1;
    while (n--) {
 80a0602:	42bd      	cmp	r5, r7
 80a0604:	d018      	beq.n	80a0638 <_ZN16Adafruit_SSD130619ssd1306_commandListEPKhh+0x56>
      if (bytesOut >= WIRE_MAX) {
 80a0606:	2e1f      	cmp	r6, #31
 80a0608:	d90d      	bls.n	80a0626 <_ZN16Adafruit_SSD130619ssd1306_commandListEPKhh+0x44>
        wire->endTransmission();
 80a060a:	6aa0      	ldr	r0, [r4, #40]	; 0x28
 80a060c:	f001 fcc9 	bl	80a1fa2 <_ZN7TwoWire15endTransmissionEv>
        wire->beginTransmission(i2caddr);
 80a0610:	f994 1030 	ldrsb.w	r1, [r4, #48]	; 0x30
 80a0614:	6aa0      	ldr	r0, [r4, #40]	; 0x28
 80a0616:	f001 fcbd 	bl	80a1f94 <_ZN7TwoWire17beginTransmissionEi>
        WIRE_WRITE((uint8_t)0x00); // Co = 0, D/C = 0
 80a061a:	6aa0      	ldr	r0, [r4, #40]	; 0x28
 80a061c:	2100      	movs	r1, #0
 80a061e:	6803      	ldr	r3, [r0, #0]
        bytesOut = 1;
 80a0620:	2601      	movs	r6, #1
    uint8_t bytesOut = 1;
    while (n--) {
      if (bytesOut >= WIRE_MAX) {
        wire->endTransmission();
        wire->beginTransmission(i2caddr);
        WIRE_WRITE((uint8_t)0x00); // Co = 0, D/C = 0
 80a0622:	689b      	ldr	r3, [r3, #8]
 80a0624:	4798      	blx	r3
        bytesOut = 1;
      }
      WIRE_WRITE(pgm_read_byte(c++));
 80a0626:	6aa0      	ldr	r0, [r4, #40]	; 0x28
 80a0628:	f815 1b01 	ldrb.w	r1, [r5], #1
 80a062c:	6803      	ldr	r3, [r0, #0]
      bytesOut++;
 80a062e:	3601      	adds	r6, #1
        wire->endTransmission();
        wire->beginTransmission(i2caddr);
        WIRE_WRITE((uint8_t)0x00); // Co = 0, D/C = 0
        bytesOut = 1;
      }
      WIRE_WRITE(pgm_read_byte(c++));
 80a0630:	689b      	ldr	r3, [r3, #8]
 80a0632:	4798      	blx	r3
      bytesOut++;
 80a0634:	b2f6      	uxtb	r6, r6
void Adafruit_SSD1306::ssd1306_commandList(const uint8_t *c, uint8_t n) {
  if (wire) { // I2C
    wire->beginTransmission(i2caddr);
    WIRE_WRITE((uint8_t)0x00); // Co = 0, D/C = 0
    uint8_t bytesOut = 1;
    while (n--) {
 80a0636:	e7e4      	b.n	80a0602 <_ZN16Adafruit_SSD130619ssd1306_commandListEPKhh+0x20>
        bytesOut = 1;
      }
      WIRE_WRITE(pgm_read_byte(c++));
      bytesOut++;
    }
    wire->endTransmission();
 80a0638:	6aa0      	ldr	r0, [r4, #40]	; 0x28
  } else { // SPI -- transaction started in calling function
    SSD1306_MODE_COMMAND
    while (n--)
      SPIwrite(pgm_read_byte(c++));
  }
}
 80a063a:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
        bytesOut = 1;
      }
      WIRE_WRITE(pgm_read_byte(c++));
      bytesOut++;
    }
    wire->endTransmission();
 80a063e:	f001 bcb0 	b.w	80a1fa2 <_ZN7TwoWire15endTransmissionEv>
  } else { // SPI -- transaction started in calling function
    SSD1306_MODE_COMMAND
 80a0642:	6c22      	ldr	r2, [r4, #64]	; 0x40
 80a0644:	6d21      	ldr	r1, [r4, #80]	; 0x50
 80a0646:	6813      	ldr	r3, [r2, #0]
 80a0648:	ea23 0301 	bic.w	r3, r3, r1
 80a064c:	6013      	str	r3, [r2, #0]
    while (n--)
 80a064e:	42bd      	cmp	r5, r7
 80a0650:	d026      	beq.n	80a06a0 <_ZN16Adafruit_SSD130619ssd1306_commandListEPKhh+0xbe>
// LOW-LEVEL UTILS ---------------------------------------------------------

// Issue single byte out SPI, either soft or hardware as appropriate.
// SPI transaction/selection must be performed in calling function.
inline void Adafruit_SSD1306::SPIwrite(uint8_t d) {
  if (spi) {
 80a0652:	6a60      	ldr	r0, [r4, #36]	; 0x24
    }
    wire->endTransmission();
  } else { // SPI -- transaction started in calling function
    SSD1306_MODE_COMMAND
    while (n--)
      SPIwrite(pgm_read_byte(c++));
 80a0654:	f815 1b01 	ldrb.w	r1, [r5], #1
// LOW-LEVEL UTILS ---------------------------------------------------------

// Issue single byte out SPI, either soft or hardware as appropriate.
// SPI transaction/selection must be performed in calling function.
inline void Adafruit_SSD1306::SPIwrite(uint8_t d) {
  if (spi) {
 80a0658:	b110      	cbz	r0, 80a0660 <_ZN16Adafruit_SSD130619ssd1306_commandListEPKhh+0x7e>
    (void)spi->transfer(d);
 80a065a:	f003 f87c 	bl	80a3756 <_ZN8SPIClass8transferEh>
 80a065e:	e7f6      	b.n	80a064e <_ZN16Adafruit_SSD130619ssd1306_commandListEPKhh+0x6c>
// LOW-LEVEL UTILS ---------------------------------------------------------

// Issue single byte out SPI, either soft or hardware as appropriate.
// SPI transaction/selection must be performed in calling function.
inline void Adafruit_SSD1306::SPIwrite(uint8_t d) {
  if (spi) {
 80a0660:	f04f 0c08 	mov.w	ip, #8
 80a0664:	2680      	movs	r6, #128	; 0x80
 80a0666:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 80a0668:	6ca2      	ldr	r2, [r4, #72]	; 0x48
    (void)spi->transfer(d);
  } else {
    for (uint8_t bit = 0x80; bit; bit >>= 1) {
#ifdef HAVE_PORTREG
      if (d & bit)
        *mosiPort |= mosiPinMask;
 80a066a:	f8d3 e000 	ldr.w	lr, [r3]
  if (spi) {
    (void)spi->transfer(d);
  } else {
    for (uint8_t bit = 0x80; bit; bit >>= 1) {
#ifdef HAVE_PORTREG
      if (d & bit)
 80a066e:	4231      	tst	r1, r6
        *mosiPort |= mosiPinMask;
 80a0670:	bf14      	ite	ne
 80a0672:	ea4e 0202 	orrne.w	r2, lr, r2
      else
        *mosiPort &= ~mosiPinMask;
 80a0676:	ea2e 0202 	biceq.w	r2, lr, r2
 80a067a:	601a      	str	r2, [r3, #0]
      *clkPort |= clkPinMask;  // Clock high
 80a067c:	6be2      	ldr	r2, [r4, #60]	; 0x3c
 80a067e:	6ce0      	ldr	r0, [r4, #76]	; 0x4c
 80a0680:	6813      	ldr	r3, [r2, #0]
// SPI transaction/selection must be performed in calling function.
inline void Adafruit_SSD1306::SPIwrite(uint8_t d) {
  if (spi) {
    (void)spi->transfer(d);
  } else {
    for (uint8_t bit = 0x80; bit; bit >>= 1) {
 80a0682:	f1bc 0c01 	subs.w	ip, ip, #1
#ifdef HAVE_PORTREG
      if (d & bit)
        *mosiPort |= mosiPinMask;
      else
        *mosiPort &= ~mosiPinMask;
      *clkPort |= clkPinMask;  // Clock high
 80a0686:	ea43 0300 	orr.w	r3, r3, r0
 80a068a:	6013      	str	r3, [r2, #0]
      *clkPort &= ~clkPinMask; // Clock low
 80a068c:	6be2      	ldr	r2, [r4, #60]	; 0x3c
 80a068e:	6ce0      	ldr	r0, [r4, #76]	; 0x4c
 80a0690:	6813      	ldr	r3, [r2, #0]
// SPI transaction/selection must be performed in calling function.
inline void Adafruit_SSD1306::SPIwrite(uint8_t d) {
  if (spi) {
    (void)spi->transfer(d);
  } else {
    for (uint8_t bit = 0x80; bit; bit >>= 1) {
 80a0692:	ea4f 0656 	mov.w	r6, r6, lsr #1
      if (d & bit)
        *mosiPort |= mosiPinMask;
      else
        *mosiPort &= ~mosiPinMask;
      *clkPort |= clkPinMask;  // Clock high
      *clkPort &= ~clkPinMask; // Clock low
 80a0696:	ea23 0300 	bic.w	r3, r3, r0
 80a069a:	6013      	str	r3, [r2, #0]
// SPI transaction/selection must be performed in calling function.
inline void Adafruit_SSD1306::SPIwrite(uint8_t d) {
  if (spi) {
    (void)spi->transfer(d);
  } else {
    for (uint8_t bit = 0x80; bit; bit >>= 1) {
 80a069c:	d1e3      	bne.n	80a0666 <_ZN16Adafruit_SSD130619ssd1306_commandListEPKhh+0x84>
 80a069e:	e7d6      	b.n	80a064e <_ZN16Adafruit_SSD130619ssd1306_commandListEPKhh+0x6c>
 80a06a0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

080a06a2 <_ZN16Adafruit_SSD130612clearDisplayEv>:
    @note   Changes buffer contents only, no immediate effect on display.
            Follow up with a call to display(), or with other graphics
            commands as needed by one's own application.
*/
void Adafruit_SSD1306::clearDisplay(void) {
  memset(buffer, 0, WIDTH * ((HEIGHT + 7) / 8));
 80a06a2:	f9b0 300a 	ldrsh.w	r3, [r0, #10]
 80a06a6:	2208      	movs	r2, #8
 80a06a8:	3307      	adds	r3, #7
 80a06aa:	fb93 f3f2 	sdiv	r3, r3, r2
 80a06ae:	f9b0 2008 	ldrsh.w	r2, [r0, #8]
 80a06b2:	2100      	movs	r1, #0
 80a06b4:	435a      	muls	r2, r3
 80a06b6:	6ac0      	ldr	r0, [r0, #44]	; 0x2c
 80a06b8:	f003 bb26 	b.w	80a3d08 <memset>

080a06bc <_ZN16Adafruit_SSD13065beginEhhbb>:
            Well-behaved code should check the return value before
            proceeding.
    @note   MUST call this function before any drawing or updates!
*/
bool Adafruit_SSD1306::begin(uint8_t vcs, uint8_t addr, bool reset,
                             bool periphBegin) {
 80a06bc:	e92d 41ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, lr}
 80a06c0:	461e      	mov	r6, r3

  if ((!buffer) && !(buffer = (uint8_t *)malloc(WIDTH * ((HEIGHT + 7) / 8))))
 80a06c2:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
            Well-behaved code should check the return value before
            proceeding.
    @note   MUST call this function before any drawing or updates!
*/
bool Adafruit_SSD1306::begin(uint8_t vcs, uint8_t addr, bool reset,
                             bool periphBegin) {
 80a06c4:	4604      	mov	r4, r0
 80a06c6:	4688      	mov	r8, r1
 80a06c8:	4615      	mov	r5, r2
 80a06ca:	f89d 7028 	ldrb.w	r7, [sp, #40]	; 0x28

  if ((!buffer) && !(buffer = (uint8_t *)malloc(WIDTH * ((HEIGHT + 7) / 8))))
 80a06ce:	b973      	cbnz	r3, 80a06ee <_ZN16Adafruit_SSD13065beginEhhbb+0x32>
 80a06d0:	f9b0 300a 	ldrsh.w	r3, [r0, #10]
 80a06d4:	2008      	movs	r0, #8
 80a06d6:	3307      	adds	r3, #7
 80a06d8:	fb93 f3f0 	sdiv	r3, r3, r0
 80a06dc:	f9b4 0008 	ldrsh.w	r0, [r4, #8]
 80a06e0:	4358      	muls	r0, r3
 80a06e2:	f001 f92d 	bl	80a1940 <malloc>
 80a06e6:	62e0      	str	r0, [r4, #44]	; 0x2c
 80a06e8:	2800      	cmp	r0, #0
 80a06ea:	f000 8153 	beq.w	80a0994 <_ZN16Adafruit_SSD13065beginEhhbb+0x2d8>
    return false;

  clearDisplay();
 80a06ee:	4620      	mov	r0, r4
 80a06f0:	f7ff ffd7 	bl	80a06a2 <_ZN16Adafruit_SSD130612clearDisplayEv>
  if (HEIGHT > 32) {
 80a06f4:	f9b4 200a 	ldrsh.w	r2, [r4, #10]
 80a06f8:	f9b4 3008 	ldrsh.w	r3, [r4, #8]
 80a06fc:	2a20      	cmp	r2, #32
 80a06fe:	f04f 0102 	mov.w	r1, #2
 80a0702:	dd0d      	ble.n	80a0720 <_ZN16Adafruit_SSD13065beginEhhbb+0x64>
    drawBitmap((WIDTH - splash1_width) / 2, (HEIGHT - splash1_height) / 2,
               splash1_data, splash1_width, splash1_height, 1);
 80a0704:	3b52      	subs	r3, #82	; 0x52
 80a0706:	3a40      	subs	r2, #64	; 0x40
 80a0708:	fb92 f2f1 	sdiv	r2, r2, r1
 80a070c:	2052      	movs	r0, #82	; 0x52
 80a070e:	fb93 f1f1 	sdiv	r1, r3, r1
 80a0712:	f04f 0c01 	mov.w	ip, #1
 80a0716:	2340      	movs	r3, #64	; 0x40
 80a0718:	e88d 1009 	stmia.w	sp, {r0, r3, ip}
 80a071c:	4b9f      	ldr	r3, [pc, #636]	; (80a099c <_ZN16Adafruit_SSD13065beginEhhbb+0x2e0>)
 80a071e:	e00c      	b.n	80a073a <_ZN16Adafruit_SSD13065beginEhhbb+0x7e>
  } else {
    drawBitmap((WIDTH - splash2_width) / 2, (HEIGHT - splash2_height) / 2,
               splash2_data, splash2_width, splash2_height, 1);
 80a0720:	3b73      	subs	r3, #115	; 0x73
 80a0722:	3a20      	subs	r2, #32
 80a0724:	fb92 f2f1 	sdiv	r2, r2, r1
 80a0728:	2073      	movs	r0, #115	; 0x73
 80a072a:	fb93 f1f1 	sdiv	r1, r3, r1
 80a072e:	f04f 0e01 	mov.w	lr, #1
 80a0732:	2320      	movs	r3, #32
 80a0734:	e88d 4009 	stmia.w	sp, {r0, r3, lr}
 80a0738:	4b99      	ldr	r3, [pc, #612]	; (80a09a0 <_ZN16Adafruit_SSD13065beginEhhbb+0x2e4>)
 80a073a:	4620      	mov	r0, r4
 80a073c:	b212      	sxth	r2, r2
 80a073e:	b209      	sxth	r1, r1
 80a0740:	f000 fcfb 	bl	80a113a <_ZN12Adafruit_GFX10drawBitmapEssPKhsst>
  }

  vccstate = vcs;

  // Setup pin directions
  if (wire) { // Using I2C
 80a0744:	6aa0      	ldr	r0, [r4, #40]	; 0x28
  } else {
    drawBitmap((WIDTH - splash2_width) / 2, (HEIGHT - splash2_height) / 2,
               splash2_data, splash2_width, splash2_height, 1);
  }

  vccstate = vcs;
 80a0746:	f884 8031 	strb.w	r8, [r4, #49]	; 0x31

  // Setup pin directions
  if (wire) { // Using I2C
 80a074a:	b180      	cbz	r0, 80a076e <_ZN16Adafruit_SSD13065beginEhhbb+0xb2>
    // If I2C address is unspecified, use default
    // (0x3C for 32-pixel-tall displays, 0x3D for all others).
    i2caddr = addr ? addr : ((HEIGHT == 32) ? 0x3C : 0x3D);
 80a074c:	b935      	cbnz	r5, 80a075c <_ZN16Adafruit_SSD13065beginEhhbb+0xa0>
 80a074e:	f9b4 300a 	ldrsh.w	r3, [r4, #10]
 80a0752:	2b20      	cmp	r3, #32
 80a0754:	bf14      	ite	ne
 80a0756:	253d      	movne	r5, #61	; 0x3d
 80a0758:	253c      	moveq	r5, #60	; 0x3c
 80a075a:	e000      	b.n	80a075e <_ZN16Adafruit_SSD13065beginEhhbb+0xa2>
 80a075c:	b26d      	sxtb	r5, r5
 80a075e:	f884 5030 	strb.w	r5, [r4, #48]	; 0x30
    // TwoWire begin() function might be already performed by the calling
    // function if it has unusual circumstances (e.g. TWI variants that
    // can accept different SDA/SCL pins, or if two SSD1306 instances
    // with different addresses -- only a single begin() is needed).
    if (periphBegin)
 80a0762:	2f00      	cmp	r7, #0
 80a0764:	f000 8112 	beq.w	80a098c <_ZN16Adafruit_SSD13065beginEhhbb+0x2d0>
      wire->begin();
 80a0768:	f001 fc0a 	bl	80a1f80 <_ZN7TwoWire5beginEv>
 80a076c:	e068      	b.n	80a0840 <_ZN16Adafruit_SSD13065beginEhhbb+0x184>
  } else { // Using one of the SPI modes, either soft or hardware
    pinMode(dcPin, OUTPUT); // Set data/command pin as output
 80a076e:	f994 0035 	ldrsb.w	r0, [r4, #53]	; 0x35
 80a0772:	2101      	movs	r1, #1
 80a0774:	b280      	uxth	r0, r0
 80a0776:	f003 f8ff 	bl	80a3978 <pinMode>
    pinMode(csPin, OUTPUT); // Same for chip select
 80a077a:	f994 0036 	ldrsb.w	r0, [r4, #54]	; 0x36
 80a077e:	2101      	movs	r1, #1
 80a0780:	b280      	uxth	r0, r0
 80a0782:	f003 f8f9 	bl	80a3978 <pinMode>
#ifdef HAVE_PORTREG
    dcPort = (PortReg *)portOutputRegister(digitalPinToPort(dcPin));
 80a0786:	f001 f81f 	bl	80a17c8 <HAL_Pin_Map>
 80a078a:	f994 3035 	ldrsb.w	r3, [r4, #53]	; 0x35
 80a078e:	251c      	movs	r5, #28
 80a0790:	436b      	muls	r3, r5
 80a0792:	58c3      	ldr	r3, [r0, r3]
 80a0794:	3314      	adds	r3, #20
 80a0796:	6423      	str	r3, [r4, #64]	; 0x40
    dcPinMask = digitalPinToBitMask(dcPin);
 80a0798:	f001 f816 	bl	80a17c8 <HAL_Pin_Map>
 80a079c:	f994 3035 	ldrsb.w	r3, [r4, #53]	; 0x35
 80a07a0:	fb05 0003 	mla	r0, r5, r3, r0
 80a07a4:	8883      	ldrh	r3, [r0, #4]
 80a07a6:	6523      	str	r3, [r4, #80]	; 0x50
    csPort = (PortReg *)portOutputRegister(digitalPinToPort(csPin));
 80a07a8:	f001 f80e 	bl	80a17c8 <HAL_Pin_Map>
 80a07ac:	f994 3036 	ldrsb.w	r3, [r4, #54]	; 0x36
 80a07b0:	436b      	muls	r3, r5
 80a07b2:	58c3      	ldr	r3, [r0, r3]
 80a07b4:	3314      	adds	r3, #20
 80a07b6:	6463      	str	r3, [r4, #68]	; 0x44
    csPinMask = digitalPinToBitMask(csPin);
 80a07b8:	f001 f806 	bl	80a17c8 <HAL_Pin_Map>
 80a07bc:	f994 3036 	ldrsb.w	r3, [r4, #54]	; 0x36
#endif
    SSD1306_DESELECT
 80a07c0:	6c62      	ldr	r2, [r4, #68]	; 0x44
    pinMode(csPin, OUTPUT); // Same for chip select
#ifdef HAVE_PORTREG
    dcPort = (PortReg *)portOutputRegister(digitalPinToPort(dcPin));
    dcPinMask = digitalPinToBitMask(dcPin);
    csPort = (PortReg *)portOutputRegister(digitalPinToPort(csPin));
    csPinMask = digitalPinToBitMask(csPin);
 80a07c2:	fb05 0003 	mla	r0, r5, r3, r0
 80a07c6:	8881      	ldrh	r1, [r0, #4]
 80a07c8:	6561      	str	r1, [r4, #84]	; 0x54
#endif
    SSD1306_DESELECT
 80a07ca:	6813      	ldr	r3, [r2, #0]
 80a07cc:	430b      	orrs	r3, r1
 80a07ce:	6013      	str	r3, [r2, #0]
    if (spi) { // Hardware SPI
 80a07d0:	6a60      	ldr	r0, [r4, #36]	; 0x24
 80a07d2:	b120      	cbz	r0, 80a07de <_ZN16Adafruit_SSD13065beginEhhbb+0x122>
      // SPI peripheral begin same as wire check above.
      if (periphBegin)
 80a07d4:	2f00      	cmp	r7, #0
 80a07d6:	d033      	beq.n	80a0840 <_ZN16Adafruit_SSD13065beginEhhbb+0x184>
        spi->begin();
 80a07d8:	f002 ff22 	bl	80a3620 <_ZN8SPIClass5beginEv>
 80a07dc:	e030      	b.n	80a0840 <_ZN16Adafruit_SSD13065beginEhhbb+0x184>
    } else {                    // Soft SPI
      pinMode(mosiPin, OUTPUT); // MOSI and SCLK outputs
 80a07de:	f994 0033 	ldrsb.w	r0, [r4, #51]	; 0x33
 80a07e2:	2101      	movs	r1, #1
 80a07e4:	b280      	uxth	r0, r0
 80a07e6:	f003 f8c7 	bl	80a3978 <pinMode>
      pinMode(clkPin, OUTPUT);
 80a07ea:	f994 0034 	ldrsb.w	r0, [r4, #52]	; 0x34
 80a07ee:	2101      	movs	r1, #1
 80a07f0:	b280      	uxth	r0, r0
 80a07f2:	f003 f8c1 	bl	80a3978 <pinMode>
#ifdef HAVE_PORTREG
      mosiPort = (PortReg *)portOutputRegister(digitalPinToPort(mosiPin));
 80a07f6:	f000 ffe7 	bl	80a17c8 <HAL_Pin_Map>
 80a07fa:	f994 3033 	ldrsb.w	r3, [r4, #51]	; 0x33
 80a07fe:	436b      	muls	r3, r5
 80a0800:	58c3      	ldr	r3, [r0, r3]
 80a0802:	3314      	adds	r3, #20
 80a0804:	63a3      	str	r3, [r4, #56]	; 0x38
      mosiPinMask = digitalPinToBitMask(mosiPin);
 80a0806:	f000 ffdf 	bl	80a17c8 <HAL_Pin_Map>
 80a080a:	f994 3033 	ldrsb.w	r3, [r4, #51]	; 0x33
 80a080e:	fb05 0003 	mla	r0, r5, r3, r0
 80a0812:	8883      	ldrh	r3, [r0, #4]
 80a0814:	64a3      	str	r3, [r4, #72]	; 0x48
      clkPort = (PortReg *)portOutputRegister(digitalPinToPort(clkPin));
 80a0816:	f000 ffd7 	bl	80a17c8 <HAL_Pin_Map>
 80a081a:	f994 3034 	ldrsb.w	r3, [r4, #52]	; 0x34
 80a081e:	436b      	muls	r3, r5
 80a0820:	58c3      	ldr	r3, [r0, r3]
 80a0822:	3314      	adds	r3, #20
 80a0824:	63e3      	str	r3, [r4, #60]	; 0x3c
      clkPinMask = digitalPinToBitMask(clkPin);
 80a0826:	f000 ffcf 	bl	80a17c8 <HAL_Pin_Map>
 80a082a:	f994 3034 	ldrsb.w	r3, [r4, #52]	; 0x34
      *clkPort &= ~clkPinMask; // Clock low
 80a082e:	6be2      	ldr	r2, [r4, #60]	; 0x3c
      pinMode(clkPin, OUTPUT);
#ifdef HAVE_PORTREG
      mosiPort = (PortReg *)portOutputRegister(digitalPinToPort(mosiPin));
      mosiPinMask = digitalPinToBitMask(mosiPin);
      clkPort = (PortReg *)portOutputRegister(digitalPinToPort(clkPin));
      clkPinMask = digitalPinToBitMask(clkPin);
 80a0830:	fb05 0003 	mla	r0, r5, r3, r0
 80a0834:	8881      	ldrh	r1, [r0, #4]
 80a0836:	64e1      	str	r1, [r4, #76]	; 0x4c
      *clkPort &= ~clkPinMask; // Clock low
 80a0838:	6813      	ldr	r3, [r2, #0]
 80a083a:	ea23 0301 	bic.w	r3, r3, r1
 80a083e:	6013      	str	r3, [r2, #0]
#endif
    }
  }

  // Reset SSD1306 if requested and reset pin specified in constructor
  if (reset && (rstPin >= 0)) {
 80a0840:	b1fe      	cbz	r6, 80a0882 <_ZN16Adafruit_SSD13065beginEhhbb+0x1c6>
 80a0842:	f994 0037 	ldrsb.w	r0, [r4, #55]	; 0x37
 80a0846:	2800      	cmp	r0, #0
 80a0848:	db1b      	blt.n	80a0882 <_ZN16Adafruit_SSD13065beginEhhbb+0x1c6>
    pinMode(rstPin, OUTPUT);
 80a084a:	2101      	movs	r1, #1
 80a084c:	b280      	uxth	r0, r0
 80a084e:	f003 f893 	bl	80a3978 <pinMode>
    digitalWrite(rstPin, HIGH);
 80a0852:	f994 0037 	ldrsb.w	r0, [r4, #55]	; 0x37
 80a0856:	2101      	movs	r1, #1
 80a0858:	b280      	uxth	r0, r0
 80a085a:	f003 f89e 	bl	80a399a <digitalWrite>
    delay(1);                   // VDD goes high at start, pause for 1 ms
 80a085e:	2001      	movs	r0, #1
 80a0860:	f001 fcf0 	bl	80a2244 <delay>
    digitalWrite(rstPin, LOW);  // Bring reset low
 80a0864:	f994 0037 	ldrsb.w	r0, [r4, #55]	; 0x37
 80a0868:	2100      	movs	r1, #0
 80a086a:	b280      	uxth	r0, r0
 80a086c:	f003 f895 	bl	80a399a <digitalWrite>
    delay(10);                  // Wait 10 ms
 80a0870:	200a      	movs	r0, #10
 80a0872:	f001 fce7 	bl	80a2244 <delay>
    digitalWrite(rstPin, HIGH); // Bring out of reset
 80a0876:	f994 0037 	ldrsb.w	r0, [r4, #55]	; 0x37
 80a087a:	2101      	movs	r1, #1
 80a087c:	b280      	uxth	r0, r0
 80a087e:	f003 f88c 	bl	80a399a <digitalWrite>
  }

  TRANSACTION_START
 80a0882:	6aa0      	ldr	r0, [r4, #40]	; 0x28
 80a0884:	b118      	cbz	r0, 80a088e <_ZN16Adafruit_SSD13065beginEhhbb+0x1d2>
 80a0886:	6da1      	ldr	r1, [r4, #88]	; 0x58
 80a0888:	f001 fb76 	bl	80a1f78 <_ZN7TwoWire8setSpeedEm>
 80a088c:	e00b      	b.n	80a08a6 <_ZN16Adafruit_SSD13065beginEhhbb+0x1ea>
 80a088e:	6a60      	ldr	r0, [r4, #36]	; 0x24
 80a0890:	b118      	cbz	r0, 80a089a <_ZN16Adafruit_SSD13065beginEhhbb+0x1de>
 80a0892:	f104 0164 	add.w	r1, r4, #100	; 0x64
 80a0896:	f002 feef 	bl	80a3678 <_ZN8SPIClass16beginTransactionERKN8particle13__SPISettingsE>
 80a089a:	6c62      	ldr	r2, [r4, #68]	; 0x44
 80a089c:	6d61      	ldr	r1, [r4, #84]	; 0x54
 80a089e:	6813      	ldr	r3, [r2, #0]
 80a08a0:	ea23 0301 	bic.w	r3, r3, r1
 80a08a4:	6013      	str	r3, [r2, #0]
  // Init sequence
  static const uint8_t PROGMEM init1[] = {SSD1306_DISPLAYOFF,         // 0xAE
                                          SSD1306_SETDISPLAYCLOCKDIV, // 0xD5
                                          0x80, // the suggested ratio 0x80
                                          SSD1306_SETMULTIPLEX}; // 0xA8
  ssd1306_commandList(init1, sizeof(init1));
 80a08a6:	2204      	movs	r2, #4
 80a08a8:	493e      	ldr	r1, [pc, #248]	; (80a09a4 <_ZN16Adafruit_SSD13065beginEhhbb+0x2e8>)
 80a08aa:	4620      	mov	r0, r4
 80a08ac:	f7ff fe99 	bl	80a05e2 <_ZN16Adafruit_SSD130619ssd1306_commandListEPKhh>
  ssd1306_command1(HEIGHT - 1);
 80a08b0:	7aa1      	ldrb	r1, [r4, #10]
 80a08b2:	4620      	mov	r0, r4
 80a08b4:	3901      	subs	r1, #1
 80a08b6:	b2c9      	uxtb	r1, r1
 80a08b8:	f7ff fe24 	bl	80a0504 <_ZN16Adafruit_SSD130616ssd1306_command1Eh>

  static const uint8_t PROGMEM init2[] = {SSD1306_SETDISPLAYOFFSET, // 0xD3
                                          0x0,                      // no offset
                                          SSD1306_SETSTARTLINE | 0x0, // line #0
                                          SSD1306_CHARGEPUMP};        // 0x8D
  ssd1306_commandList(init2, sizeof(init2));
 80a08bc:	493a      	ldr	r1, [pc, #232]	; (80a09a8 <_ZN16Adafruit_SSD13065beginEhhbb+0x2ec>)
 80a08be:	2204      	movs	r2, #4
 80a08c0:	4620      	mov	r0, r4
 80a08c2:	f7ff fe8e 	bl	80a05e2 <_ZN16Adafruit_SSD130619ssd1306_commandListEPKhh>

  ssd1306_command1((vccstate == SSD1306_EXTERNALVCC) ? 0x10 : 0x14);
 80a08c6:	f994 3031 	ldrsb.w	r3, [r4, #49]	; 0x31
 80a08ca:	4620      	mov	r0, r4
 80a08cc:	2b01      	cmp	r3, #1
 80a08ce:	bf14      	ite	ne
 80a08d0:	2114      	movne	r1, #20
 80a08d2:	2110      	moveq	r1, #16
 80a08d4:	f7ff fe16 	bl	80a0504 <_ZN16Adafruit_SSD130616ssd1306_command1Eh>

  static const uint8_t PROGMEM init3[] = {SSD1306_MEMORYMODE, // 0x20
                                          0x00, // 0x0 act like ks0108
                                          SSD1306_SEGREMAP | 0x1,
                                          SSD1306_COMSCANDEC};
  ssd1306_commandList(init3, sizeof(init3));
 80a08d8:	2204      	movs	r2, #4
 80a08da:	4934      	ldr	r1, [pc, #208]	; (80a09ac <_ZN16Adafruit_SSD13065beginEhhbb+0x2f0>)
 80a08dc:	4620      	mov	r0, r4
 80a08de:	f7ff fe80 	bl	80a05e2 <_ZN16Adafruit_SSD130619ssd1306_commandListEPKhh>

  uint8_t comPins = 0x02;
  contrast = 0x8F;
 80a08e2:	238f      	movs	r3, #143	; 0x8f
 80a08e4:	f884 3060 	strb.w	r3, [r4, #96]	; 0x60

  if ((WIDTH == 128) && (HEIGHT == 32)) {
 80a08e8:	4a31      	ldr	r2, [pc, #196]	; (80a09b0 <_ZN16Adafruit_SSD13065beginEhhbb+0x2f4>)
 80a08ea:	68a3      	ldr	r3, [r4, #8]
 80a08ec:	4293      	cmp	r3, r2
 80a08ee:	d018      	beq.n	80a0922 <_ZN16Adafruit_SSD13065beginEhhbb+0x266>
    comPins = 0x02;
    contrast = 0x8F;
  } else if ((WIDTH == 128) && (HEIGHT == 64)) {
 80a08f0:	f502 1200 	add.w	r2, r2, #2097152	; 0x200000
 80a08f4:	4293      	cmp	r3, r2
 80a08f6:	d109      	bne.n	80a090c <_ZN16Adafruit_SSD13065beginEhhbb+0x250>
    comPins = 0x12;
    contrast = (vccstate == SSD1306_EXTERNALVCC) ? 0x9F : 0xCF;
 80a08f8:	f994 3031 	ldrsb.w	r3, [r4, #49]	; 0x31

  if ((WIDTH == 128) && (HEIGHT == 32)) {
    comPins = 0x02;
    contrast = 0x8F;
  } else if ((WIDTH == 128) && (HEIGHT == 64)) {
    comPins = 0x12;
 80a08fc:	2512      	movs	r5, #18
    contrast = (vccstate == SSD1306_EXTERNALVCC) ? 0x9F : 0xCF;
 80a08fe:	2b01      	cmp	r3, #1
 80a0900:	bf14      	ite	ne
 80a0902:	23cf      	movne	r3, #207	; 0xcf
 80a0904:	239f      	moveq	r3, #159	; 0x9f
 80a0906:	f884 3060 	strb.w	r3, [r4, #96]	; 0x60
 80a090a:	e00b      	b.n	80a0924 <_ZN16Adafruit_SSD13065beginEhhbb+0x268>
  } else if ((WIDTH == 96) && (HEIGHT == 16)) {
 80a090c:	4a29      	ldr	r2, [pc, #164]	; (80a09b4 <_ZN16Adafruit_SSD13065beginEhhbb+0x2f8>)
 80a090e:	4293      	cmp	r3, r2
 80a0910:	d107      	bne.n	80a0922 <_ZN16Adafruit_SSD13065beginEhhbb+0x266>
    comPins = 0x2; // ada x12
    contrast = (vccstate == SSD1306_EXTERNALVCC) ? 0x10 : 0xAF;
 80a0912:	f994 3031 	ldrsb.w	r3, [r4, #49]	; 0x31
 80a0916:	2b01      	cmp	r3, #1
 80a0918:	bf14      	ite	ne
 80a091a:	23af      	movne	r3, #175	; 0xaf
 80a091c:	2310      	moveq	r3, #16
 80a091e:	f884 3060 	strb.w	r3, [r4, #96]	; 0x60

  uint8_t comPins = 0x02;
  contrast = 0x8F;

  if ((WIDTH == 128) && (HEIGHT == 32)) {
    comPins = 0x02;
 80a0922:	2502      	movs	r5, #2
    contrast = (vccstate == SSD1306_EXTERNALVCC) ? 0x10 : 0xAF;
  } else {
    // Other screen varieties -- TBD
  }

  ssd1306_command1(SSD1306_SETCOMPINS);
 80a0924:	21da      	movs	r1, #218	; 0xda
 80a0926:	4620      	mov	r0, r4
 80a0928:	f7ff fdec 	bl	80a0504 <_ZN16Adafruit_SSD130616ssd1306_command1Eh>
  ssd1306_command1(comPins);
 80a092c:	4629      	mov	r1, r5
 80a092e:	4620      	mov	r0, r4
 80a0930:	f7ff fde8 	bl	80a0504 <_ZN16Adafruit_SSD130616ssd1306_command1Eh>
  ssd1306_command1(SSD1306_SETCONTRAST);
 80a0934:	2181      	movs	r1, #129	; 0x81
 80a0936:	4620      	mov	r0, r4
 80a0938:	f7ff fde4 	bl	80a0504 <_ZN16Adafruit_SSD130616ssd1306_command1Eh>
  ssd1306_command1(contrast);
 80a093c:	f894 1060 	ldrb.w	r1, [r4, #96]	; 0x60
 80a0940:	4620      	mov	r0, r4
 80a0942:	f7ff fddf 	bl	80a0504 <_ZN16Adafruit_SSD130616ssd1306_command1Eh>

  ssd1306_command1(SSD1306_SETPRECHARGE); // 0xd9
 80a0946:	21d9      	movs	r1, #217	; 0xd9
 80a0948:	4620      	mov	r0, r4
 80a094a:	f7ff fddb 	bl	80a0504 <_ZN16Adafruit_SSD130616ssd1306_command1Eh>
  ssd1306_command1((vccstate == SSD1306_EXTERNALVCC) ? 0x22 : 0xF1);
 80a094e:	f994 3031 	ldrsb.w	r3, [r4, #49]	; 0x31
 80a0952:	4620      	mov	r0, r4
 80a0954:	2b01      	cmp	r3, #1
 80a0956:	bf14      	ite	ne
 80a0958:	21f1      	movne	r1, #241	; 0xf1
 80a095a:	2122      	moveq	r1, #34	; 0x22
 80a095c:	f7ff fdd2 	bl	80a0504 <_ZN16Adafruit_SSD130616ssd1306_command1Eh>
      0x40,
      SSD1306_DISPLAYALLON_RESUME, // 0xA4
      SSD1306_NORMALDISPLAY,       // 0xA6
      SSD1306_DEACTIVATE_SCROLL,
      SSD1306_DISPLAYON}; // Main screen turn on
  ssd1306_commandList(init5, sizeof(init5));
 80a0960:	4620      	mov	r0, r4
 80a0962:	2206      	movs	r2, #6
 80a0964:	4914      	ldr	r1, [pc, #80]	; (80a09b8 <_ZN16Adafruit_SSD13065beginEhhbb+0x2fc>)
 80a0966:	f7ff fe3c 	bl	80a05e2 <_ZN16Adafruit_SSD130619ssd1306_commandListEPKhh>

  TRANSACTION_END
 80a096a:	6aa0      	ldr	r0, [r4, #40]	; 0x28
 80a096c:	b118      	cbz	r0, 80a0976 <_ZN16Adafruit_SSD13065beginEhhbb+0x2ba>
 80a096e:	6de1      	ldr	r1, [r4, #92]	; 0x5c
 80a0970:	f001 fb02 	bl	80a1f78 <_ZN7TwoWire8setSpeedEm>
 80a0974:	e008      	b.n	80a0988 <_ZN16Adafruit_SSD13065beginEhhbb+0x2cc>
 80a0976:	6c62      	ldr	r2, [r4, #68]	; 0x44
 80a0978:	6d63      	ldr	r3, [r4, #84]	; 0x54
 80a097a:	6811      	ldr	r1, [r2, #0]
 80a097c:	430b      	orrs	r3, r1
 80a097e:	6013      	str	r3, [r2, #0]
 80a0980:	6a60      	ldr	r0, [r4, #36]	; 0x24
 80a0982:	b108      	cbz	r0, 80a0988 <_ZN16Adafruit_SSD13065beginEhhbb+0x2cc>
 80a0984:	f002 fe5c 	bl	80a3640 <_ZN8SPIClass14endTransactionEv>

  return true; // Success
 80a0988:	2001      	movs	r0, #1
 80a098a:	e003      	b.n	80a0994 <_ZN16Adafruit_SSD13065beginEhhbb+0x2d8>
#endif
    }
  }

  // Reset SSD1306 if requested and reset pin specified in constructor
  if (reset && (rstPin >= 0)) {
 80a098c:	2e00      	cmp	r6, #0
 80a098e:	f47f af58 	bne.w	80a0842 <_ZN16Adafruit_SSD13065beginEhhbb+0x186>
 80a0992:	e778      	b.n	80a0886 <_ZN16Adafruit_SSD13065beginEhhbb+0x1ca>
  ssd1306_commandList(init5, sizeof(init5));

  TRANSACTION_END

  return true; // Success
}
 80a0994:	b004      	add	sp, #16
 80a0996:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 80a099a:	bf00      	nop
 80a099c:	080a405c 	.word	0x080a405c
 80a09a0:	080a431c 	.word	0x080a431c
 80a09a4:	080a3fe5 	.word	0x080a3fe5
 80a09a8:	080a3fe9 	.word	0x080a3fe9
 80a09ac:	080a3fed 	.word	0x080a3fed
 80a09b0:	00200080 	.word	0x00200080
 80a09b4:	00100060 	.word	0x00100060
 80a09b8:	080a3ff1 	.word	0x080a3ff1

080a09bc <_ZN16Adafruit_SSD130621drawFastHLineInternalEssst>:
  else
    drawFastHLineInternal(x, y, w, color);
}

void Adafruit_SSD1306::drawFastHLineInternal(int16_t x, int16_t y, int16_t w,
                                             uint16_t color) {
 80a09bc:	b570      	push	{r4, r5, r6, lr}

  if ((y >= 0) && (y < HEIGHT)) { // Y coord in bounds?
 80a09be:	2a00      	cmp	r2, #0
  else
    drawFastHLineInternal(x, y, w, color);
}

void Adafruit_SSD1306::drawFastHLineInternal(int16_t x, int16_t y, int16_t w,
                                             uint16_t color) {
 80a09c0:	f8bd 5010 	ldrh.w	r5, [sp, #16]

  if ((y >= 0) && (y < HEIGHT)) { // Y coord in bounds?
 80a09c4:	db44      	blt.n	80a0a50 <_ZN16Adafruit_SSD130621drawFastHLineInternalEssst+0x94>
 80a09c6:	f9b0 400a 	ldrsh.w	r4, [r0, #10]
 80a09ca:	4294      	cmp	r4, r2
 80a09cc:	dd40      	ble.n	80a0a50 <_ZN16Adafruit_SSD130621drawFastHLineInternalEssst+0x94>
    if (x < 0) {                  // Clip left
 80a09ce:	2900      	cmp	r1, #0
      w += x;
 80a09d0:	bfbe      	ittt	lt
 80a09d2:	185b      	addlt	r3, r3, r1
 80a09d4:	b21b      	sxthlt	r3, r3
      x = 0;
 80a09d6:	2100      	movlt	r1, #0
    }
    if ((x + w) > WIDTH) { // Clip right
 80a09d8:	f9b0 6008 	ldrsh.w	r6, [r0, #8]
 80a09dc:	185c      	adds	r4, r3, r1
 80a09de:	42b4      	cmp	r4, r6
      w = (WIDTH - x);
 80a09e0:	bfc4      	itt	gt
 80a09e2:	1a73      	subgt	r3, r6, r1
 80a09e4:	b21b      	sxthgt	r3, r3
    }
    if (w > 0) { // Proceed only if width is positive
 80a09e6:	2b00      	cmp	r3, #0
 80a09e8:	dd32      	ble.n	80a0a50 <_ZN16Adafruit_SSD130621drawFastHLineInternalEssst+0x94>
      uint8_t *pBuf = &buffer[(y / 8) * WIDTH + x], mask = 1 << (y & 7);
 80a09ea:	2408      	movs	r4, #8
 80a09ec:	fb92 f4f4 	sdiv	r4, r2, r4
 80a09f0:	fb06 1104 	mla	r1, r6, r4, r1
 80a09f4:	6ac0      	ldr	r0, [r0, #44]	; 0x2c
 80a09f6:	f002 0207 	and.w	r2, r2, #7
 80a09fa:	4408      	add	r0, r1
 80a09fc:	2101      	movs	r1, #1
 80a09fe:	fa01 f202 	lsl.w	r2, r1, r2
      switch (color) {
 80a0a02:	428d      	cmp	r5, r1
    }
    if ((x + w) > WIDTH) { // Clip right
      w = (WIDTH - x);
    }
    if (w > 0) { // Proceed only if width is positive
      uint8_t *pBuf = &buffer[(y / 8) * WIDTH + x], mask = 1 << (y & 7);
 80a0a04:	b2d2      	uxtb	r2, r2
      switch (color) {
 80a0a06:	d003      	beq.n	80a0a10 <_ZN16Adafruit_SSD130621drawFastHLineInternalEssst+0x54>
 80a0a08:	d30c      	bcc.n	80a0a24 <_ZN16Adafruit_SSD130621drawFastHLineInternalEssst+0x68>
 80a0a0a:	2d02      	cmp	r5, #2
 80a0a0c:	d016      	beq.n	80a0a3c <_ZN16Adafruit_SSD130621drawFastHLineInternalEssst+0x80>
 80a0a0e:	bd70      	pop	{r4, r5, r6, pc}
 80a0a10:	3b01      	subs	r3, #1
 80a0a12:	b21b      	sxth	r3, r3
      case SSD1306_WHITE:
        while (w--) {
 80a0a14:	1c5d      	adds	r5, r3, #1
 80a0a16:	d01b      	beq.n	80a0a50 <_ZN16Adafruit_SSD130621drawFastHLineInternalEssst+0x94>
          *pBuf++ |= mask;
 80a0a18:	f810 1b01 	ldrb.w	r1, [r0], #1
 80a0a1c:	4311      	orrs	r1, r2
 80a0a1e:	f800 1c01 	strb.w	r1, [r0, #-1]
 80a0a22:	e7f5      	b.n	80a0a10 <_ZN16Adafruit_SSD130621drawFastHLineInternalEssst+0x54>
        };
        break;
      case SSD1306_BLACK:
        mask = ~mask;
 80a0a24:	43d2      	mvns	r2, r2
 80a0a26:	b2d2      	uxtb	r2, r2
 80a0a28:	3b01      	subs	r3, #1
 80a0a2a:	b21b      	sxth	r3, r3
        while (w--) {
 80a0a2c:	1c5c      	adds	r4, r3, #1
 80a0a2e:	d00f      	beq.n	80a0a50 <_ZN16Adafruit_SSD130621drawFastHLineInternalEssst+0x94>
          *pBuf++ &= mask;
 80a0a30:	f810 1b01 	ldrb.w	r1, [r0], #1
 80a0a34:	4011      	ands	r1, r2
 80a0a36:	f800 1c01 	strb.w	r1, [r0, #-1]
 80a0a3a:	e7f5      	b.n	80a0a28 <_ZN16Adafruit_SSD130621drawFastHLineInternalEssst+0x6c>
 80a0a3c:	3b01      	subs	r3, #1
 80a0a3e:	b21b      	sxth	r3, r3
        };
        break;
      case SSD1306_INVERSE:
        while (w--) {
 80a0a40:	1c59      	adds	r1, r3, #1
 80a0a42:	d005      	beq.n	80a0a50 <_ZN16Adafruit_SSD130621drawFastHLineInternalEssst+0x94>
          *pBuf++ ^= mask;
 80a0a44:	f810 1b01 	ldrb.w	r1, [r0], #1
 80a0a48:	4051      	eors	r1, r2
 80a0a4a:	f800 1c01 	strb.w	r1, [r0, #-1]
 80a0a4e:	e7f5      	b.n	80a0a3c <_ZN16Adafruit_SSD130621drawFastHLineInternalEssst+0x80>
 80a0a50:	bd70      	pop	{r4, r5, r6, pc}
	...

080a0a54 <_ZN16Adafruit_SSD130621drawFastVLineInternalEssst>:
  else
    drawFastVLineInternal(x, y, h, color);
}

void Adafruit_SSD1306::drawFastVLineInternal(int16_t x, int16_t __y,
                                             int16_t __h, uint16_t color) {
 80a0a54:	b5f0      	push	{r4, r5, r6, r7, lr}

  if ((x >= 0) && (x < WIDTH)) { // X coord in bounds?
 80a0a56:	2900      	cmp	r1, #0
  else
    drawFastVLineInternal(x, y, h, color);
}

void Adafruit_SSD1306::drawFastVLineInternal(int16_t x, int16_t __y,
                                             int16_t __h, uint16_t color) {
 80a0a58:	f8bd 5014 	ldrh.w	r5, [sp, #20]

  if ((x >= 0) && (x < WIDTH)) { // X coord in bounds?
 80a0a5c:	f2c0 8088 	blt.w	80a0b70 <_ZN16Adafruit_SSD130621drawFastVLineInternalEssst+0x11c>
 80a0a60:	f9b0 e008 	ldrsh.w	lr, [r0, #8]
 80a0a64:	4571      	cmp	r1, lr
 80a0a66:	f280 8083 	bge.w	80a0b70 <_ZN16Adafruit_SSD130621drawFastVLineInternalEssst+0x11c>
    if (__y < 0) {               // Clip top
 80a0a6a:	2a00      	cmp	r2, #0
      __h += __y;
 80a0a6c:	bfbe      	ittt	lt
 80a0a6e:	189b      	addlt	r3, r3, r2
 80a0a70:	b21b      	sxthlt	r3, r3
      __y = 0;
 80a0a72:	2200      	movlt	r2, #0
    }
    if ((__y + __h) > HEIGHT) { // Clip bottom
 80a0a74:	f9b0 400a 	ldrsh.w	r4, [r0, #10]
 80a0a78:	18d6      	adds	r6, r2, r3
 80a0a7a:	42a6      	cmp	r6, r4
      __h = (HEIGHT - __y);
 80a0a7c:	bfc4      	itt	gt
 80a0a7e:	1aa3      	subgt	r3, r4, r2
 80a0a80:	b21b      	sxthgt	r3, r3
    }
    if (__h > 0) { // Proceed only if height is now positive
 80a0a82:	2b00      	cmp	r3, #0
 80a0a84:	dd74      	ble.n	80a0b70 <_ZN16Adafruit_SSD130621drawFastVLineInternalEssst+0x11c>
      // this display doesn't need ints for coordinates,
      // use local byte registers for faster juggling
      uint8_t y = __y, h = __h;
 80a0a86:	b2d2      	uxtb	r2, r2
      uint8_t *pBuf = &buffer[(y / 8) * WIDTH + x];
 80a0a88:	08d4      	lsrs	r4, r2, #3
 80a0a8a:	fb0e 1104 	mla	r1, lr, r4, r1
 80a0a8e:	6ac6      	ldr	r6, [r0, #44]	; 0x2c

      // do the first partial byte, if necessary - this requires some masking
      uint8_t mod = (y & 7);
      if (mod) {
 80a0a90:	f012 0207 	ands.w	r2, r2, #7
      __h = (HEIGHT - __y);
    }
    if (__h > 0) { // Proceed only if height is now positive
      // this display doesn't need ints for coordinates,
      // use local byte registers for faster juggling
      uint8_t y = __y, h = __h;
 80a0a94:	b2db      	uxtb	r3, r3
      uint8_t *pBuf = &buffer[(y / 8) * WIDTH + x];
 80a0a96:	eb06 0401 	add.w	r4, r6, r1

      // do the first partial byte, if necessary - this requires some masking
      uint8_t mod = (y & 7);
      if (mod) {
 80a0a9a:	d02b      	beq.n	80a0af4 <_ZN16Adafruit_SSD130621drawFastVLineInternalEssst+0xa0>
        // mask off the high n bits we want to set
        mod = 8 - mod;
 80a0a9c:	f1c2 0208 	rsb	r2, r2, #8
 80a0aa0:	b2d2      	uxtb	r2, r2
        // note - lookup table results in a nearly 10% performance
        // improvement in fill* functions
        // uint8_t mask = ~(0xFF >> mod);
        static const uint8_t PROGMEM premask[8] = {0x00, 0x80, 0xC0, 0xE0,
                                                   0xF0, 0xF8, 0xFC, 0xFE};
        uint8_t mask = pgm_read_byte(&premask[mod]);
 80a0aa2:	4f34      	ldr	r7, [pc, #208]	; (80a0b74 <_ZN16Adafruit_SSD130621drawFastVLineInternalEssst+0x120>)
        // adjust the mask if we're not going to reach the end of this byte
        if (h < mod)
 80a0aa4:	4293      	cmp	r3, r2
        // note - lookup table results in a nearly 10% performance
        // improvement in fill* functions
        // uint8_t mask = ~(0xFF >> mod);
        static const uint8_t PROGMEM premask[8] = {0x00, 0x80, 0xC0, 0xE0,
                                                   0xF0, 0xF8, 0xFC, 0xFE};
        uint8_t mask = pgm_read_byte(&premask[mod]);
 80a0aa6:	5cbf      	ldrb	r7, [r7, r2]
        // adjust the mask if we're not going to reach the end of this byte
        if (h < mod)
 80a0aa8:	d20d      	bcs.n	80a0ac6 <_ZN16Adafruit_SSD130621drawFastVLineInternalEssst+0x72>
          mask &= (0XFF >> (mod - h));
 80a0aaa:	ebc3 0c02 	rsb	ip, r3, r2
 80a0aae:	f04f 0eff 	mov.w	lr, #255	; 0xff
 80a0ab2:	fa4e fe0c 	asr.w	lr, lr, ip

        switch (color) {
 80a0ab6:	2d01      	cmp	r5, #1
        static const uint8_t PROGMEM premask[8] = {0x00, 0x80, 0xC0, 0xE0,
                                                   0xF0, 0xF8, 0xFC, 0xFE};
        uint8_t mask = pgm_read_byte(&premask[mod]);
        // adjust the mask if we're not going to reach the end of this byte
        if (h < mod)
          mask &= (0XFF >> (mod - h));
 80a0ab8:	ea0e 0707 	and.w	r7, lr, r7

        switch (color) {
 80a0abc:	d005      	beq.n	80a0aca <_ZN16Adafruit_SSD130621drawFastVLineInternalEssst+0x76>
 80a0abe:	d30a      	bcc.n	80a0ad6 <_ZN16Adafruit_SSD130621drawFastVLineInternalEssst+0x82>
 80a0ac0:	2d02      	cmp	r5, #2
 80a0ac2:	d155      	bne.n	80a0b70 <_ZN16Adafruit_SSD130621drawFastVLineInternalEssst+0x11c>
 80a0ac4:	e00c      	b.n	80a0ae0 <_ZN16Adafruit_SSD130621drawFastVLineInternalEssst+0x8c>
 80a0ac6:	2d01      	cmp	r5, #1
 80a0ac8:	d104      	bne.n	80a0ad4 <_ZN16Adafruit_SSD130621drawFastVLineInternalEssst+0x80>
        case SSD1306_WHITE:
          *pBuf |= mask;
 80a0aca:	f816 e001 	ldrb.w	lr, [r6, r1]
 80a0ace:	ea47 070e 	orr.w	r7, r7, lr
 80a0ad2:	e009      	b.n	80a0ae8 <_ZN16Adafruit_SSD130621drawFastVLineInternalEssst+0x94>
        uint8_t mask = pgm_read_byte(&premask[mod]);
        // adjust the mask if we're not going to reach the end of this byte
        if (h < mod)
          mask &= (0XFF >> (mod - h));

        switch (color) {
 80a0ad4:	d248      	bcs.n	80a0b68 <_ZN16Adafruit_SSD130621drawFastVLineInternalEssst+0x114>
        case SSD1306_WHITE:
          *pBuf |= mask;
          break;
        case SSD1306_BLACK:
          *pBuf &= ~mask;
 80a0ad6:	f816 e001 	ldrb.w	lr, [r6, r1]
 80a0ada:	ea2e 0707 	bic.w	r7, lr, r7
 80a0ade:	e003      	b.n	80a0ae8 <_ZN16Adafruit_SSD130621drawFastVLineInternalEssst+0x94>
          break;
        case SSD1306_INVERSE:
          *pBuf ^= mask;
 80a0ae0:	f816 e001 	ldrb.w	lr, [r6, r1]
 80a0ae4:	ea87 070e 	eor.w	r7, r7, lr
          break;
        }
        pBuf += WIDTH;
      }

      if (h >= mod) { // More to go?
 80a0ae8:	4293      	cmp	r3, r2
          break;
        case SSD1306_BLACK:
          *pBuf &= ~mask;
          break;
        case SSD1306_INVERSE:
          *pBuf ^= mask;
 80a0aea:	5477      	strb	r7, [r6, r1]
          break;
        }
        pBuf += WIDTH;
      }

      if (h >= mod) { // More to go?
 80a0aec:	d340      	bcc.n	80a0b70 <_ZN16Adafruit_SSD130621drawFastVLineInternalEssst+0x11c>
          break;
        case SSD1306_INVERSE:
          *pBuf ^= mask;
          break;
        }
        pBuf += WIDTH;
 80a0aee:	f9b0 1008 	ldrsh.w	r1, [r0, #8]
 80a0af2:	440c      	add	r4, r1
      }

      if (h >= mod) { // More to go?
        h -= mod;
 80a0af4:	1a9b      	subs	r3, r3, r2
 80a0af6:	b2db      	uxtb	r3, r3
        // Write solid bytes while we can - effectively 8 rows at a time
        if (h >= 8) {
 80a0af8:	2b07      	cmp	r3, #7
 80a0afa:	d91c      	bls.n	80a0b36 <_ZN16Adafruit_SSD130621drawFastVLineInternalEssst+0xe2>
          if (color == SSD1306_INVERSE) {
 80a0afc:	2d02      	cmp	r5, #2
 80a0afe:	d10b      	bne.n	80a0b18 <_ZN16Adafruit_SSD130621drawFastVLineInternalEssst+0xc4>
 80a0b00:	461a      	mov	r2, r3
            // separate copy of the code so we don't impact performance of
            // black/white write version with an extra comparison per loop
            do {
              *pBuf ^= 0xFF; // Invert byte
 80a0b02:	7821      	ldrb	r1, [r4, #0]
              pBuf += WIDTH; // Advance pointer 8 rows
              h -= 8;        // Subtract 8 rows from height
 80a0b04:	3a08      	subs	r2, #8
        if (h >= 8) {
          if (color == SSD1306_INVERSE) {
            // separate copy of the code so we don't impact performance of
            // black/white write version with an extra comparison per loop
            do {
              *pBuf ^= 0xFF; // Invert byte
 80a0b06:	43c9      	mvns	r1, r1
 80a0b08:	7021      	strb	r1, [r4, #0]
              pBuf += WIDTH; // Advance pointer 8 rows
 80a0b0a:	f9b0 1008 	ldrsh.w	r1, [r0, #8]
              h -= 8;        // Subtract 8 rows from height
 80a0b0e:	b2d2      	uxtb	r2, r2
            } while (h >= 8);
 80a0b10:	2a07      	cmp	r2, #7
          if (color == SSD1306_INVERSE) {
            // separate copy of the code so we don't impact performance of
            // black/white write version with an extra comparison per loop
            do {
              *pBuf ^= 0xFF; // Invert byte
              pBuf += WIDTH; // Advance pointer 8 rows
 80a0b12:	440c      	add	r4, r1
              h -= 8;        // Subtract 8 rows from height
            } while (h >= 8);
 80a0b14:	d8f5      	bhi.n	80a0b02 <_ZN16Adafruit_SSD130621drawFastVLineInternalEssst+0xae>
 80a0b16:	e01e      	b.n	80a0b56 <_ZN16Adafruit_SSD130621drawFastVLineInternalEssst+0x102>
          } else {
            // store a local value to work with
            uint8_t val = (color != SSD1306_BLACK) ? 255 : 0;
 80a0b18:	2d00      	cmp	r5, #0
 80a0b1a:	bf14      	ite	ne
 80a0b1c:	26ff      	movne	r6, #255	; 0xff
 80a0b1e:	2600      	moveq	r6, #0
 80a0b20:	461a      	mov	r2, r3
            do {
              *pBuf = val;   // Set byte
 80a0b22:	7026      	strb	r6, [r4, #0]
              pBuf += WIDTH; // Advance pointer 8 rows
              h -= 8;        // Subtract 8 rows from height
 80a0b24:	3a08      	subs	r2, #8
          } else {
            // store a local value to work with
            uint8_t val = (color != SSD1306_BLACK) ? 255 : 0;
            do {
              *pBuf = val;   // Set byte
              pBuf += WIDTH; // Advance pointer 8 rows
 80a0b26:	f9b0 1008 	ldrsh.w	r1, [r0, #8]
              h -= 8;        // Subtract 8 rows from height
 80a0b2a:	b2d2      	uxtb	r2, r2
            } while (h >= 8);
 80a0b2c:	2a07      	cmp	r2, #7
          } else {
            // store a local value to work with
            uint8_t val = (color != SSD1306_BLACK) ? 255 : 0;
            do {
              *pBuf = val;   // Set byte
              pBuf += WIDTH; // Advance pointer 8 rows
 80a0b2e:	440c      	add	r4, r1
              h -= 8;        // Subtract 8 rows from height
            } while (h >= 8);
 80a0b30:	d8f7      	bhi.n	80a0b22 <_ZN16Adafruit_SSD130621drawFastVLineInternalEssst+0xce>
 80a0b32:	f003 0307 	and.w	r3, r3, #7
          }
        }

        if (h) { // Do the final partial byte, if necessary
 80a0b36:	b1db      	cbz	r3, 80a0b70 <_ZN16Adafruit_SSD130621drawFastVLineInternalEssst+0x11c>
          // uint8_t mask = (1 << mod) - 1;
          // note - lookup table results in a nearly 10% performance
          // improvement in fill* functions
          static const uint8_t PROGMEM postmask[8] = {0x00, 0x01, 0x03, 0x07,
                                                      0x0F, 0x1F, 0x3F, 0x7F};
          uint8_t mask = pgm_read_byte(&postmask[mod]);
 80a0b38:	4a0f      	ldr	r2, [pc, #60]	; (80a0b78 <_ZN16Adafruit_SSD130621drawFastVLineInternalEssst+0x124>)
          switch (color) {
 80a0b3a:	2d01      	cmp	r5, #1
          // uint8_t mask = (1 << mod) - 1;
          // note - lookup table results in a nearly 10% performance
          // improvement in fill* functions
          static const uint8_t PROGMEM postmask[8] = {0x00, 0x01, 0x03, 0x07,
                                                      0x0F, 0x1F, 0x3F, 0x7F};
          uint8_t mask = pgm_read_byte(&postmask[mod]);
 80a0b3c:	5cd3      	ldrb	r3, [r2, r3]
          switch (color) {
 80a0b3e:	d003      	beq.n	80a0b48 <_ZN16Adafruit_SSD130621drawFastVLineInternalEssst+0xf4>
 80a0b40:	d305      	bcc.n	80a0b4e <_ZN16Adafruit_SSD130621drawFastVLineInternalEssst+0xfa>
 80a0b42:	2d02      	cmp	r5, #2
 80a0b44:	d114      	bne.n	80a0b70 <_ZN16Adafruit_SSD130621drawFastVLineInternalEssst+0x11c>
 80a0b46:	e00b      	b.n	80a0b60 <_ZN16Adafruit_SSD130621drawFastVLineInternalEssst+0x10c>
          case SSD1306_WHITE:
            *pBuf |= mask;
 80a0b48:	7822      	ldrb	r2, [r4, #0]
 80a0b4a:	4313      	orrs	r3, r2
 80a0b4c:	e00a      	b.n	80a0b64 <_ZN16Adafruit_SSD130621drawFastVLineInternalEssst+0x110>
            break;
          case SSD1306_BLACK:
            *pBuf &= ~mask;
 80a0b4e:	7822      	ldrb	r2, [r4, #0]
 80a0b50:	ea22 0303 	bic.w	r3, r2, r3
 80a0b54:	e006      	b.n	80a0b64 <_ZN16Adafruit_SSD130621drawFastVLineInternalEssst+0x110>
              h -= 8;        // Subtract 8 rows from height
            } while (h >= 8);
          }
        }

        if (h) { // Do the final partial byte, if necessary
 80a0b56:	f013 0307 	ands.w	r3, r3, #7
 80a0b5a:	d009      	beq.n	80a0b70 <_ZN16Adafruit_SSD130621drawFastVLineInternalEssst+0x11c>
          // uint8_t mask = (1 << mod) - 1;
          // note - lookup table results in a nearly 10% performance
          // improvement in fill* functions
          static const uint8_t PROGMEM postmask[8] = {0x00, 0x01, 0x03, 0x07,
                                                      0x0F, 0x1F, 0x3F, 0x7F};
          uint8_t mask = pgm_read_byte(&postmask[mod]);
 80a0b5c:	4a06      	ldr	r2, [pc, #24]	; (80a0b78 <_ZN16Adafruit_SSD130621drawFastVLineInternalEssst+0x124>)
 80a0b5e:	5cd3      	ldrb	r3, [r2, r3]
            break;
          case SSD1306_BLACK:
            *pBuf &= ~mask;
            break;
          case SSD1306_INVERSE:
            *pBuf ^= mask;
 80a0b60:	7822      	ldrb	r2, [r4, #0]
 80a0b62:	4053      	eors	r3, r2
 80a0b64:	7023      	strb	r3, [r4, #0]
          }
        }
      }
    } // endif positive height
  }   // endif x in bounds
}
 80a0b66:	bdf0      	pop	{r4, r5, r6, r7, pc}
        uint8_t mask = pgm_read_byte(&premask[mod]);
        // adjust the mask if we're not going to reach the end of this byte
        if (h < mod)
          mask &= (0XFF >> (mod - h));

        switch (color) {
 80a0b68:	2d02      	cmp	r5, #2
 80a0b6a:	d0b9      	beq.n	80a0ae0 <_ZN16Adafruit_SSD130621drawFastVLineInternalEssst+0x8c>
          break;
        case SSD1306_INVERSE:
          *pBuf ^= mask;
          break;
        }
        pBuf += WIDTH;
 80a0b6c:	4474      	add	r4, lr
 80a0b6e:	e7c1      	b.n	80a0af4 <_ZN16Adafruit_SSD130621drawFastVLineInternalEssst+0xa0>
 80a0b70:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80a0b72:	bf00      	nop
 80a0b74:	080a3ff7 	.word	0x080a3ff7
 80a0b78:	080a3f98 	.word	0x080a3f98

080a0b7c <_ZN16Adafruit_SSD130613drawFastHLineEssst>:
    @note   Changes buffer contents only, no immediate effect on display.
            Follow up with a call to display(), or with other graphics
            commands as needed by one's own application.
*/
void Adafruit_SSD1306::drawFastHLine(int16_t x, int16_t y, int16_t w,
                                     uint16_t color) {
 80a0b7c:	b470      	push	{r4, r5, r6}
  bool bSwap = false;
  switch (rotation) {
 80a0b7e:	7e84      	ldrb	r4, [r0, #26]
    @note   Changes buffer contents only, no immediate effect on display.
            Follow up with a call to display(), or with other graphics
            commands as needed by one's own application.
*/
void Adafruit_SSD1306::drawFastHLine(int16_t x, int16_t y, int16_t w,
                                     uint16_t color) {
 80a0b80:	f8bd 600c 	ldrh.w	r6, [sp, #12]
  bool bSwap = false;
  switch (rotation) {
 80a0b84:	2c02      	cmp	r4, #2
 80a0b86:	d008      	beq.n	80a0b9a <_ZN16Adafruit_SSD130613drawFastHLineEssst+0x1e>
 80a0b88:	2c03      	cmp	r4, #3
 80a0b8a:	d00f      	beq.n	80a0bac <_ZN16Adafruit_SSD130613drawFastHLineEssst+0x30>
 80a0b8c:	2c01      	cmp	r4, #1
 80a0b8e:	d118      	bne.n	80a0bc2 <_ZN16Adafruit_SSD130613drawFastHLineEssst+0x46>
  case 1:
    // 90 degree rotation, swap x & y for rotation, then invert x
    bSwap = true;
    ssd1306_swap(x, y);
    x = WIDTH - x - 1;
 80a0b90:	8905      	ldrh	r5, [r0, #8]
 80a0b92:	3d01      	subs	r5, #1
 80a0b94:	1aac      	subs	r4, r5, r2
 80a0b96:	b224      	sxth	r4, r4
    break;
 80a0b98:	e00d      	b.n	80a0bb6 <_ZN16Adafruit_SSD130613drawFastHLineEssst+0x3a>
  case 2:
    // 180 degree rotation, invert x and y, then shift y around for height.
    x = WIDTH - x - 1;
    y = HEIGHT - y - 1;
 80a0b9a:	8944      	ldrh	r4, [r0, #10]
 80a0b9c:	3c01      	subs	r4, #1
 80a0b9e:	1aa4      	subs	r4, r4, r2
 80a0ba0:	b222      	sxth	r2, r4
    x -= (w - 1);
 80a0ba2:	8904      	ldrh	r4, [r0, #8]
 80a0ba4:	1a61      	subs	r1, r4, r1
 80a0ba6:	1ac9      	subs	r1, r1, r3
 80a0ba8:	b209      	sxth	r1, r1
    break;
 80a0baa:	e00a      	b.n	80a0bc2 <_ZN16Adafruit_SSD130613drawFastHLineEssst+0x46>
  case 3:
    // 270 degree rotation, swap x & y for rotation,
    // then invert y and adjust y for w (not to become h)
    bSwap = true;
    ssd1306_swap(x, y);
 80a0bac:	4614      	mov	r4, r2
    y = HEIGHT - y - 1;
    y -= (w - 1);
 80a0bae:	8942      	ldrh	r2, [r0, #10]
 80a0bb0:	1ad2      	subs	r2, r2, r3
 80a0bb2:	1a51      	subs	r1, r2, r1
 80a0bb4:	b209      	sxth	r1, r1
    break;
  }

  if (bSwap)
    drawFastVLineInternal(x, y, w, color);
 80a0bb6:	9603      	str	r6, [sp, #12]
 80a0bb8:	460a      	mov	r2, r1
 80a0bba:	4621      	mov	r1, r4
  else
    drawFastHLineInternal(x, y, w, color);
}
 80a0bbc:	bc70      	pop	{r4, r5, r6}
    y -= (w - 1);
    break;
  }

  if (bSwap)
    drawFastVLineInternal(x, y, w, color);
 80a0bbe:	f7ff bf49 	b.w	80a0a54 <_ZN16Adafruit_SSD130621drawFastVLineInternalEssst>
  else
    drawFastHLineInternal(x, y, w, color);
 80a0bc2:	9603      	str	r6, [sp, #12]
}
 80a0bc4:	bc70      	pop	{r4, r5, r6}
  }

  if (bSwap)
    drawFastVLineInternal(x, y, w, color);
  else
    drawFastHLineInternal(x, y, w, color);
 80a0bc6:	f7ff bef9 	b.w	80a09bc <_ZN16Adafruit_SSD130621drawFastHLineInternalEssst>

080a0bca <_ZN16Adafruit_SSD130613drawFastVLineEssst>:
    @note   Changes buffer contents only, no immediate effect on display.
            Follow up with a call to display(), or with other graphics
            commands as needed by one's own application.
*/
void Adafruit_SSD1306::drawFastVLine(int16_t x, int16_t y, int16_t h,
                                     uint16_t color) {
 80a0bca:	b430      	push	{r4, r5}
  bool bSwap = false;
  switch (rotation) {
 80a0bcc:	7e84      	ldrb	r4, [r0, #26]
    @note   Changes buffer contents only, no immediate effect on display.
            Follow up with a call to display(), or with other graphics
            commands as needed by one's own application.
*/
void Adafruit_SSD1306::drawFastVLine(int16_t x, int16_t y, int16_t h,
                                     uint16_t color) {
 80a0bce:	f8bd 5008 	ldrh.w	r5, [sp, #8]
  bool bSwap = false;
  switch (rotation) {
 80a0bd2:	2c02      	cmp	r4, #2
 80a0bd4:	d008      	beq.n	80a0be8 <_ZN16Adafruit_SSD130613drawFastVLineEssst+0x1e>
 80a0bd6:	2c03      	cmp	r4, #3
 80a0bd8:	d00f      	beq.n	80a0bfa <_ZN16Adafruit_SSD130613drawFastVLineEssst+0x30>
 80a0bda:	2c01      	cmp	r4, #1
 80a0bdc:	d118      	bne.n	80a0c10 <_ZN16Adafruit_SSD130613drawFastVLineEssst+0x46>
    // 90 degree rotation, swap x & y for rotation,
    // then invert x and adjust x for h (now to become w)
    bSwap = true;
    ssd1306_swap(x, y);
    x = WIDTH - x - 1;
    x -= (h - 1);
 80a0bde:	8904      	ldrh	r4, [r0, #8]
 80a0be0:	1ae4      	subs	r4, r4, r3
 80a0be2:	1aa2      	subs	r2, r4, r2
 80a0be4:	b214      	sxth	r4, r2
    break;
 80a0be6:	e00d      	b.n	80a0c04 <_ZN16Adafruit_SSD130613drawFastVLineEssst+0x3a>
  case 2:
    // 180 degree rotation, invert x and y, then shift y around for height.
    x = WIDTH - x - 1;
 80a0be8:	8904      	ldrh	r4, [r0, #8]
 80a0bea:	3c01      	subs	r4, #1
 80a0bec:	1a61      	subs	r1, r4, r1
    y = HEIGHT - y - 1;
    y -= (h - 1);
 80a0bee:	8944      	ldrh	r4, [r0, #10]
    x = WIDTH - x - 1;
    x -= (h - 1);
    break;
  case 2:
    // 180 degree rotation, invert x and y, then shift y around for height.
    x = WIDTH - x - 1;
 80a0bf0:	b209      	sxth	r1, r1
    y = HEIGHT - y - 1;
    y -= (h - 1);
 80a0bf2:	1aa2      	subs	r2, r4, r2
 80a0bf4:	1ad2      	subs	r2, r2, r3
 80a0bf6:	b212      	sxth	r2, r2
    break;
 80a0bf8:	e00a      	b.n	80a0c10 <_ZN16Adafruit_SSD130613drawFastVLineEssst+0x46>
  case 3:
    // 270 degree rotation, swap x & y for rotation, then invert y
    bSwap = true;
    ssd1306_swap(x, y);
 80a0bfa:	4614      	mov	r4, r2
    y = HEIGHT - y - 1;
 80a0bfc:	8942      	ldrh	r2, [r0, #10]
 80a0bfe:	3a01      	subs	r2, #1
 80a0c00:	1a51      	subs	r1, r2, r1
 80a0c02:	b209      	sxth	r1, r1
    break;
  }

  if (bSwap)
    drawFastHLineInternal(x, y, h, color);
 80a0c04:	9502      	str	r5, [sp, #8]
 80a0c06:	460a      	mov	r2, r1
 80a0c08:	4621      	mov	r1, r4
  else
    drawFastVLineInternal(x, y, h, color);
}
 80a0c0a:	bc30      	pop	{r4, r5}
    y = HEIGHT - y - 1;
    break;
  }

  if (bSwap)
    drawFastHLineInternal(x, y, h, color);
 80a0c0c:	f7ff bed6 	b.w	80a09bc <_ZN16Adafruit_SSD130621drawFastHLineInternalEssst>
  else
    drawFastVLineInternal(x, y, h, color);
 80a0c10:	9502      	str	r5, [sp, #8]
}
 80a0c12:	bc30      	pop	{r4, r5}
  }

  if (bSwap)
    drawFastHLineInternal(x, y, h, color);
  else
    drawFastVLineInternal(x, y, h, color);
 80a0c14:	f7ff bf1e 	b.w	80a0a54 <_ZN16Adafruit_SSD130621drawFastVLineInternalEssst>

080a0c18 <_ZN16Adafruit_SSD13067displayEv>:
    @return None (void).
    @note   Drawing operations are not visible until this function is
            called. Call after each graphics command, or after a whole set
            of graphics commands, as best needed by one's own application.
*/
void Adafruit_SSD1306::display(void) {
 80a0c18:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80a0c1a:	4604      	mov	r4, r0
  TRANSACTION_START
 80a0c1c:	6a80      	ldr	r0, [r0, #40]	; 0x28
 80a0c1e:	b118      	cbz	r0, 80a0c28 <_ZN16Adafruit_SSD13067displayEv+0x10>
 80a0c20:	6da1      	ldr	r1, [r4, #88]	; 0x58
 80a0c22:	f001 f9a9 	bl	80a1f78 <_ZN7TwoWire8setSpeedEm>
 80a0c26:	e00b      	b.n	80a0c40 <_ZN16Adafruit_SSD13067displayEv+0x28>
 80a0c28:	6a60      	ldr	r0, [r4, #36]	; 0x24
 80a0c2a:	b118      	cbz	r0, 80a0c34 <_ZN16Adafruit_SSD13067displayEv+0x1c>
 80a0c2c:	f104 0164 	add.w	r1, r4, #100	; 0x64
 80a0c30:	f002 fd22 	bl	80a3678 <_ZN8SPIClass16beginTransactionERKN8particle13__SPISettingsE>
 80a0c34:	6c62      	ldr	r2, [r4, #68]	; 0x44
 80a0c36:	6d61      	ldr	r1, [r4, #84]	; 0x54
 80a0c38:	6813      	ldr	r3, [r2, #0]
 80a0c3a:	ea23 0301 	bic.w	r3, r3, r1
 80a0c3e:	6013      	str	r3, [r2, #0]
  static const uint8_t PROGMEM dlist1[] = {
      SSD1306_PAGEADDR,
      0,                      // Page start address
      0xFF,                   // Page end (not really, but works here)
      SSD1306_COLUMNADDR, 0}; // Column start address
  ssd1306_commandList(dlist1, sizeof(dlist1));
 80a0c40:	2205      	movs	r2, #5
 80a0c42:	4940      	ldr	r1, [pc, #256]	; (80a0d44 <_ZN16Adafruit_SSD13067displayEv+0x12c>)
 80a0c44:	4620      	mov	r0, r4
 80a0c46:	f7ff fccc 	bl	80a05e2 <_ZN16Adafruit_SSD130619ssd1306_commandListEPKhh>
  ssd1306_command1(WIDTH - 1); // Column end address
 80a0c4a:	7a21      	ldrb	r1, [r4, #8]
 80a0c4c:	4620      	mov	r0, r4
 80a0c4e:	3901      	subs	r1, #1
 80a0c50:	b2c9      	uxtb	r1, r1
 80a0c52:	f7ff fc57 	bl	80a0504 <_ZN16Adafruit_SSD130616ssd1306_command1Eh>
  // a screen write and one immediately after should cover it.  But if
  // not, if this becomes a problem, yields() might be added in the
  // 32-byte transfer condition below.
  yield();
#endif
  uint16_t count = WIDTH * ((HEIGHT + 7) / 8);
 80a0c56:	f9b4 500a 	ldrsh.w	r5, [r4, #10]
 80a0c5a:	2308      	movs	r3, #8
 80a0c5c:	3507      	adds	r5, #7
 80a0c5e:	fb95 f5f3 	sdiv	r5, r5, r3
 80a0c62:	8923      	ldrh	r3, [r4, #8]
  uint8_t *ptr = buffer;
 80a0c64:	6ae6      	ldr	r6, [r4, #44]	; 0x2c
  // a screen write and one immediately after should cover it.  But if
  // not, if this becomes a problem, yields() might be added in the
  // 32-byte transfer condition below.
  yield();
#endif
  uint16_t count = WIDTH * ((HEIGHT + 7) / 8);
 80a0c66:	435d      	muls	r5, r3
  uint8_t *ptr = buffer;
  if (wire) { // I2C
 80a0c68:	6aa0      	ldr	r0, [r4, #40]	; 0x28
  // a screen write and one immediately after should cover it.  But if
  // not, if this becomes a problem, yields() might be added in the
  // 32-byte transfer condition below.
  yield();
#endif
  uint16_t count = WIDTH * ((HEIGHT + 7) / 8);
 80a0c6a:	b2ad      	uxth	r5, r5
 80a0c6c:	4435      	add	r5, r6
  uint8_t *ptr = buffer;
  if (wire) { // I2C
 80a0c6e:	b340      	cbz	r0, 80a0cc2 <_ZN16Adafruit_SSD13067displayEv+0xaa>
    wire->beginTransmission(i2caddr);
 80a0c70:	f994 1030 	ldrsb.w	r1, [r4, #48]	; 0x30
 80a0c74:	f001 f98e 	bl	80a1f94 <_ZN7TwoWire17beginTransmissionEi>
    WIRE_WRITE((uint8_t)0x40);
 80a0c78:	6aa0      	ldr	r0, [r4, #40]	; 0x28
 80a0c7a:	2140      	movs	r1, #64	; 0x40
 80a0c7c:	6803      	ldr	r3, [r0, #0]
    uint8_t bytesOut = 1;
 80a0c7e:	2701      	movs	r7, #1
#endif
  uint16_t count = WIDTH * ((HEIGHT + 7) / 8);
  uint8_t *ptr = buffer;
  if (wire) { // I2C
    wire->beginTransmission(i2caddr);
    WIRE_WRITE((uint8_t)0x40);
 80a0c80:	689b      	ldr	r3, [r3, #8]
 80a0c82:	4798      	blx	r3
    uint8_t bytesOut = 1;
    while (count--) {
 80a0c84:	42ae      	cmp	r6, r5
 80a0c86:	d018      	beq.n	80a0cba <_ZN16Adafruit_SSD13067displayEv+0xa2>
      if (bytesOut >= WIRE_MAX) {
 80a0c88:	2f1f      	cmp	r7, #31
 80a0c8a:	d90d      	bls.n	80a0ca8 <_ZN16Adafruit_SSD13067displayEv+0x90>
        wire->endTransmission();
 80a0c8c:	6aa0      	ldr	r0, [r4, #40]	; 0x28
 80a0c8e:	f001 f988 	bl	80a1fa2 <_ZN7TwoWire15endTransmissionEv>
        wire->beginTransmission(i2caddr);
 80a0c92:	f994 1030 	ldrsb.w	r1, [r4, #48]	; 0x30
 80a0c96:	6aa0      	ldr	r0, [r4, #40]	; 0x28
 80a0c98:	f001 f97c 	bl	80a1f94 <_ZN7TwoWire17beginTransmissionEi>
        WIRE_WRITE((uint8_t)0x40);
 80a0c9c:	6aa0      	ldr	r0, [r4, #40]	; 0x28
 80a0c9e:	2140      	movs	r1, #64	; 0x40
 80a0ca0:	6803      	ldr	r3, [r0, #0]
        bytesOut = 1;
 80a0ca2:	2701      	movs	r7, #1
    uint8_t bytesOut = 1;
    while (count--) {
      if (bytesOut >= WIRE_MAX) {
        wire->endTransmission();
        wire->beginTransmission(i2caddr);
        WIRE_WRITE((uint8_t)0x40);
 80a0ca4:	689b      	ldr	r3, [r3, #8]
 80a0ca6:	4798      	blx	r3
        bytesOut = 1;
      }
      WIRE_WRITE(*ptr++);
 80a0ca8:	6aa0      	ldr	r0, [r4, #40]	; 0x28
 80a0caa:	f816 1b01 	ldrb.w	r1, [r6], #1
 80a0cae:	6803      	ldr	r3, [r0, #0]
      bytesOut++;
 80a0cb0:	3701      	adds	r7, #1
        wire->endTransmission();
        wire->beginTransmission(i2caddr);
        WIRE_WRITE((uint8_t)0x40);
        bytesOut = 1;
      }
      WIRE_WRITE(*ptr++);
 80a0cb2:	689b      	ldr	r3, [r3, #8]
 80a0cb4:	4798      	blx	r3
      bytesOut++;
 80a0cb6:	b2ff      	uxtb	r7, r7
  uint8_t *ptr = buffer;
  if (wire) { // I2C
    wire->beginTransmission(i2caddr);
    WIRE_WRITE((uint8_t)0x40);
    uint8_t bytesOut = 1;
    while (count--) {
 80a0cb8:	e7e4      	b.n	80a0c84 <_ZN16Adafruit_SSD13067displayEv+0x6c>
        bytesOut = 1;
      }
      WIRE_WRITE(*ptr++);
      bytesOut++;
    }
    wire->endTransmission();
 80a0cba:	6aa0      	ldr	r0, [r4, #40]	; 0x28
 80a0cbc:	f001 f971 	bl	80a1fa2 <_ZN7TwoWire15endTransmissionEv>
 80a0cc0:	e02d      	b.n	80a0d1e <_ZN16Adafruit_SSD13067displayEv+0x106>
  } else { // SPI
    SSD1306_MODE_DATA
 80a0cc2:	6c22      	ldr	r2, [r4, #64]	; 0x40
 80a0cc4:	6d23      	ldr	r3, [r4, #80]	; 0x50
 80a0cc6:	6811      	ldr	r1, [r2, #0]
 80a0cc8:	430b      	orrs	r3, r1
 80a0cca:	6013      	str	r3, [r2, #0]
    while (count--)
 80a0ccc:	42ae      	cmp	r6, r5
 80a0cce:	d026      	beq.n	80a0d1e <_ZN16Adafruit_SSD13067displayEv+0x106>
// LOW-LEVEL UTILS ---------------------------------------------------------

// Issue single byte out SPI, either soft or hardware as appropriate.
// SPI transaction/selection must be performed in calling function.
inline void Adafruit_SSD1306::SPIwrite(uint8_t d) {
  if (spi) {
 80a0cd0:	6a60      	ldr	r0, [r4, #36]	; 0x24
    }
    wire->endTransmission();
  } else { // SPI
    SSD1306_MODE_DATA
    while (count--)
      SPIwrite(*ptr++);
 80a0cd2:	f816 1b01 	ldrb.w	r1, [r6], #1
// LOW-LEVEL UTILS ---------------------------------------------------------

// Issue single byte out SPI, either soft or hardware as appropriate.
// SPI transaction/selection must be performed in calling function.
inline void Adafruit_SSD1306::SPIwrite(uint8_t d) {
  if (spi) {
 80a0cd6:	b110      	cbz	r0, 80a0cde <_ZN16Adafruit_SSD13067displayEv+0xc6>
    (void)spi->transfer(d);
 80a0cd8:	f002 fd3d 	bl	80a3756 <_ZN8SPIClass8transferEh>
 80a0cdc:	e7f6      	b.n	80a0ccc <_ZN16Adafruit_SSD13067displayEv+0xb4>
// LOW-LEVEL UTILS ---------------------------------------------------------

// Issue single byte out SPI, either soft or hardware as appropriate.
// SPI transaction/selection must be performed in calling function.
inline void Adafruit_SSD1306::SPIwrite(uint8_t d) {
  if (spi) {
 80a0cde:	f04f 0c08 	mov.w	ip, #8
 80a0ce2:	2780      	movs	r7, #128	; 0x80
 80a0ce4:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 80a0ce6:	6ca2      	ldr	r2, [r4, #72]	; 0x48
    (void)spi->transfer(d);
  } else {
    for (uint8_t bit = 0x80; bit; bit >>= 1) {
#ifdef HAVE_PORTREG
      if (d & bit)
        *mosiPort |= mosiPinMask;
 80a0ce8:	f8d3 e000 	ldr.w	lr, [r3]
  if (spi) {
    (void)spi->transfer(d);
  } else {
    for (uint8_t bit = 0x80; bit; bit >>= 1) {
#ifdef HAVE_PORTREG
      if (d & bit)
 80a0cec:	4239      	tst	r1, r7
        *mosiPort |= mosiPinMask;
 80a0cee:	bf14      	ite	ne
 80a0cf0:	ea4e 0202 	orrne.w	r2, lr, r2
      else
        *mosiPort &= ~mosiPinMask;
 80a0cf4:	ea2e 0202 	biceq.w	r2, lr, r2
 80a0cf8:	601a      	str	r2, [r3, #0]
      *clkPort |= clkPinMask;  // Clock high
 80a0cfa:	6be2      	ldr	r2, [r4, #60]	; 0x3c
 80a0cfc:	6ce0      	ldr	r0, [r4, #76]	; 0x4c
 80a0cfe:	6813      	ldr	r3, [r2, #0]
// SPI transaction/selection must be performed in calling function.
inline void Adafruit_SSD1306::SPIwrite(uint8_t d) {
  if (spi) {
    (void)spi->transfer(d);
  } else {
    for (uint8_t bit = 0x80; bit; bit >>= 1) {
 80a0d00:	f1bc 0c01 	subs.w	ip, ip, #1
#ifdef HAVE_PORTREG
      if (d & bit)
        *mosiPort |= mosiPinMask;
      else
        *mosiPort &= ~mosiPinMask;
      *clkPort |= clkPinMask;  // Clock high
 80a0d04:	ea43 0300 	orr.w	r3, r3, r0
 80a0d08:	6013      	str	r3, [r2, #0]
      *clkPort &= ~clkPinMask; // Clock low
 80a0d0a:	6be2      	ldr	r2, [r4, #60]	; 0x3c
 80a0d0c:	6ce0      	ldr	r0, [r4, #76]	; 0x4c
 80a0d0e:	6813      	ldr	r3, [r2, #0]
// SPI transaction/selection must be performed in calling function.
inline void Adafruit_SSD1306::SPIwrite(uint8_t d) {
  if (spi) {
    (void)spi->transfer(d);
  } else {
    for (uint8_t bit = 0x80; bit; bit >>= 1) {
 80a0d10:	ea4f 0757 	mov.w	r7, r7, lsr #1
      if (d & bit)
        *mosiPort |= mosiPinMask;
      else
        *mosiPort &= ~mosiPinMask;
      *clkPort |= clkPinMask;  // Clock high
      *clkPort &= ~clkPinMask; // Clock low
 80a0d14:	ea23 0300 	bic.w	r3, r3, r0
 80a0d18:	6013      	str	r3, [r2, #0]
// SPI transaction/selection must be performed in calling function.
inline void Adafruit_SSD1306::SPIwrite(uint8_t d) {
  if (spi) {
    (void)spi->transfer(d);
  } else {
    for (uint8_t bit = 0x80; bit; bit >>= 1) {
 80a0d1a:	d1e3      	bne.n	80a0ce4 <_ZN16Adafruit_SSD13067displayEv+0xcc>
 80a0d1c:	e7d6      	b.n	80a0ccc <_ZN16Adafruit_SSD13067displayEv+0xb4>
  } else { // SPI
    SSD1306_MODE_DATA
    while (count--)
      SPIwrite(*ptr++);
  }
  TRANSACTION_END
 80a0d1e:	6aa0      	ldr	r0, [r4, #40]	; 0x28
 80a0d20:	b120      	cbz	r0, 80a0d2c <_ZN16Adafruit_SSD13067displayEv+0x114>
 80a0d22:	6de1      	ldr	r1, [r4, #92]	; 0x5c
#if defined(ESP8266)
  yield();
#endif
}
 80a0d24:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
 80a0d28:	f001 b926 	b.w	80a1f78 <_ZN7TwoWire8setSpeedEm>
  } else { // SPI
    SSD1306_MODE_DATA
    while (count--)
      SPIwrite(*ptr++);
  }
  TRANSACTION_END
 80a0d2c:	6c62      	ldr	r2, [r4, #68]	; 0x44
 80a0d2e:	6d63      	ldr	r3, [r4, #84]	; 0x54
 80a0d30:	6811      	ldr	r1, [r2, #0]
 80a0d32:	430b      	orrs	r3, r1
 80a0d34:	6013      	str	r3, [r2, #0]
 80a0d36:	6a60      	ldr	r0, [r4, #36]	; 0x24
 80a0d38:	b118      	cbz	r0, 80a0d42 <_ZN16Adafruit_SSD13067displayEv+0x12a>
#if defined(ESP8266)
  yield();
#endif
}
 80a0d3a:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
  } else { // SPI
    SSD1306_MODE_DATA
    while (count--)
      SPIwrite(*ptr++);
  }
  TRANSACTION_END
 80a0d3e:	f002 bc7f 	b.w	80a3640 <_ZN8SPIClass14endTransactionEv>
 80a0d42:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 80a0d44:	080a3fff 	.word	0x080a3fff

080a0d48 <_GLOBAL__sub_I__ZN16Adafruit_SSD1306C2EhhP7TwoWireamm>:
 80a0d48:	f000 bd3e 	b.w	80a17c8 <HAL_Pin_Map>

080a0d4c <_GLOBAL__sub_I__ZN18Adafruit_I2CDeviceC2EhP7TwoWire>:
 80a0d4c:	f000 bd3c 	b.w	80a17c8 <HAL_Pin_Map>

080a0d50 <_GLOBAL__sub_I__ZN18Adafruit_SPIDeviceC2Eam9_BitOrderhP8SPIClass>:
 80a0d50:	f000 bd3a 	b.w	80a17c8 <HAL_Pin_Map>

080a0d54 <_GLOBAL__sub_I__ZN23Adafruit_BusIO_RegisterC2EP18Adafruit_I2CDevicethhh>:
 80a0d54:	f000 bd38 	b.w	80a17c8 <HAL_Pin_Map>

080a0d58 <_ZN12Adafruit_GFX9writeLineEsssst>:
    @param    y1  End point y coordinate
    @param    color 16-bit 5-6-5 Color to draw with
*/
/**************************************************************************/
void Adafruit_GFX::writeLine(int16_t x0, int16_t y0, int16_t x1, int16_t y1,
                             uint16_t color) {
 80a0d58:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80a0d5c:	461e      	mov	r6, r3
 80a0d5e:	b085      	sub	sp, #20
 80a0d60:	f9bd 3038 	ldrsh.w	r3, [sp, #56]	; 0x38
 80a0d64:	4615      	mov	r5, r2
#if defined(ESP8266)
  yield();
#endif
  int16_t steep = abs(y1 - y0) > abs(x1 - x0);
 80a0d66:	1a9a      	subs	r2, r3, r2
 80a0d68:	2a00      	cmp	r2, #0
 80a0d6a:	bfb8      	it	lt
 80a0d6c:	4252      	neglt	r2, r2
 80a0d6e:	9200      	str	r2, [sp, #0]
 80a0d70:	1a72      	subs	r2, r6, r1
 80a0d72:	2a00      	cmp	r2, #0
 80a0d74:	bfb8      	it	lt
 80a0d76:	4252      	neglt	r2, r2
 80a0d78:	9201      	str	r2, [sp, #4]
    @param    y1  End point y coordinate
    @param    color 16-bit 5-6-5 Color to draw with
*/
/**************************************************************************/
void Adafruit_GFX::writeLine(int16_t x0, int16_t y0, int16_t x1, int16_t y1,
                             uint16_t color) {
 80a0d7a:	460c      	mov	r4, r1
#if defined(ESP8266)
  yield();
#endif
  int16_t steep = abs(y1 - y0) > abs(x1 - x0);
  if (steep) {
 80a0d7c:	9a00      	ldr	r2, [sp, #0]
 80a0d7e:	9901      	ldr	r1, [sp, #4]
    @param    y1  End point y coordinate
    @param    color 16-bit 5-6-5 Color to draw with
*/
/**************************************************************************/
void Adafruit_GFX::writeLine(int16_t x0, int16_t y0, int16_t x1, int16_t y1,
                             uint16_t color) {
 80a0d80:	4681      	mov	r9, r0
#if defined(ESP8266)
  yield();
#endif
  int16_t steep = abs(y1 - y0) > abs(x1 - x0);
  if (steep) {
 80a0d82:	428a      	cmp	r2, r1
    @param    y1  End point y coordinate
    @param    color 16-bit 5-6-5 Color to draw with
*/
/**************************************************************************/
void Adafruit_GFX::writeLine(int16_t x0, int16_t y0, int16_t x1, int16_t y1,
                             uint16_t color) {
 80a0d84:	f8bd a03c 	ldrh.w	sl, [sp, #60]	; 0x3c
#if defined(ESP8266)
  yield();
#endif
  int16_t steep = abs(y1 - y0) > abs(x1 - x0);
  if (steep) {
 80a0d88:	dd05      	ble.n	80a0d96 <_ZN12Adafruit_GFX9writeLineEsssst+0x3e>
 80a0d8a:	4632      	mov	r2, r6
    _swap_int16_t(x0, y0);
    _swap_int16_t(x1, y1);
 80a0d8c:	461e      	mov	r6, r3
 80a0d8e:	4613      	mov	r3, r2
                             uint16_t color) {
#if defined(ESP8266)
  yield();
#endif
  int16_t steep = abs(y1 - y0) > abs(x1 - x0);
  if (steep) {
 80a0d90:	4622      	mov	r2, r4
    _swap_int16_t(x0, y0);
 80a0d92:	462c      	mov	r4, r5
 80a0d94:	4615      	mov	r5, r2
    _swap_int16_t(x1, y1);
  }

  if (x0 > x1) {
 80a0d96:	42b4      	cmp	r4, r6
 80a0d98:	dd05      	ble.n	80a0da6 <_ZN12Adafruit_GFX9writeLineEsssst+0x4e>
 80a0d9a:	462a      	mov	r2, r5
    _swap_int16_t(x0, x1);
    _swap_int16_t(y0, y1);
 80a0d9c:	461d      	mov	r5, r3
 80a0d9e:	4613      	mov	r3, r2
  if (steep) {
    _swap_int16_t(x0, y0);
    _swap_int16_t(x1, y1);
  }

  if (x0 > x1) {
 80a0da0:	4622      	mov	r2, r4
 80a0da2:	4634      	mov	r4, r6
 80a0da4:	4616      	mov	r6, r2
    _swap_int16_t(y0, y1);
  }

  int16_t dx, dy;
  dx = x1 - x0;
  dy = abs(y1 - y0);
 80a0da6:	1b5a      	subs	r2, r3, r5
 80a0da8:	2a00      	cmp	r2, #0
    _swap_int16_t(x0, x1);
    _swap_int16_t(y0, y1);
  }

  int16_t dx, dy;
  dx = x1 - x0;
 80a0daa:	ebc4 0806 	rsb	r8, r4, r6
  dy = abs(y1 - y0);
 80a0dae:	bfb8      	it	lt
 80a0db0:	4252      	neglt	r2, r2
    _swap_int16_t(x0, x1);
    _swap_int16_t(y0, y1);
  }

  int16_t dx, dy;
  dx = x1 - x0;
 80a0db2:	fa1f f888 	uxth.w	r8, r8
  dy = abs(y1 - y0);
 80a0db6:	9203      	str	r2, [sp, #12]

  int16_t err = dx / 2;
 80a0db8:	fa0f f788 	sxth.w	r7, r8
 80a0dbc:	2202      	movs	r2, #2
  int16_t ystep;

  if (y0 < y1) {
    ystep = 1;
  } else {
    ystep = -1;
 80a0dbe:	429d      	cmp	r5, r3
 80a0dc0:	bfb4      	ite	lt
 80a0dc2:	2301      	movlt	r3, #1
 80a0dc4:	f04f 33ff 	movge.w	r3, #4294967295

  int16_t dx, dy;
  dx = x1 - x0;
  dy = abs(y1 - y0);

  int16_t err = dx / 2;
 80a0dc8:	fb97 f7f2 	sdiv	r7, r7, r2
  int16_t ystep;

  if (y0 < y1) {
    ystep = 1;
  } else {
    ystep = -1;
 80a0dcc:	9302      	str	r3, [sp, #8]
  }

  for (; x0 <= x1; x0++) {
 80a0dce:	42b4      	cmp	r4, r6
 80a0dd0:	dc1f      	bgt.n	80a0e12 <_ZN12Adafruit_GFX9writeLineEsssst+0xba>
    if (steep) {
 80a0dd2:	9a01      	ldr	r2, [sp, #4]
 80a0dd4:	9b00      	ldr	r3, [sp, #0]
      writePixel(y0, x0, color);
    } else {
      writePixel(x0, y0, color);
 80a0dd6:	4648      	mov	r0, r9
  } else {
    ystep = -1;
  }

  for (; x0 <= x1; x0++) {
    if (steep) {
 80a0dd8:	4293      	cmp	r3, r2
 80a0dda:	f8d9 3000 	ldr.w	r3, [r9]
      writePixel(y0, x0, color);
 80a0dde:	bfc8      	it	gt
 80a0de0:	4622      	movgt	r2, r4
 80a0de2:	f8d3 b018 	ldr.w	fp, [r3, #24]
 80a0de6:	bfc8      	it	gt
 80a0de8:	4629      	movgt	r1, r5
 80a0dea:	4653      	mov	r3, sl
    } else {
      writePixel(x0, y0, color);
 80a0dec:	bfdc      	itt	le
 80a0dee:	462a      	movle	r2, r5
 80a0df0:	4621      	movle	r1, r4
 80a0df2:	47d8      	blx	fp
    }
    err -= dy;
 80a0df4:	9b03      	ldr	r3, [sp, #12]
 80a0df6:	1aff      	subs	r7, r7, r3
 80a0df8:	b2bb      	uxth	r3, r7
 80a0dfa:	b21f      	sxth	r7, r3
    if (err < 0) {
 80a0dfc:	2f00      	cmp	r7, #0
 80a0dfe:	da05      	bge.n	80a0e0c <_ZN12Adafruit_GFX9writeLineEsssst+0xb4>
      y0 += ystep;
 80a0e00:	9a02      	ldr	r2, [sp, #8]
      err += dx;
 80a0e02:	eb08 0703 	add.w	r7, r8, r3
    } else {
      writePixel(x0, y0, color);
    }
    err -= dy;
    if (err < 0) {
      y0 += ystep;
 80a0e06:	4415      	add	r5, r2
 80a0e08:	b22d      	sxth	r5, r5
      err += dx;
 80a0e0a:	b23f      	sxth	r7, r7
 80a0e0c:	3401      	adds	r4, #1
 80a0e0e:	b224      	sxth	r4, r4
    ystep = 1;
  } else {
    ystep = -1;
  }

  for (; x0 <= x1; x0++) {
 80a0e10:	e7dd      	b.n	80a0dce <_ZN12Adafruit_GFX9writeLineEsssst+0x76>
    if (err < 0) {
      y0 += ystep;
      err += dx;
    }
  }
}
 80a0e12:	b005      	add	sp, #20
 80a0e14:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

080a0e18 <_ZN12Adafruit_GFX10writePixelEsst>:
    @param   x   x coordinate
    @param   y   y coordinate
   @param    color 16-bit 5-6-5 Color to fill with
*/
/**************************************************************************/
void Adafruit_GFX::writePixel(int16_t x, int16_t y, uint16_t color) {
 80a0e18:	b410      	push	{r4}
  drawPixel(x, y, color);
 80a0e1a:	6804      	ldr	r4, [r0, #0]
 80a0e1c:	6924      	ldr	r4, [r4, #16]
 80a0e1e:	46a4      	mov	ip, r4
}
 80a0e20:	bc10      	pop	{r4}
    @param   y   y coordinate
   @param    color 16-bit 5-6-5 Color to fill with
*/
/**************************************************************************/
void Adafruit_GFX::writePixel(int16_t x, int16_t y, uint16_t color) {
  drawPixel(x, y, color);
 80a0e22:	4760      	bx	ip

080a0e24 <_ZN12Adafruit_GFX14writeFastVLineEssst>:
    @param    h   Height in pixels
   @param    color 16-bit 5-6-5 Color to fill with
*/
/**************************************************************************/
void Adafruit_GFX::writeFastVLine(int16_t x, int16_t y, int16_t h,
                                  uint16_t color) {
 80a0e24:	b430      	push	{r4, r5}
 80a0e26:	f8bd 5008 	ldrh.w	r5, [sp, #8]
  // Overwrite in subclasses if startWrite is defined!
  // Can be just writeLine(x, y, x, y+h-1, color);
  // or writeFillRect(x, y, 1, h, color);
  drawFastVLine(x, y, h, color);
 80a0e2a:	6804      	ldr	r4, [r0, #0]
 80a0e2c:	9502      	str	r5, [sp, #8]
 80a0e2e:	6ba4      	ldr	r4, [r4, #56]	; 0x38
 80a0e30:	46a4      	mov	ip, r4
}
 80a0e32:	bc30      	pop	{r4, r5}
void Adafruit_GFX::writeFastVLine(int16_t x, int16_t y, int16_t h,
                                  uint16_t color) {
  // Overwrite in subclasses if startWrite is defined!
  // Can be just writeLine(x, y, x, y+h-1, color);
  // or writeFillRect(x, y, 1, h, color);
  drawFastVLine(x, y, h, color);
 80a0e34:	4760      	bx	ip

080a0e36 <_ZN12Adafruit_GFX14writeFastHLineEssst>:
    @param    w   Width in pixels
   @param    color 16-bit 5-6-5 Color to fill with
*/
/**************************************************************************/
void Adafruit_GFX::writeFastHLine(int16_t x, int16_t y, int16_t w,
                                  uint16_t color) {
 80a0e36:	b430      	push	{r4, r5}
 80a0e38:	f8bd 5008 	ldrh.w	r5, [sp, #8]
  // Overwrite in subclasses if startWrite is defined!
  // Example: writeLine(x, y, x+w-1, y, color);
  // or writeFillRect(x, y, w, 1, color);
  drawFastHLine(x, y, w, color);
 80a0e3c:	6804      	ldr	r4, [r0, #0]
 80a0e3e:	9502      	str	r5, [sp, #8]
 80a0e40:	6be4      	ldr	r4, [r4, #60]	; 0x3c
 80a0e42:	46a4      	mov	ip, r4
}
 80a0e44:	bc30      	pop	{r4, r5}
void Adafruit_GFX::writeFastHLine(int16_t x, int16_t y, int16_t w,
                                  uint16_t color) {
  // Overwrite in subclasses if startWrite is defined!
  // Example: writeLine(x, y, x+w-1, y, color);
  // or writeFillRect(x, y, w, 1, color);
  drawFastHLine(x, y, w, color);
 80a0e46:	4760      	bx	ip

080a0e48 <_ZN12Adafruit_GFX13writeFillRectEsssst>:
    @param    h   Height in pixels
   @param    color 16-bit 5-6-5 Color to fill with
*/
/**************************************************************************/
void Adafruit_GFX::writeFillRect(int16_t x, int16_t y, int16_t w, int16_t h,
                                 uint16_t color) {
 80a0e48:	b470      	push	{r4, r5, r6}
 80a0e4a:	f9bd 500c 	ldrsh.w	r5, [sp, #12]
 80a0e4e:	f8bd 6010 	ldrh.w	r6, [sp, #16]
  // Overwrite in subclasses if desired!
  fillRect(x, y, w, h, color);
 80a0e52:	6804      	ldr	r4, [r0, #0]
 80a0e54:	9604      	str	r6, [sp, #16]
 80a0e56:	9503      	str	r5, [sp, #12]
 80a0e58:	6c24      	ldr	r4, [r4, #64]	; 0x40
 80a0e5a:	46a4      	mov	ip, r4
}
 80a0e5c:	bc70      	pop	{r4, r5, r6}
*/
/**************************************************************************/
void Adafruit_GFX::writeFillRect(int16_t x, int16_t y, int16_t w, int16_t h,
                                 uint16_t color) {
  // Overwrite in subclasses if desired!
  fillRect(x, y, w, h, color);
 80a0e5e:	4760      	bx	ip

080a0e60 <_ZN12Adafruit_GFX10startWriteEv>:
/*!
   @brief    End a display-writing routine, overwrite in subclasses if
   startWrite is defined!
*/
/**************************************************************************/
void Adafruit_GFX::endWrite() {}
 80a0e60:	4770      	bx	lr

080a0e62 <_ZN12Adafruit_GFX13drawFastVLineEssst>:
    @param    h   Height in pixels
   @param    color 16-bit 5-6-5 Color to fill with
*/
/**************************************************************************/
void Adafruit_GFX::drawFastVLine(int16_t x, int16_t y, int16_t h,
                                 uint16_t color) {
 80a0e62:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
 80a0e66:	461c      	mov	r4, r3
 80a0e68:	4616      	mov	r6, r2
 80a0e6a:	4605      	mov	r5, r0
 80a0e6c:	460f      	mov	r7, r1
  startWrite();
 80a0e6e:	6803      	ldr	r3, [r0, #0]
  writeLine(x, y, x, y + h - 1, color);
 80a0e70:	3c01      	subs	r4, #1
    @param    h   Height in pixels
   @param    color 16-bit 5-6-5 Color to fill with
*/
/**************************************************************************/
void Adafruit_GFX::drawFastVLine(int16_t x, int16_t y, int16_t h,
                                 uint16_t color) {
 80a0e72:	f8bd 8020 	ldrh.w	r8, [sp, #32]
  startWrite();
 80a0e76:	695b      	ldr	r3, [r3, #20]
  writeLine(x, y, x, y + h - 1, color);
 80a0e78:	4434      	add	r4, r6
   @param    color 16-bit 5-6-5 Color to fill with
*/
/**************************************************************************/
void Adafruit_GFX::drawFastVLine(int16_t x, int16_t y, int16_t h,
                                 uint16_t color) {
  startWrite();
 80a0e7a:	4798      	blx	r3
  writeLine(x, y, x, y + h - 1, color);
 80a0e7c:	b224      	sxth	r4, r4
 80a0e7e:	682b      	ldr	r3, [r5, #0]
 80a0e80:	f8cd 8004 	str.w	r8, [sp, #4]
 80a0e84:	9400      	str	r4, [sp, #0]
 80a0e86:	6a9c      	ldr	r4, [r3, #40]	; 0x28
 80a0e88:	4628      	mov	r0, r5
 80a0e8a:	463b      	mov	r3, r7
 80a0e8c:	4632      	mov	r2, r6
 80a0e8e:	4639      	mov	r1, r7
 80a0e90:	47a0      	blx	r4
  endWrite();
 80a0e92:	4628      	mov	r0, r5
 80a0e94:	682b      	ldr	r3, [r5, #0]
 80a0e96:	6adb      	ldr	r3, [r3, #44]	; 0x2c
}
 80a0e98:	b002      	add	sp, #8
 80a0e9a:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
/**************************************************************************/
void Adafruit_GFX::drawFastVLine(int16_t x, int16_t y, int16_t h,
                                 uint16_t color) {
  startWrite();
  writeLine(x, y, x, y + h - 1, color);
  endWrite();
 80a0e9e:	4718      	bx	r3

080a0ea0 <_ZN12Adafruit_GFX13drawFastHLineEssst>:
    @param    w   Width in pixels
   @param    color 16-bit 5-6-5 Color to fill with
*/
/**************************************************************************/
void Adafruit_GFX::drawFastHLine(int16_t x, int16_t y, int16_t w,
                                 uint16_t color) {
 80a0ea0:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
 80a0ea4:	4617      	mov	r7, r2
 80a0ea6:	4604      	mov	r4, r0
 80a0ea8:	461d      	mov	r5, r3
 80a0eaa:	460e      	mov	r6, r1
  startWrite();
 80a0eac:	6803      	ldr	r3, [r0, #0]
    @param    w   Width in pixels
   @param    color 16-bit 5-6-5 Color to fill with
*/
/**************************************************************************/
void Adafruit_GFX::drawFastHLine(int16_t x, int16_t y, int16_t w,
                                 uint16_t color) {
 80a0eae:	f8bd 8020 	ldrh.w	r8, [sp, #32]
  startWrite();
 80a0eb2:	695b      	ldr	r3, [r3, #20]
 80a0eb4:	4798      	blx	r3
  writeLine(x, y, x + w - 1, y, color);
 80a0eb6:	e88d 0180 	stmia.w	sp, {r7, r8}
 80a0eba:	6822      	ldr	r2, [r4, #0]
 80a0ebc:	1e6b      	subs	r3, r5, #1
 80a0ebe:	4433      	add	r3, r6
 80a0ec0:	6a95      	ldr	r5, [r2, #40]	; 0x28
 80a0ec2:	4620      	mov	r0, r4
 80a0ec4:	b21b      	sxth	r3, r3
 80a0ec6:	463a      	mov	r2, r7
 80a0ec8:	4631      	mov	r1, r6
 80a0eca:	47a8      	blx	r5
  endWrite();
 80a0ecc:	4620      	mov	r0, r4
 80a0ece:	6823      	ldr	r3, [r4, #0]
 80a0ed0:	6adb      	ldr	r3, [r3, #44]	; 0x2c
}
 80a0ed2:	b002      	add	sp, #8
 80a0ed4:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
/**************************************************************************/
void Adafruit_GFX::drawFastHLine(int16_t x, int16_t y, int16_t w,
                                 uint16_t color) {
  startWrite();
  writeLine(x, y, x + w - 1, y, color);
  endWrite();
 80a0ed8:	4718      	bx	r3

080a0eda <_ZN12Adafruit_GFX8fillRectEsssst>:
    @param    h   Height in pixels
   @param    color 16-bit 5-6-5 Color to fill with
*/
/**************************************************************************/
void Adafruit_GFX::fillRect(int16_t x, int16_t y, int16_t w, int16_t h,
                            uint16_t color) {
 80a0eda:	e92d 47f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, r9, sl, lr}
 80a0ede:	461e      	mov	r6, r3
  startWrite();
 80a0ee0:	6803      	ldr	r3, [r0, #0]
    @param    h   Height in pixels
   @param    color 16-bit 5-6-5 Color to fill with
*/
/**************************************************************************/
void Adafruit_GFX::fillRect(int16_t x, int16_t y, int16_t w, int16_t h,
                            uint16_t color) {
 80a0ee2:	460c      	mov	r4, r1
  startWrite();
 80a0ee4:	695b      	ldr	r3, [r3, #20]
    @param    h   Height in pixels
   @param    color 16-bit 5-6-5 Color to fill with
*/
/**************************************************************************/
void Adafruit_GFX::fillRect(int16_t x, int16_t y, int16_t w, int16_t h,
                            uint16_t color) {
 80a0ee6:	4605      	mov	r5, r0
 80a0ee8:	4617      	mov	r7, r2
 80a0eea:	f9bd 8028 	ldrsh.w	r8, [sp, #40]	; 0x28
 80a0eee:	f8bd 902c 	ldrh.w	r9, [sp, #44]	; 0x2c
  startWrite();
 80a0ef2:	4798      	blx	r3
  for (int16_t i = x; i < x + w; i++) {
 80a0ef4:	4426      	add	r6, r4
 80a0ef6:	42b4      	cmp	r4, r6
 80a0ef8:	682a      	ldr	r2, [r5, #0]
 80a0efa:	da0b      	bge.n	80a0f14 <_ZN12Adafruit_GFX8fillRectEsssst+0x3a>
    writeFastVLine(i, y, h, color);
 80a0efc:	f8cd 9000 	str.w	r9, [sp]
 80a0f00:	f8d2 a020 	ldr.w	sl, [r2, #32]
 80a0f04:	4621      	mov	r1, r4
 80a0f06:	4643      	mov	r3, r8
 80a0f08:	463a      	mov	r2, r7
 80a0f0a:	4628      	mov	r0, r5
 80a0f0c:	3401      	adds	r4, #1
 80a0f0e:	47d0      	blx	sl
 80a0f10:	b224      	sxth	r4, r4
*/
/**************************************************************************/
void Adafruit_GFX::fillRect(int16_t x, int16_t y, int16_t w, int16_t h,
                            uint16_t color) {
  startWrite();
  for (int16_t i = x; i < x + w; i++) {
 80a0f12:	e7f0      	b.n	80a0ef6 <_ZN12Adafruit_GFX8fillRectEsssst+0x1c>
    writeFastVLine(i, y, h, color);
  }
  endWrite();
 80a0f14:	4628      	mov	r0, r5
 80a0f16:	6ad3      	ldr	r3, [r2, #44]	; 0x2c
}
 80a0f18:	b002      	add	sp, #8
 80a0f1a:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
                            uint16_t color) {
  startWrite();
  for (int16_t i = x; i < x + w; i++) {
    writeFastVLine(i, y, h, color);
  }
  endWrite();
 80a0f1e:	4718      	bx	r3

080a0f20 <_ZN12Adafruit_GFX10fillScreenEt>:
   @brief    Fill the screen completely with one color. Update in subclasses if
   desired!
    @param    color 16-bit 5-6-5 Color to fill with
*/
/**************************************************************************/
void Adafruit_GFX::fillScreen(uint16_t color) {
 80a0f20:	b513      	push	{r0, r1, r4, lr}
  fillRect(0, 0, _width, _height, color);
 80a0f22:	f9b0 200e 	ldrsh.w	r2, [r0, #14]
 80a0f26:	6804      	ldr	r4, [r0, #0]
 80a0f28:	9101      	str	r1, [sp, #4]
 80a0f2a:	9200      	str	r2, [sp, #0]
 80a0f2c:	2200      	movs	r2, #0
 80a0f2e:	f9b0 300c 	ldrsh.w	r3, [r0, #12]
 80a0f32:	6c24      	ldr	r4, [r4, #64]	; 0x40
 80a0f34:	4611      	mov	r1, r2
 80a0f36:	47a0      	blx	r4
}
 80a0f38:	b002      	add	sp, #8
 80a0f3a:	bd10      	pop	{r4, pc}

080a0f3c <_ZN12Adafruit_GFX8drawLineEsssst>:
    @param    y1  End point y coordinate
    @param    color 16-bit 5-6-5 Color to draw with
*/
/**************************************************************************/
void Adafruit_GFX::drawLine(int16_t x0, int16_t y0, int16_t x1, int16_t y1,
                            uint16_t color) {
 80a0f3c:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
  // Update in subclasses if desired!
  if (x0 == x1) {
 80a0f40:	4299      	cmp	r1, r3
    @param    y1  End point y coordinate
    @param    color 16-bit 5-6-5 Color to draw with
*/
/**************************************************************************/
void Adafruit_GFX::drawLine(int16_t x0, int16_t y0, int16_t x1, int16_t y1,
                            uint16_t color) {
 80a0f42:	4690      	mov	r8, r2
 80a0f44:	4607      	mov	r7, r0
 80a0f46:	460e      	mov	r6, r1
 80a0f48:	461c      	mov	r4, r3
 80a0f4a:	f9bd 5028 	ldrsh.w	r5, [sp, #40]	; 0x28
 80a0f4e:	f8bd 902c 	ldrh.w	r9, [sp, #44]	; 0x2c
 80a0f52:	6802      	ldr	r2, [r0, #0]
  // Update in subclasses if desired!
  if (x0 == x1) {
 80a0f54:	d10b      	bne.n	80a0f6e <_ZN12Adafruit_GFX8drawLineEsssst+0x32>
    if (y0 > y1)
 80a0f56:	45a8      	cmp	r8, r5
 80a0f58:	bfc2      	ittt	gt
 80a0f5a:	4643      	movgt	r3, r8
 80a0f5c:	46a8      	movgt	r8, r5
 80a0f5e:	461d      	movgt	r5, r3
      _swap_int16_t(y0, y1);
    drawFastVLine(x0, y0, y1 - y0 + 1, color);
 80a0f60:	f8cd 9028 	str.w	r9, [sp, #40]	; 0x28
 80a0f64:	1c6b      	adds	r3, r5, #1
 80a0f66:	ebc8 0303 	rsb	r3, r8, r3
 80a0f6a:	6b94      	ldr	r4, [r2, #56]	; 0x38
 80a0f6c:	e00b      	b.n	80a0f86 <_ZN12Adafruit_GFX8drawLineEsssst+0x4a>
  } else if (y0 == y1) {
 80a0f6e:	45a8      	cmp	r8, r5
 80a0f70:	d112      	bne.n	80a0f98 <_ZN12Adafruit_GFX8drawLineEsssst+0x5c>
    if (x0 > x1)
 80a0f72:	4299      	cmp	r1, r3
 80a0f74:	bfc2      	ittt	gt
 80a0f76:	460b      	movgt	r3, r1
 80a0f78:	4626      	movgt	r6, r4
 80a0f7a:	461c      	movgt	r4, r3
      _swap_int16_t(x0, x1);
    drawFastHLine(x0, y0, x1 - x0 + 1, color);
 80a0f7c:	f8cd 9028 	str.w	r9, [sp, #40]	; 0x28
 80a0f80:	1c63      	adds	r3, r4, #1
 80a0f82:	6bd4      	ldr	r4, [r2, #60]	; 0x3c
 80a0f84:	1b9b      	subs	r3, r3, r6
 80a0f86:	4642      	mov	r2, r8
 80a0f88:	4631      	mov	r1, r6
 80a0f8a:	4638      	mov	r0, r7
 80a0f8c:	46a4      	mov	ip, r4
 80a0f8e:	b21b      	sxth	r3, r3
  } else {
    startWrite();
    writeLine(x0, y0, x1, y1, color);
    endWrite();
  }
}
 80a0f90:	b003      	add	sp, #12
 80a0f92:	e8bd 43f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, lr}
      _swap_int16_t(y0, y1);
    drawFastVLine(x0, y0, y1 - y0 + 1, color);
  } else if (y0 == y1) {
    if (x0 > x1)
      _swap_int16_t(x0, x1);
    drawFastHLine(x0, y0, x1 - x0 + 1, color);
 80a0f96:	4760      	bx	ip
  } else {
    startWrite();
 80a0f98:	6953      	ldr	r3, [r2, #20]
 80a0f9a:	4798      	blx	r3
    writeLine(x0, y0, x1, y1, color);
 80a0f9c:	683b      	ldr	r3, [r7, #0]
 80a0f9e:	e88d 0220 	stmia.w	sp, {r5, r9}
 80a0fa2:	4638      	mov	r0, r7
 80a0fa4:	6a9d      	ldr	r5, [r3, #40]	; 0x28
 80a0fa6:	4642      	mov	r2, r8
 80a0fa8:	4623      	mov	r3, r4
 80a0faa:	4631      	mov	r1, r6
 80a0fac:	47a8      	blx	r5
    endWrite();
 80a0fae:	4638      	mov	r0, r7
 80a0fb0:	683b      	ldr	r3, [r7, #0]
 80a0fb2:	6adb      	ldr	r3, [r3, #44]	; 0x2c
  }
}
 80a0fb4:	b003      	add	sp, #12
 80a0fb6:	e8bd 43f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, lr}
      _swap_int16_t(x0, x1);
    drawFastHLine(x0, y0, x1 - x0 + 1, color);
  } else {
    startWrite();
    writeLine(x0, y0, x1, y1, color);
    endWrite();
 80a0fba:	4718      	bx	r3

080a0fbc <_ZN12Adafruit_GFX8drawRectEsssst>:
    @param    h   Height in pixels
    @param    color 16-bit 5-6-5 Color to draw with
*/
/**************************************************************************/
void Adafruit_GFX::drawRect(int16_t x, int16_t y, int16_t w, int16_t h,
                            uint16_t color) {
 80a0fbc:	e92d 47f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, r9, sl, lr}
 80a0fc0:	4604      	mov	r4, r0
 80a0fc2:	460d      	mov	r5, r1
 80a0fc4:	4617      	mov	r7, r2
 80a0fc6:	461e      	mov	r6, r3
  startWrite();
 80a0fc8:	6803      	ldr	r3, [r0, #0]
    @param    h   Height in pixels
    @param    color 16-bit 5-6-5 Color to draw with
*/
/**************************************************************************/
void Adafruit_GFX::drawRect(int16_t x, int16_t y, int16_t w, int16_t h,
                            uint16_t color) {
 80a0fca:	f8bd 802c 	ldrh.w	r8, [sp, #44]	; 0x2c
  startWrite();
 80a0fce:	695b      	ldr	r3, [r3, #20]
    @param    h   Height in pixels
    @param    color 16-bit 5-6-5 Color to draw with
*/
/**************************************************************************/
void Adafruit_GFX::drawRect(int16_t x, int16_t y, int16_t w, int16_t h,
                            uint16_t color) {
 80a0fd0:	f9bd 9028 	ldrsh.w	r9, [sp, #40]	; 0x28
  startWrite();
 80a0fd4:	4798      	blx	r3
  writeFastHLine(x, y, w, color);
 80a0fd6:	6823      	ldr	r3, [r4, #0]
 80a0fd8:	f8cd 8000 	str.w	r8, [sp]
 80a0fdc:	f8d3 a024 	ldr.w	sl, [r3, #36]	; 0x24
 80a0fe0:	463a      	mov	r2, r7
 80a0fe2:	4633      	mov	r3, r6
 80a0fe4:	4629      	mov	r1, r5
 80a0fe6:	4620      	mov	r0, r4
 80a0fe8:	47d0      	blx	sl
  writeFastHLine(x, y + h - 1, w, color);
 80a0fea:	6823      	ldr	r3, [r4, #0]
 80a0fec:	f109 32ff 	add.w	r2, r9, #4294967295
 80a0ff0:	f8cd 8000 	str.w	r8, [sp]
 80a0ff4:	443a      	add	r2, r7
 80a0ff6:	f8d3 a024 	ldr.w	sl, [r3, #36]	; 0x24
 80a0ffa:	4629      	mov	r1, r5
 80a0ffc:	4633      	mov	r3, r6
 80a0ffe:	4620      	mov	r0, r4
 80a1000:	b212      	sxth	r2, r2
 80a1002:	47d0      	blx	sl
  writeFastVLine(x, y, h, color);
 80a1004:	6823      	ldr	r3, [r4, #0]
 80a1006:	f8cd 8000 	str.w	r8, [sp]
 80a100a:	f8d3 a020 	ldr.w	sl, [r3, #32]
 80a100e:	463a      	mov	r2, r7
 80a1010:	464b      	mov	r3, r9
 80a1012:	4629      	mov	r1, r5
 80a1014:	4620      	mov	r0, r4
 80a1016:	47d0      	blx	sl
  writeFastVLine(x + w - 1, y, h, color);
 80a1018:	6823      	ldr	r3, [r4, #0]
 80a101a:	1e71      	subs	r1, r6, #1
 80a101c:	f8cd 8000 	str.w	r8, [sp]
 80a1020:	4429      	add	r1, r5
 80a1022:	4620      	mov	r0, r4
 80a1024:	6a1d      	ldr	r5, [r3, #32]
 80a1026:	463a      	mov	r2, r7
 80a1028:	464b      	mov	r3, r9
 80a102a:	b209      	sxth	r1, r1
 80a102c:	47a8      	blx	r5
  endWrite();
 80a102e:	4620      	mov	r0, r4
 80a1030:	6823      	ldr	r3, [r4, #0]
 80a1032:	6adb      	ldr	r3, [r3, #44]	; 0x2c
}
 80a1034:	b002      	add	sp, #8
 80a1036:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  startWrite();
  writeFastHLine(x, y, w, color);
  writeFastHLine(x, y + h - 1, w, color);
  writeFastVLine(x, y, h, color);
  writeFastVLine(x + w - 1, y, h, color);
  endWrite();
 80a103a:	4718      	bx	r3

080a103c <_ZN12Adafruit_GFX13invertDisplayEb>:
/*!
    @brief      Invert the display (ideally using built-in hardware command)
    @param   i  True if you want to invert, false to make 'normal'
*/
/**************************************************************************/
void Adafruit_GFX::invertDisplay(bool i) {
 80a103c:	4770      	bx	lr

080a103e <_ZN12Adafruit_GFX11setRotationEh>:
    @brief      Set rotation setting for display
    @param  x   0 thru 3 corresponding to 4 cardinal rotations
*/
/**************************************************************************/
void Adafruit_GFX::setRotation(uint8_t x) {
  rotation = (x & 3);
 80a103e:	f001 0103 	and.w	r1, r1, #3
  switch (rotation) {
 80a1042:	2901      	cmp	r1, #1
    @brief      Set rotation setting for display
    @param  x   0 thru 3 corresponding to 4 cardinal rotations
*/
/**************************************************************************/
void Adafruit_GFX::setRotation(uint8_t x) {
  rotation = (x & 3);
 80a1044:	7681      	strb	r1, [r0, #26]
 80a1046:	8903      	ldrh	r3, [r0, #8]
 80a1048:	8942      	ldrh	r2, [r0, #10]
  switch (rotation) {
 80a104a:	d004      	beq.n	80a1056 <_ZN12Adafruit_GFX11setRotationEh+0x18>
 80a104c:	2903      	cmp	r1, #3
 80a104e:	d002      	beq.n	80a1056 <_ZN12Adafruit_GFX11setRotationEh+0x18>
  case 0:
  case 2:
    _width = WIDTH;
 80a1050:	8183      	strh	r3, [r0, #12]
    _height = HEIGHT;
 80a1052:	81c2      	strh	r2, [r0, #14]
 80a1054:	4770      	bx	lr
    break;
  case 1:
  case 3:
    _width = HEIGHT;
 80a1056:	8182      	strh	r2, [r0, #12]
    _height = WIDTH;
 80a1058:	81c3      	strh	r3, [r0, #14]
 80a105a:	4770      	bx	lr

080a105c <_ZN12Adafruit_GFXC1Ess>:
   superclass
   @param    w   Display width, in pixels
   @param    h   Display height, in pixels
*/
/**************************************************************************/
Adafruit_GFX::Adafruit_GFX(int16_t w, int16_t h) : WIDTH(w), HEIGHT(h) {
 80a105c:	8101      	strh	r1, [r0, #8]
  _width = WIDTH;
 80a105e:	8181      	strh	r1, [r0, #12]
  _height = HEIGHT;
  rotation = 0;
  cursor_y = cursor_x = 0;
  textsize_x = textsize_y = 1;
  textcolor = textbgcolor = 0xFFFF;
 80a1060:	f64f 71ff 	movw	r1, #65535	; 0xffff
   superclass
   @param    w   Display width, in pixels
   @param    h   Display height, in pixels
*/
/**************************************************************************/
Adafruit_GFX::Adafruit_GFX(int16_t w, int16_t h) : WIDTH(w), HEIGHT(h) {
 80a1064:	b530      	push	{r4, r5, lr}
 80a1066:	4d09      	ldr	r5, [pc, #36]	; (80a108c <_ZN12Adafruit_GFXC1Ess+0x30>)
  protected:
    void setWriteError(int err = 1) { write_error = err; }
    size_t printf_impl(bool newline, const char* format, ...);

  public:
    Print() : write_error(0) {}
 80a1068:	2400      	movs	r4, #0
 80a106a:	8142      	strh	r2, [r0, #10]
  _width = WIDTH;
  _height = HEIGHT;
 80a106c:	81c2      	strh	r2, [r0, #14]
  rotation = 0;
  cursor_y = cursor_x = 0;
  textsize_x = textsize_y = 1;
 80a106e:	2201      	movs	r2, #1
 80a1070:	6044      	str	r4, [r0, #4]
   superclass
   @param    w   Display width, in pixels
   @param    h   Display height, in pixels
*/
/**************************************************************************/
Adafruit_GFX::Adafruit_GFX(int16_t w, int16_t h) : WIDTH(w), HEIGHT(h) {
 80a1072:	6005      	str	r5, [r0, #0]
  _width = WIDTH;
  _height = HEIGHT;
  rotation = 0;
 80a1074:	7684      	strb	r4, [r0, #26]
  cursor_y = cursor_x = 0;
 80a1076:	8204      	strh	r4, [r0, #16]
 80a1078:	8244      	strh	r4, [r0, #18]
  textsize_x = textsize_y = 1;
 80a107a:	7642      	strb	r2, [r0, #25]
 80a107c:	7602      	strb	r2, [r0, #24]
  textcolor = textbgcolor = 0xFFFF;
 80a107e:	82c1      	strh	r1, [r0, #22]
 80a1080:	8281      	strh	r1, [r0, #20]
  wrap = true;
 80a1082:	76c2      	strb	r2, [r0, #27]
  _cp437 = false;
 80a1084:	7704      	strb	r4, [r0, #28]
  gfxFont = NULL;
 80a1086:	6204      	str	r4, [r0, #32]
}
 80a1088:	bd30      	pop	{r4, r5, pc}
 80a108a:	bf00      	nop
 80a108c:	080a4504 	.word	0x080a4504

080a1090 <_ZN12Adafruit_GFX10drawBitmapEssPhsst>:
    @param    h   Height of bitmap in pixels
    @param    color 16-bit 5-6-5 Color to draw with
*/
/**************************************************************************/
void Adafruit_GFX::drawBitmap(int16_t x, int16_t y, uint8_t *bitmap, int16_t w,
                              int16_t h, uint16_t color) {
 80a1090:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80a1094:	b089      	sub	sp, #36	; 0x24
 80a1096:	469a      	mov	sl, r3
 80a1098:	f9bd 304c 	ldrsh.w	r3, [sp, #76]	; 0x4c
 80a109c:	f9bd 9048 	ldrsh.w	r9, [sp, #72]	; 0x48
 80a10a0:	9304      	str	r3, [sp, #16]
 80a10a2:	f8bd 3050 	ldrh.w	r3, [sp, #80]	; 0x50
 80a10a6:	9203      	str	r2, [sp, #12]
 80a10a8:	9305      	str	r3, [sp, #20]

  int16_t byteWidth = (w + 7) / 8; // Bitmap scanline pad = whole byte
  uint8_t byte = 0;

  startWrite();
 80a10aa:	6803      	ldr	r3, [r0, #0]
    @param    h   Height of bitmap in pixels
    @param    color 16-bit 5-6-5 Color to draw with
*/
/**************************************************************************/
void Adafruit_GFX::drawBitmap(int16_t x, int16_t y, uint8_t *bitmap, int16_t w,
                              int16_t h, uint16_t color) {
 80a10ac:	9102      	str	r1, [sp, #8]

  int16_t byteWidth = (w + 7) / 8; // Bitmap scanline pad = whole byte
  uint8_t byte = 0;

  startWrite();
 80a10ae:	695b      	ldr	r3, [r3, #20]
 80a10b0:	2600      	movs	r6, #0
    @param    h   Height of bitmap in pixels
    @param    color 16-bit 5-6-5 Color to draw with
*/
/**************************************************************************/
void Adafruit_GFX::drawBitmap(int16_t x, int16_t y, uint8_t *bitmap, int16_t w,
                              int16_t h, uint16_t color) {
 80a10b2:	4605      	mov	r5, r0

  int16_t byteWidth = (w + 7) / 8; // Bitmap scanline pad = whole byte
  uint8_t byte = 0;

  startWrite();
 80a10b4:	4798      	blx	r3
 80a10b6:	2308      	movs	r3, #8
 80a10b8:	f109 0207 	add.w	r2, r9, #7
 80a10bc:	fb92 fbf3 	sdiv	fp, r2, r3
/**************************************************************************/
void Adafruit_GFX::drawBitmap(int16_t x, int16_t y, uint8_t *bitmap, int16_t w,
                              int16_t h, uint16_t color) {

  int16_t byteWidth = (w + 7) / 8; // Bitmap scanline pad = whole byte
  uint8_t byte = 0;
 80a10c0:	4634      	mov	r4, r6

  startWrite();
 80a10c2:	9600      	str	r6, [sp, #0]
  for (int16_t j = 0; j < h; j++, y++) {
    for (int16_t i = 0; i < w; i++) {
      if (i & 7)
        byte <<= 1;
      else
        byte = bitmap[j * byteWidth + i / 8];
 80a10c4:	9307      	str	r3, [sp, #28]
 80a10c6:	9a00      	ldr	r2, [sp, #0]
 80a10c8:	9b03      	ldr	r3, [sp, #12]
 80a10ca:	4413      	add	r3, r2
 80a10cc:	b21b      	sxth	r3, r3
 80a10ce:	9301      	str	r3, [sp, #4]

  int16_t byteWidth = (w + 7) / 8; // Bitmap scanline pad = whole byte
  uint8_t byte = 0;

  startWrite();
  for (int16_t j = 0; j < h; j++, y++) {
 80a10d0:	9a04      	ldr	r2, [sp, #16]
 80a10d2:	f9bd 3000 	ldrsh.w	r3, [sp]
 80a10d6:	429a      	cmp	r2, r3
 80a10d8:	dd28      	ble.n	80a112c <_ZN12Adafruit_GFX10drawBitmapEssPhsst+0x9c>
    for (int16_t i = 0; i < w; i++) {
      if (i & 7)
        byte <<= 1;
      else
        byte = bitmap[j * byteWidth + i / 8];
 80a10da:	eb0a 0306 	add.w	r3, sl, r6

  int16_t byteWidth = (w + 7) / 8; // Bitmap scanline pad = whole byte
  uint8_t byte = 0;

  startWrite();
  for (int16_t j = 0; j < h; j++, y++) {
 80a10de:	f04f 0800 	mov.w	r8, #0
    for (int16_t i = 0; i < w; i++) {
      if (i & 7)
        byte <<= 1;
      else
        byte = bitmap[j * byteWidth + i / 8];
 80a10e2:	9306      	str	r3, [sp, #24]
 80a10e4:	fa0f f388 	sxth.w	r3, r8
  int16_t byteWidth = (w + 7) / 8; // Bitmap scanline pad = whole byte
  uint8_t byte = 0;

  startWrite();
  for (int16_t j = 0; j < h; j++, y++) {
    for (int16_t i = 0; i < w; i++) {
 80a10e8:	454b      	cmp	r3, r9
 80a10ea:	da1a      	bge.n	80a1122 <_ZN12Adafruit_GFX10drawBitmapEssPhsst+0x92>
      if (i & 7)
 80a10ec:	fa1f f188 	uxth.w	r1, r8
 80a10f0:	074a      	lsls	r2, r1, #29
        byte <<= 1;
      else
        byte = bitmap[j * byteWidth + i / 8];
 80a10f2:	bf09      	itett	eq
 80a10f4:	9a07      	ldreq	r2, [sp, #28]

  startWrite();
  for (int16_t j = 0; j < h; j++, y++) {
    for (int16_t i = 0; i < w; i++) {
      if (i & 7)
        byte <<= 1;
 80a10f6:	0064      	lslne	r4, r4, #1
      else
        byte = bitmap[j * byteWidth + i / 8];
 80a10f8:	fb93 f3f2 	sdiveq	r3, r3, r2
 80a10fc:	9a06      	ldreq	r2, [sp, #24]

  startWrite();
  for (int16_t j = 0; j < h; j++, y++) {
    for (int16_t i = 0; i < w; i++) {
      if (i & 7)
        byte <<= 1;
 80a10fe:	bf14      	ite	ne
 80a1100:	b2e4      	uxtbne	r4, r4
      else
        byte = bitmap[j * byteWidth + i / 8];
 80a1102:	5cd4      	ldrbeq	r4, [r2, r3]
      if (byte & 0x80)
 80a1104:	0623      	lsls	r3, r4, #24
 80a1106:	d509      	bpl.n	80a111c <_ZN12Adafruit_GFX10drawBitmapEssPhsst+0x8c>
        writePixel(x + i, y, color);
 80a1108:	9b02      	ldr	r3, [sp, #8]
 80a110a:	9a01      	ldr	r2, [sp, #4]
 80a110c:	4419      	add	r1, r3
 80a110e:	682b      	ldr	r3, [r5, #0]
 80a1110:	b209      	sxth	r1, r1
 80a1112:	699b      	ldr	r3, [r3, #24]
 80a1114:	4628      	mov	r0, r5
 80a1116:	461f      	mov	r7, r3
 80a1118:	9b05      	ldr	r3, [sp, #20]
 80a111a:	47b8      	blx	r7
 80a111c:	f108 0801 	add.w	r8, r8, #1
  int16_t byteWidth = (w + 7) / 8; // Bitmap scanline pad = whole byte
  uint8_t byte = 0;

  startWrite();
  for (int16_t j = 0; j < h; j++, y++) {
    for (int16_t i = 0; i < w; i++) {
 80a1120:	e7e0      	b.n	80a10e4 <_ZN12Adafruit_GFX10drawBitmapEssPhsst+0x54>
 80a1122:	9b00      	ldr	r3, [sp, #0]
 80a1124:	445e      	add	r6, fp
 80a1126:	3301      	adds	r3, #1
 80a1128:	9300      	str	r3, [sp, #0]

  int16_t byteWidth = (w + 7) / 8; // Bitmap scanline pad = whole byte
  uint8_t byte = 0;

  startWrite();
  for (int16_t j = 0; j < h; j++, y++) {
 80a112a:	e7cc      	b.n	80a10c6 <_ZN12Adafruit_GFX10drawBitmapEssPhsst+0x36>
        byte = bitmap[j * byteWidth + i / 8];
      if (byte & 0x80)
        writePixel(x + i, y, color);
    }
  }
  endWrite();
 80a112c:	4628      	mov	r0, r5
 80a112e:	682b      	ldr	r3, [r5, #0]
 80a1130:	6adb      	ldr	r3, [r3, #44]	; 0x2c
}
 80a1132:	b009      	add	sp, #36	; 0x24
 80a1134:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
        byte = bitmap[j * byteWidth + i / 8];
      if (byte & 0x80)
        writePixel(x + i, y, color);
    }
  }
  endWrite();
 80a1138:	4718      	bx	r3

080a113a <_ZN12Adafruit_GFX10drawBitmapEssPKhsst>:
 80a113a:	b470      	push	{r4, r5, r6}
 80a113c:	f9bd 400c 	ldrsh.w	r4, [sp, #12]
 80a1140:	f9bd 5010 	ldrsh.w	r5, [sp, #16]
 80a1144:	f8bd 6014 	ldrh.w	r6, [sp, #20]
 80a1148:	9504      	str	r5, [sp, #16]
 80a114a:	9605      	str	r6, [sp, #20]
 80a114c:	9403      	str	r4, [sp, #12]
 80a114e:	bc70      	pop	{r4, r5, r6}
 80a1150:	f7ff bf9e 	b.w	80a1090 <_ZN12Adafruit_GFX10drawBitmapEssPhsst>

080a1154 <_ZN12Adafruit_GFX8drawCharEsshtthh>:
    @param    size_y  Font magnification level in Y-axis, 1 is 'original' size
*/
/**************************************************************************/
void Adafruit_GFX::drawChar(int16_t x, int16_t y, unsigned char c,
                            uint16_t color, uint16_t bg, uint8_t size_x,
                            uint8_t size_y) {
 80a1154:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80a1158:	b091      	sub	sp, #68	; 0x44
 80a115a:	4617      	mov	r7, r2
 80a115c:	4698      	mov	r8, r3

  if (!gfxFont) { // 'Classic' built-in font
 80a115e:	6a02      	ldr	r2, [r0, #32]
    @param    size_y  Font magnification level in Y-axis, 1 is 'original' size
*/
/**************************************************************************/
void Adafruit_GFX::drawChar(int16_t x, int16_t y, unsigned char c,
                            uint16_t color, uint16_t bg, uint8_t size_x,
                            uint8_t size_y) {
 80a1160:	f8bd 3068 	ldrh.w	r3, [sp, #104]	; 0x68
 80a1164:	4604      	mov	r4, r0
 80a1166:	9103      	str	r1, [sp, #12]
 80a1168:	9302      	str	r3, [sp, #8]
 80a116a:	f8bd 906c 	ldrh.w	r9, [sp, #108]	; 0x6c
 80a116e:	f89d 6070 	ldrb.w	r6, [sp, #112]	; 0x70
 80a1172:	f89d 5074 	ldrb.w	r5, [sp, #116]	; 0x74

  if (!gfxFont) { // 'Classic' built-in font
 80a1176:	2a00      	cmp	r2, #0
 80a1178:	f040 80b4 	bne.w	80a12e4 <_ZN12Adafruit_GFX8drawCharEsshtthh+0x190>

    if ((x >= _width) ||              // Clip right
 80a117c:	f9b0 300c 	ldrsh.w	r3, [r0, #12]
 80a1180:	428b      	cmp	r3, r1
 80a1182:	f340 813b 	ble.w	80a13fc <_ZN12Adafruit_GFX8drawCharEsshtthh+0x2a8>
 80a1186:	f9b0 300e 	ldrsh.w	r3, [r0, #14]
 80a118a:	42bb      	cmp	r3, r7
 80a118c:	f340 8136 	ble.w	80a13fc <_ZN12Adafruit_GFX8drawCharEsshtthh+0x2a8>
        (y >= _height) ||             // Clip bottom
 80a1190:	2306      	movs	r3, #6
 80a1192:	fb03 1306 	mla	r3, r3, r6, r1
 80a1196:	2b00      	cmp	r3, #0
 80a1198:	f340 8130 	ble.w	80a13fc <_ZN12Adafruit_GFX8drawCharEsshtthh+0x2a8>
        ((x + 6 * size_x - 1) < 0) || // Clip left
 80a119c:	eb07 03c5 	add.w	r3, r7, r5, lsl #3
 80a11a0:	2b00      	cmp	r3, #0
 80a11a2:	f340 812b 	ble.w	80a13fc <_ZN12Adafruit_GFX8drawCharEsshtthh+0x2a8>
        ((y + 8 * size_y - 1) < 0))   // Clip top
      return;

    if (!_cp437 && (c >= 176))
 80a11a6:	7f03      	ldrb	r3, [r0, #28]
 80a11a8:	b933      	cbnz	r3, 80a11b8 <_ZN12Adafruit_GFX8drawCharEsshtthh+0x64>
 80a11aa:	f1b8 0faf 	cmp.w	r8, #175	; 0xaf
      c++; // Handle 'classic' charset behavior
 80a11ae:	bf84      	itt	hi
 80a11b0:	f108 0801 	addhi.w	r8, r8, #1
 80a11b4:	fa5f f888 	uxtbhi.w	r8, r8

    startWrite();
 80a11b8:	6823      	ldr	r3, [r4, #0]
 80a11ba:	4620      	mov	r0, r4
 80a11bc:	695b      	ldr	r3, [r3, #20]
 80a11be:	4798      	blx	r3
    for (int8_t i = 0; i < 5; i++) { // Char bitmap = 5 columns
      uint8_t line = pgm_read_byte(&font[c * 5 + i]);
 80a11c0:	2305      	movs	r3, #5
 80a11c2:	9308      	str	r3, [sp, #32]
 80a11c4:	4b8f      	ldr	r3, [pc, #572]	; (80a1404 <_ZN12Adafruit_GFX8drawCharEsshtthh+0x2b0>)
 80a11c6:	eb08 0888 	add.w	r8, r8, r8, lsl #2
 80a11ca:	4443      	add	r3, r8
 80a11cc:	930c      	str	r3, [sp, #48]	; 0x30
                          color);
        } else if (bg != color) {
          if (size_x == 1 && size_y == 1)
            writePixel(x + i, y + j, bg);
          else
            writeFillRect(x + i * size_x, y + j * size_y, size_x, size_y, bg);
 80a11ce:	b233      	sxth	r3, r6

    if (!_cp437 && (c >= 176))
      c++; // Handle 'classic' charset behavior

    startWrite();
    for (int8_t i = 0; i < 5; i++) { // Char bitmap = 5 columns
 80a11d0:	f04f 0a00 	mov.w	sl, #0
                          color);
        } else if (bg != color) {
          if (size_x == 1 && size_y == 1)
            writePixel(x + i, y + j, bg);
          else
            writeFillRect(x + i * size_x, y + j * size_y, size_x, size_y, bg);
 80a11d4:	930b      	str	r3, [sp, #44]	; 0x2c
      for (int8_t j = 0; j < 8; j++, line >>= 1) {
        if (line & 1) {
          if (size_x == 1 && size_y == 1)
            writePixel(x + i, y + j, color);
          else
            writeFillRect(x + i * size_x, y + j * size_y, size_x, size_y,
 80a11d6:	b2b2      	uxth	r2, r6
 80a11d8:	9206      	str	r2, [sp, #24]
    if (!_cp437 && (c >= 176))
      c++; // Handle 'classic' charset behavior

    startWrite();
    for (int8_t i = 0; i < 5; i++) { // Char bitmap = 5 columns
      uint8_t line = pgm_read_byte(&font[c * 5 + i]);
 80a11da:	9b0c      	ldr	r3, [sp, #48]	; 0x30
      for (int8_t j = 0; j < 8; j++, line >>= 1) {
        if (line & 1) {
          if (size_x == 1 && size_y == 1)
            writePixel(x + i, y + j, color);
          else
            writeFillRect(x + i * size_x, y + j * size_y, size_x, size_y,
 80a11dc:	f8bd 200c 	ldrh.w	r2, [sp, #12]
    if (!_cp437 && (c >= 176))
      c++; // Handle 'classic' charset behavior

    startWrite();
    for (int8_t i = 0; i < 5; i++) { // Char bitmap = 5 columns
      uint8_t line = pgm_read_byte(&font[c * 5 + i]);
 80a11e0:	f813 300a 	ldrb.w	r3, [r3, sl]
      for (int8_t j = 0; j < 8; j++, line >>= 1) {
        if (line & 1) {
          if (size_x == 1 && size_y == 1)
            writePixel(x + i, y + j, color);
          else
            writeFillRect(x + i * size_x, y + j * size_y, size_x, size_y,
 80a11e4:	9204      	str	r2, [sp, #16]
 80a11e6:	9904      	ldr	r1, [sp, #16]
 80a11e8:	9a06      	ldr	r2, [sp, #24]
    if (!_cp437 && (c >= 176))
      c++; // Handle 'classic' charset behavior

    startWrite();
    for (int8_t i = 0; i < 5; i++) { // Char bitmap = 5 columns
      uint8_t line = pgm_read_byte(&font[c * 5 + i]);
 80a11ea:	9305      	str	r3, [sp, #20]
      for (int8_t j = 0; j < 8; j++, line >>= 1) {
        if (line & 1) {
          if (size_x == 1 && size_y == 1)
            writePixel(x + i, y + j, color);
          else
            writeFillRect(x + i * size_x, y + j * size_y, size_x, size_y,
 80a11ec:	fa1f f38a 	uxth.w	r3, sl
 80a11f0:	fb02 1203 	mla	r2, r2, r3, r1
                          color);
        } else if (bg != color) {
          if (size_x == 1 && size_y == 1)
            writePixel(x + i, y + j, bg);
 80a11f4:	440b      	add	r3, r1
      for (int8_t j = 0; j < 8; j++, line >>= 1) {
        if (line & 1) {
          if (size_x == 1 && size_y == 1)
            writePixel(x + i, y + j, color);
          else
            writeFillRect(x + i * size_x, y + j * size_y, size_x, size_y,
 80a11f6:	b212      	sxth	r2, r2
 80a11f8:	9207      	str	r2, [sp, #28]
                          color);
        } else if (bg != color) {
          if (size_x == 1 && size_y == 1)
            writePixel(x + i, y + j, bg);
 80a11fa:	b21b      	sxth	r3, r3
      for (int8_t j = 0; j < 8; j++, line >>= 1) {
        if (line & 1) {
          if (size_x == 1 && size_y == 1)
            writePixel(x + i, y + j, color);
          else
            writeFillRect(x + i * size_x, y + j * size_y, size_x, size_y,
 80a11fc:	2208      	movs	r2, #8
 80a11fe:	9209      	str	r2, [sp, #36]	; 0x24
      c++; // Handle 'classic' charset behavior

    startWrite();
    for (int8_t i = 0; i < 5; i++) { // Char bitmap = 5 columns
      uint8_t line = pgm_read_byte(&font[c * 5 + i]);
      for (int8_t j = 0; j < 8; j++, line >>= 1) {
 80a1200:	f04f 0800 	mov.w	r8, #0
          else
            writeFillRect(x + i * size_x, y + j * size_y, size_x, size_y,
                          color);
        } else if (bg != color) {
          if (size_x == 1 && size_y == 1)
            writePixel(x + i, y + j, bg);
 80a1204:	930a      	str	r3, [sp, #40]	; 0x28

    startWrite();
    for (int8_t i = 0; i < 5; i++) { // Char bitmap = 5 columns
      uint8_t line = pgm_read_byte(&font[c * 5 + i]);
      for (int8_t j = 0; j < 8; j++, line >>= 1) {
        if (line & 1) {
 80a1206:	9b05      	ldr	r3, [sp, #20]
 80a1208:	07da      	lsls	r2, r3, #31
 80a120a:	d510      	bpl.n	80a122e <_ZN12Adafruit_GFX8drawCharEsshtthh+0xda>
          if (size_x == 1 && size_y == 1)
 80a120c:	2e01      	cmp	r6, #1
 80a120e:	d108      	bne.n	80a1222 <_ZN12Adafruit_GFX8drawCharEsshtthh+0xce>
 80a1210:	2d01      	cmp	r5, #1
 80a1212:	d106      	bne.n	80a1222 <_ZN12Adafruit_GFX8drawCharEsshtthh+0xce>
            writePixel(x + i, y + j, color);
 80a1214:	6823      	ldr	r3, [r4, #0]
 80a1216:	eb08 0207 	add.w	r2, r8, r7
 80a121a:	f8d3 b018 	ldr.w	fp, [r3, #24]
 80a121e:	9b02      	ldr	r3, [sp, #8]
 80a1220:	e012      	b.n	80a1248 <_ZN12Adafruit_GFX8drawCharEsshtthh+0xf4>
          else
            writeFillRect(x + i * size_x, y + j * size_y, size_x, size_y,
                          color);
 80a1222:	9902      	ldr	r1, [sp, #8]
 80a1224:	fb08 7205 	mla	r2, r8, r5, r7
 80a1228:	6823      	ldr	r3, [r4, #0]
 80a122a:	9101      	str	r1, [sp, #4]
 80a122c:	e016      	b.n	80a125c <_ZN12Adafruit_GFX8drawCharEsshtthh+0x108>
        } else if (bg != color) {
 80a122e:	9b02      	ldr	r3, [sp, #8]
 80a1230:	454b      	cmp	r3, r9
 80a1232:	d01b      	beq.n	80a126c <_ZN12Adafruit_GFX8drawCharEsshtthh+0x118>
          if (size_x == 1 && size_y == 1)
 80a1234:	2e01      	cmp	r6, #1
 80a1236:	d10c      	bne.n	80a1252 <_ZN12Adafruit_GFX8drawCharEsshtthh+0xfe>
 80a1238:	2d01      	cmp	r5, #1
 80a123a:	d10a      	bne.n	80a1252 <_ZN12Adafruit_GFX8drawCharEsshtthh+0xfe>
            writePixel(x + i, y + j, bg);
 80a123c:	6823      	ldr	r3, [r4, #0]
 80a123e:	eb08 0207 	add.w	r2, r8, r7
 80a1242:	f8d3 b018 	ldr.w	fp, [r3, #24]
 80a1246:	464b      	mov	r3, r9
 80a1248:	b212      	sxth	r2, r2
 80a124a:	990a      	ldr	r1, [sp, #40]	; 0x28
 80a124c:	4620      	mov	r0, r4
 80a124e:	47d8      	blx	fp
 80a1250:	e00c      	b.n	80a126c <_ZN12Adafruit_GFX8drawCharEsshtthh+0x118>
          else
            writeFillRect(x + i * size_x, y + j * size_y, size_x, size_y, bg);
 80a1252:	fb08 7205 	mla	r2, r8, r5, r7
 80a1256:	6823      	ldr	r3, [r4, #0]
 80a1258:	f8cd 9004 	str.w	r9, [sp, #4]
 80a125c:	9500      	str	r5, [sp, #0]
 80a125e:	f8d3 b01c 	ldr.w	fp, [r3, #28]
 80a1262:	b212      	sxth	r2, r2
 80a1264:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 80a1266:	9907      	ldr	r1, [sp, #28]
 80a1268:	4620      	mov	r0, r4
 80a126a:	47d8      	blx	fp
      c++; // Handle 'classic' charset behavior

    startWrite();
    for (int8_t i = 0; i < 5; i++) { // Char bitmap = 5 columns
      uint8_t line = pgm_read_byte(&font[c * 5 + i]);
      for (int8_t j = 0; j < 8; j++, line >>= 1) {
 80a126c:	9b05      	ldr	r3, [sp, #20]
 80a126e:	f108 0801 	add.w	r8, r8, #1
 80a1272:	085b      	lsrs	r3, r3, #1
 80a1274:	9305      	str	r3, [sp, #20]
 80a1276:	9b09      	ldr	r3, [sp, #36]	; 0x24
 80a1278:	fa4f f888 	sxtb.w	r8, r8
 80a127c:	3b01      	subs	r3, #1
 80a127e:	f013 03ff 	ands.w	r3, r3, #255	; 0xff
 80a1282:	9309      	str	r3, [sp, #36]	; 0x24
 80a1284:	d1bf      	bne.n	80a1206 <_ZN12Adafruit_GFX8drawCharEsshtthh+0xb2>
 80a1286:	9b08      	ldr	r3, [sp, #32]

    if (!_cp437 && (c >= 176))
      c++; // Handle 'classic' charset behavior

    startWrite();
    for (int8_t i = 0; i < 5; i++) { // Char bitmap = 5 columns
 80a1288:	f10a 0a01 	add.w	sl, sl, #1
 80a128c:	3b01      	subs	r3, #1
 80a128e:	f013 03ff 	ands.w	r3, r3, #255	; 0xff
 80a1292:	fa4f fa8a 	sxtb.w	sl, sl
 80a1296:	9308      	str	r3, [sp, #32]
 80a1298:	d19d      	bne.n	80a11d6 <_ZN12Adafruit_GFX8drawCharEsshtthh+0x82>
          else
            writeFillRect(x + i * size_x, y + j * size_y, size_x, size_y, bg);
        }
      }
    }
    if (bg != color) { // If opaque, draw vertical line for last column
 80a129a:	9b02      	ldr	r3, [sp, #8]
 80a129c:	454b      	cmp	r3, r9
 80a129e:	f000 80a6 	beq.w	80a13ee <_ZN12Adafruit_GFX8drawCharEsshtthh+0x29a>
      if (size_x == 1 && size_y == 1)
 80a12a2:	2e01      	cmp	r6, #1
 80a12a4:	6823      	ldr	r3, [r4, #0]
 80a12a6:	d10c      	bne.n	80a12c2 <_ZN12Adafruit_GFX8drawCharEsshtthh+0x16e>
 80a12a8:	2d01      	cmp	r5, #1
 80a12aa:	d10a      	bne.n	80a12c2 <_ZN12Adafruit_GFX8drawCharEsshtthh+0x16e>
        writeFastVLine(x + 5, y, 8, bg);
 80a12ac:	9904      	ldr	r1, [sp, #16]
 80a12ae:	f8cd 9000 	str.w	r9, [sp]
 80a12b2:	3105      	adds	r1, #5
 80a12b4:	6a1d      	ldr	r5, [r3, #32]
 80a12b6:	463a      	mov	r2, r7
 80a12b8:	2308      	movs	r3, #8
 80a12ba:	b209      	sxth	r1, r1
 80a12bc:	4620      	mov	r0, r4
 80a12be:	47a8      	blx	r5
 80a12c0:	e095      	b.n	80a13ee <_ZN12Adafruit_GFX8drawCharEsshtthh+0x29a>
      else
        writeFillRect(x + 5 * size_x, y, size_x, 8 * size_y, bg);
 80a12c2:	9a06      	ldr	r2, [sp, #24]
 80a12c4:	00ed      	lsls	r5, r5, #3
 80a12c6:	eb02 0182 	add.w	r1, r2, r2, lsl #2
 80a12ca:	9a04      	ldr	r2, [sp, #16]
 80a12cc:	f8cd 9004 	str.w	r9, [sp, #4]
 80a12d0:	440a      	add	r2, r1
 80a12d2:	4611      	mov	r1, r2
 80a12d4:	9500      	str	r5, [sp, #0]
 80a12d6:	69dd      	ldr	r5, [r3, #28]
 80a12d8:	463a      	mov	r2, r7
 80a12da:	4633      	mov	r3, r6
 80a12dc:	b209      	sxth	r1, r1
 80a12de:	4620      	mov	r0, r4
 80a12e0:	47a8      	blx	r5
 80a12e2:	e084      	b.n	80a13ee <_ZN12Adafruit_GFX8drawCharEsshtthh+0x29a>
#else
  // expression in __AVR__ section may generate "dereferencing type-punned
  // pointer will break strict-aliasing rules" warning In fact, on other
  // platforms (such as STM32) there is no need to do this pointer magic as
  // program memory may be read in a usual way So expression may be simplified
  return gfxFont->glyph + c;
 80a12e4:	7a13      	ldrb	r3, [r2, #8]
 80a12e6:	6851      	ldr	r1, [r2, #4]
 80a12e8:	ebc3 0808 	rsb	r8, r3, r8
 80a12ec:	6812      	ldr	r2, [r2, #0]
 80a12ee:	fa5f f888 	uxtb.w	r8, r8
 80a12f2:	920d      	str	r2, [sp, #52]	; 0x34

    c -= (uint8_t)pgm_read_byte(&gfxFont->first);
    GFXglyph *glyph = pgm_read_glyph_ptr(gfxFont, c);
    uint8_t *bitmap = pgm_read_bitmap_ptr(gfxFont);

    uint16_t bo = pgm_read_word(&glyph->bitmapOffset);
 80a12f4:	f831 2038 	ldrh.w	r2, [r1, r8, lsl #3]
#else
  // expression in __AVR__ section may generate "dereferencing type-punned
  // pointer will break strict-aliasing rules" warning In fact, on other
  // platforms (such as STM32) there is no need to do this pointer magic as
  // program memory may be read in a usual way So expression may be simplified
  return gfxFont->glyph + c;
 80a12f8:	eb01 03c8 	add.w	r3, r1, r8, lsl #3

    c -= (uint8_t)pgm_read_byte(&gfxFont->first);
    GFXglyph *glyph = pgm_read_glyph_ptr(gfxFont, c);
    uint8_t *bitmap = pgm_read_bitmap_ptr(gfxFont);

    uint16_t bo = pgm_read_word(&glyph->bitmapOffset);
 80a12fc:	9204      	str	r2, [sp, #16]
    uint8_t w = pgm_read_byte(&glyph->width), h = pgm_read_byte(&glyph->height);
 80a12fe:	789a      	ldrb	r2, [r3, #2]
    int8_t xo = pgm_read_byte(&glyph->xOffset),
           yo = pgm_read_byte(&glyph->yOffset);
    uint8_t xx, yy, bits = 0, bit = 0;
    int16_t xo16 = 0, yo16 = 0;

    if (size_x > 1 || size_y > 1) {
 80a1300:	2e01      	cmp	r6, #1
    c -= (uint8_t)pgm_read_byte(&gfxFont->first);
    GFXglyph *glyph = pgm_read_glyph_ptr(gfxFont, c);
    uint8_t *bitmap = pgm_read_bitmap_ptr(gfxFont);

    uint16_t bo = pgm_read_word(&glyph->bitmapOffset);
    uint8_t w = pgm_read_byte(&glyph->width), h = pgm_read_byte(&glyph->height);
 80a1302:	9207      	str	r2, [sp, #28]
 80a1304:	78da      	ldrb	r2, [r3, #3]
    int8_t xo = pgm_read_byte(&glyph->xOffset),
           yo = pgm_read_byte(&glyph->yOffset);
 80a1306:	f993 b006 	ldrsb.w	fp, [r3, #6]
    c -= (uint8_t)pgm_read_byte(&gfxFont->first);
    GFXglyph *glyph = pgm_read_glyph_ptr(gfxFont, c);
    uint8_t *bitmap = pgm_read_bitmap_ptr(gfxFont);

    uint16_t bo = pgm_read_word(&glyph->bitmapOffset);
    uint8_t w = pgm_read_byte(&glyph->width), h = pgm_read_byte(&glyph->height);
 80a130a:	920a      	str	r2, [sp, #40]	; 0x28
    int8_t xo = pgm_read_byte(&glyph->xOffset),
 80a130c:	f993 2005 	ldrsb.w	r2, [r3, #5]
 80a1310:	9208      	str	r2, [sp, #32]
           yo = pgm_read_byte(&glyph->yOffset);
    uint8_t xx, yy, bits = 0, bit = 0;
    int16_t xo16 = 0, yo16 = 0;

    if (size_x > 1 || size_y > 1) {
 80a1312:	d801      	bhi.n	80a1318 <_ZN12Adafruit_GFX8drawCharEsshtthh+0x1c4>
 80a1314:	2d01      	cmp	r5, #1
 80a1316:	d906      	bls.n	80a1326 <_ZN12Adafruit_GFX8drawCharEsshtthh+0x1d2>
      xo16 = xo;
 80a1318:	f9bd 3020 	ldrsh.w	r3, [sp, #32]
 80a131c:	9306      	str	r3, [sp, #24]
      yo16 = yo;
 80a131e:	fa0f f38b 	sxth.w	r3, fp
 80a1322:	9305      	str	r3, [sp, #20]
 80a1324:	e002      	b.n	80a132c <_ZN12Adafruit_GFX8drawCharEsshtthh+0x1d8>
    uint16_t bo = pgm_read_word(&glyph->bitmapOffset);
    uint8_t w = pgm_read_byte(&glyph->width), h = pgm_read_byte(&glyph->height);
    int8_t xo = pgm_read_byte(&glyph->xOffset),
           yo = pgm_read_byte(&glyph->yOffset);
    uint8_t xx, yy, bits = 0, bit = 0;
    int16_t xo16 = 0, yo16 = 0;
 80a1326:	2300      	movs	r3, #0
 80a1328:	9305      	str	r3, [sp, #20]
 80a132a:	9306      	str	r3, [sp, #24]
    // only creates a new set of problems.  Have an idea to work around
    // this (a canvas object type for MCUs that can afford the RAM and
    // displays supporting setAddrWindow() and pushColors()), but haven't
    // implemented this yet.

    startWrite();
 80a132c:	f04f 0800 	mov.w	r8, #0

    uint16_t bo = pgm_read_word(&glyph->bitmapOffset);
    uint8_t w = pgm_read_byte(&glyph->width), h = pgm_read_byte(&glyph->height);
    int8_t xo = pgm_read_byte(&glyph->xOffset),
           yo = pgm_read_byte(&glyph->yOffset);
    uint8_t xx, yy, bits = 0, bit = 0;
 80a1330:	46c2      	mov	sl, r8
 80a1332:	46c1      	mov	r9, r8
    // only creates a new set of problems.  Have an idea to work around
    // this (a canvas object type for MCUs that can afford the RAM and
    // displays supporting setAddrWindow() and pushColors()), but haven't
    // implemented this yet.

    startWrite();
 80a1334:	6823      	ldr	r3, [r4, #0]
 80a1336:	4620      	mov	r0, r4
 80a1338:	695b      	ldr	r3, [r3, #20]
 80a133a:	4798      	blx	r3
        }
        if (bits & 0x80) {
          if (size_x == 1 && size_y == 1) {
            writePixel(x + xo + xx, y + yo + yy, color);
          } else {
            writeFillRect(x + (xo16 + xx) * size_x, y + (yo16 + yy) * size_y,
 80a133c:	b2bb      	uxth	r3, r7
 80a133e:	9309      	str	r3, [sp, #36]	; 0x24
        if (!(bit++ & 7)) {
          bits = pgm_read_byte(&bitmap[bo++]);
        }
        if (bits & 0x80) {
          if (size_x == 1 && size_y == 1) {
            writePixel(x + xo + xx, y + yo + yy, color);
 80a1340:	445b      	add	r3, fp
 80a1342:	930f      	str	r3, [sp, #60]	; 0x3c
    // this (a canvas object type for MCUs that can afford the RAM and
    // displays supporting setAddrWindow() and pushColors()), but haven't
    // implemented this yet.

    startWrite();
    for (yy = 0; yy < h; yy++) {
 80a1344:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 80a1346:	fa5f f388 	uxtb.w	r3, r8
 80a134a:	4293      	cmp	r3, r2
 80a134c:	d24f      	bcs.n	80a13ee <_ZN12Adafruit_GFX8drawCharEsshtthh+0x29a>
        }
        if (bits & 0x80) {
          if (size_x == 1 && size_y == 1) {
            writePixel(x + xo + xx, y + yo + yy, color);
          } else {
            writeFillRect(x + (xo16 + xx) * size_x, y + (yo16 + yy) * size_y,
 80a134e:	9a05      	ldr	r2, [sp, #20]
 80a1350:	9909      	ldr	r1, [sp, #36]	; 0x24
 80a1352:	4442      	add	r2, r8
 80a1354:	fb02 1205 	mla	r2, r2, r5, r1
 80a1358:	b212      	sxth	r2, r2
 80a135a:	920c      	str	r2, [sp, #48]	; 0x30
 80a135c:	4652      	mov	r2, sl
        if (!(bit++ & 7)) {
          bits = pgm_read_byte(&bitmap[bo++]);
        }
        if (bits & 0x80) {
          if (size_x == 1 && size_y == 1) {
            writePixel(x + xo + xx, y + yo + yy, color);
 80a135e:	990f      	ldr	r1, [sp, #60]	; 0x3c
          } else {
            writeFillRect(x + (xo16 + xx) * size_x, y + (yo16 + yy) * size_y,
 80a1360:	2700      	movs	r7, #0
        if (!(bit++ & 7)) {
          bits = pgm_read_byte(&bitmap[bo++]);
        }
        if (bits & 0x80) {
          if (size_x == 1 && size_y == 1) {
            writePixel(x + xo + xx, y + yo + yy, color);
 80a1362:	440b      	add	r3, r1
 80a1364:	b21b      	sxth	r3, r3
 80a1366:	930e      	str	r3, [sp, #56]	; 0x38
    // displays supporting setAddrWindow() and pushColors()), but haven't
    // implemented this yet.

    startWrite();
    for (yy = 0; yy < h; yy++) {
      for (xx = 0; xx < w; xx++) {
 80a1368:	9b07      	ldr	r3, [sp, #28]
 80a136a:	429f      	cmp	r7, r3
 80a136c:	d238      	bcs.n	80a13e0 <_ZN12Adafruit_GFX8drawCharEsshtthh+0x28c>
        if (!(bit++ & 7)) {
 80a136e:	1c53      	adds	r3, r2, #1
 80a1370:	b2db      	uxtb	r3, r3
 80a1372:	930b      	str	r3, [sp, #44]	; 0x2c
 80a1374:	0753      	lsls	r3, r2, #29
 80a1376:	d107      	bne.n	80a1388 <_ZN12Adafruit_GFX8drawCharEsshtthh+0x234>
          bits = pgm_read_byte(&bitmap[bo++]);
 80a1378:	9b04      	ldr	r3, [sp, #16]
 80a137a:	9904      	ldr	r1, [sp, #16]
 80a137c:	9a0d      	ldr	r2, [sp, #52]	; 0x34
 80a137e:	3301      	adds	r3, #1
 80a1380:	b29b      	uxth	r3, r3
 80a1382:	f812 9001 	ldrb.w	r9, [r2, r1]
 80a1386:	9304      	str	r3, [sp, #16]
        }
        if (bits & 0x80) {
 80a1388:	f019 0f80 	tst.w	r9, #128	; 0x80
 80a138c:	d020      	beq.n	80a13d0 <_ZN12Adafruit_GFX8drawCharEsshtthh+0x27c>
          if (size_x == 1 && size_y == 1) {
 80a138e:	2e01      	cmp	r6, #1
 80a1390:	d10e      	bne.n	80a13b0 <_ZN12Adafruit_GFX8drawCharEsshtthh+0x25c>
 80a1392:	2d01      	cmp	r5, #1
 80a1394:	d10c      	bne.n	80a13b0 <_ZN12Adafruit_GFX8drawCharEsshtthh+0x25c>
            writePixel(x + xo + xx, y + yo + yy, color);
 80a1396:	9b08      	ldr	r3, [sp, #32]
 80a1398:	9a03      	ldr	r2, [sp, #12]
 80a139a:	4620      	mov	r0, r4
 80a139c:	1899      	adds	r1, r3, r2
 80a139e:	6823      	ldr	r3, [r4, #0]
 80a13a0:	4439      	add	r1, r7
 80a13a2:	f8d3 b018 	ldr.w	fp, [r3, #24]
 80a13a6:	9a0e      	ldr	r2, [sp, #56]	; 0x38
 80a13a8:	9b02      	ldr	r3, [sp, #8]
 80a13aa:	b209      	sxth	r1, r1
 80a13ac:	47d8      	blx	fp
 80a13ae:	e00f      	b.n	80a13d0 <_ZN12Adafruit_GFX8drawCharEsshtthh+0x27c>
          } else {
            writeFillRect(x + (xo16 + xx) * size_x, y + (yo16 + yy) * size_y,
                          size_x, size_y, color);
 80a13b0:	9b06      	ldr	r3, [sp, #24]
 80a13b2:	9a02      	ldr	r2, [sp, #8]
 80a13b4:	19d9      	adds	r1, r3, r7
 80a13b6:	9b03      	ldr	r3, [sp, #12]
 80a13b8:	9201      	str	r2, [sp, #4]
 80a13ba:	fb01 3106 	mla	r1, r1, r6, r3
 80a13be:	6823      	ldr	r3, [r4, #0]
 80a13c0:	9500      	str	r5, [sp, #0]
 80a13c2:	f8d3 b01c 	ldr.w	fp, [r3, #28]
 80a13c6:	9a0c      	ldr	r2, [sp, #48]	; 0x30
 80a13c8:	4633      	mov	r3, r6
 80a13ca:	b209      	sxth	r1, r1
 80a13cc:	4620      	mov	r0, r4
 80a13ce:	47d8      	blx	fp
          }
        }
        bits <<= 1;
 80a13d0:	ea4f 0949 	mov.w	r9, r9, lsl #1
    // displays supporting setAddrWindow() and pushColors()), but haven't
    // implemented this yet.

    startWrite();
    for (yy = 0; yy < h; yy++) {
      for (xx = 0; xx < w; xx++) {
 80a13d4:	3701      	adds	r7, #1
          } else {
            writeFillRect(x + (xo16 + xx) * size_x, y + (yo16 + yy) * size_y,
                          size_x, size_y, color);
          }
        }
        bits <<= 1;
 80a13d6:	fa5f f989 	uxtb.w	r9, r9
    // displays supporting setAddrWindow() and pushColors()), but haven't
    // implemented this yet.

    startWrite();
    for (yy = 0; yy < h; yy++) {
      for (xx = 0; xx < w; xx++) {
 80a13da:	b2ff      	uxtb	r7, r7
        if (!(bit++ & 7)) {
 80a13dc:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
    // displays supporting setAddrWindow() and pushColors()), but haven't
    // implemented this yet.

    startWrite();
    for (yy = 0; yy < h; yy++) {
      for (xx = 0; xx < w; xx++) {
 80a13de:	e7c3      	b.n	80a1368 <_ZN12Adafruit_GFX8drawCharEsshtthh+0x214>
 80a13e0:	9b07      	ldr	r3, [sp, #28]
 80a13e2:	f108 0801 	add.w	r8, r8, #1
 80a13e6:	449a      	add	sl, r3
 80a13e8:	fa5f fa8a 	uxtb.w	sl, sl
    // this (a canvas object type for MCUs that can afford the RAM and
    // displays supporting setAddrWindow() and pushColors()), but haven't
    // implemented this yet.

    startWrite();
    for (yy = 0; yy < h; yy++) {
 80a13ec:	e7aa      	b.n	80a1344 <_ZN12Adafruit_GFX8drawCharEsshtthh+0x1f0>
          }
        }
        bits <<= 1;
      }
    }
    endWrite();
 80a13ee:	4620      	mov	r0, r4
 80a13f0:	6823      	ldr	r3, [r4, #0]
 80a13f2:	6adb      	ldr	r3, [r3, #44]	; 0x2c

  } // End classic vs custom font
}
 80a13f4:	b011      	add	sp, #68	; 0x44
 80a13f6:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
          }
        }
        bits <<= 1;
      }
    }
    endWrite();
 80a13fa:	4718      	bx	r3

  } // End classic vs custom font
}
 80a13fc:	b011      	add	sp, #68	; 0x44
 80a13fe:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80a1402:	bf00      	nop
 80a1404:	080a4554 	.word	0x080a4554

080a1408 <_ZN12Adafruit_GFX5writeEh>:
/*!
    @brief  Print one byte/character of data, used to support print()
    @param  c  The 8-bit ascii character to write
*/
/**************************************************************************/
size_t Adafruit_GFX::write(uint8_t c) {
 80a1408:	b5f0      	push	{r4, r5, r6, r7, lr}
  if (!gfxFont) { // 'Classic' built-in font
 80a140a:	6a02      	ldr	r2, [r0, #32]
/*!
    @brief  Print one byte/character of data, used to support print()
    @param  c  The 8-bit ascii character to write
*/
/**************************************************************************/
size_t Adafruit_GFX::write(uint8_t c) {
 80a140c:	b085      	sub	sp, #20
 80a140e:	4604      	mov	r4, r0
 80a1410:	460b      	mov	r3, r1
  if (!gfxFont) { // 'Classic' built-in font
 80a1412:	2a00      	cmp	r2, #0
 80a1414:	d12f      	bne.n	80a1476 <_ZN12Adafruit_GFX5writeEh+0x6e>

    if (c == '\n') {              // Newline?
 80a1416:	290a      	cmp	r1, #10
 80a1418:	d105      	bne.n	80a1426 <_ZN12Adafruit_GFX5writeEh+0x1e>
      cursor_x = 0;               // Reset x to zero,
 80a141a:	8202      	strh	r2, [r0, #16]
      cursor_y += textsize_y * 8; // advance y one line
 80a141c:	8a43      	ldrh	r3, [r0, #18]
 80a141e:	7e42      	ldrb	r2, [r0, #25]
 80a1420:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
 80a1424:	e030      	b.n	80a1488 <_ZN12Adafruit_GFX5writeEh+0x80>
    } else if (c != '\r') {       // Ignore carriage returns
 80a1426:	290d      	cmp	r1, #13
 80a1428:	d06a      	beq.n	80a1500 <_ZN12Adafruit_GFX5writeEh+0xf8>
      if (wrap && ((cursor_x + textsize_x * 6) > _width)) { // Off right?
 80a142a:	7ec1      	ldrb	r1, [r0, #27]
 80a142c:	7e45      	ldrb	r5, [r0, #25]
 80a142e:	7e00      	ldrb	r0, [r0, #24]
 80a1430:	b169      	cbz	r1, 80a144e <_ZN12Adafruit_GFX5writeEh+0x46>
 80a1432:	f9b4 6010 	ldrsh.w	r6, [r4, #16]
 80a1436:	2106      	movs	r1, #6
 80a1438:	fb01 6100 	mla	r1, r1, r0, r6
 80a143c:	f9b4 600c 	ldrsh.w	r6, [r4, #12]
 80a1440:	42b1      	cmp	r1, r6
        cursor_x = 0;                                       // Reset x to zero,
 80a1442:	bfc1      	itttt	gt
 80a1444:	8222      	strhgt	r2, [r4, #16]
        cursor_y += textsize_y * 8; // advance y one line
 80a1446:	8a62      	ldrhgt	r2, [r4, #18]
 80a1448:	eb02 02c5 	addgt.w	r2, r2, r5, lsl #3
 80a144c:	8262      	strhgt	r2, [r4, #18]
      }
      drawChar(cursor_x, cursor_y, c, textcolor, textbgcolor, textsize_x,
               textsize_y);
 80a144e:	9002      	str	r0, [sp, #8]
 80a1450:	8ae0      	ldrh	r0, [r4, #22]
 80a1452:	f9b4 2012 	ldrsh.w	r2, [r4, #18]
 80a1456:	9001      	str	r0, [sp, #4]
 80a1458:	8aa0      	ldrh	r0, [r4, #20]
 80a145a:	f9b4 1010 	ldrsh.w	r1, [r4, #16]
 80a145e:	9000      	str	r0, [sp, #0]
 80a1460:	9503      	str	r5, [sp, #12]
 80a1462:	4620      	mov	r0, r4
 80a1464:	f7ff fe76 	bl	80a1154 <_ZN12Adafruit_GFX8drawCharEsshtthh>
      cursor_x += textsize_x * 6; // Advance x one char
 80a1468:	7e23      	ldrb	r3, [r4, #24]
 80a146a:	8a22      	ldrh	r2, [r4, #16]
 80a146c:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 80a1470:	eb02 0343 	add.w	r3, r2, r3, lsl #1
 80a1474:	e043      	b.n	80a14fe <_ZN12Adafruit_GFX5writeEh+0xf6>
    }

  } else { // Custom font

    if (c == '\n') {
 80a1476:	290a      	cmp	r1, #10
 80a1478:	d108      	bne.n	80a148c <_ZN12Adafruit_GFX5writeEh+0x84>
      cursor_x = 0;
 80a147a:	2300      	movs	r3, #0
 80a147c:	8203      	strh	r3, [r0, #16]
      cursor_y +=
          (int16_t)textsize_y * (uint8_t)pgm_read_byte(&gfxFont->yAdvance);
 80a147e:	7e41      	ldrb	r1, [r0, #25]
 80a1480:	7b12      	ldrb	r2, [r2, #12]
 80a1482:	8a43      	ldrh	r3, [r0, #18]
 80a1484:	fb01 3302 	mla	r3, r1, r2, r3
 80a1488:	8263      	strh	r3, [r4, #18]
 80a148a:	e039      	b.n	80a1500 <_ZN12Adafruit_GFX5writeEh+0xf8>
    } else if (c != '\r') {
 80a148c:	290d      	cmp	r1, #13
 80a148e:	d037      	beq.n	80a1500 <_ZN12Adafruit_GFX5writeEh+0xf8>
      uint8_t first = pgm_read_byte(&gfxFont->first);
 80a1490:	7a15      	ldrb	r5, [r2, #8]
      if ((c >= first) && (c <= (uint8_t)pgm_read_byte(&gfxFont->last))) {
 80a1492:	42a9      	cmp	r1, r5
 80a1494:	d334      	bcc.n	80a1500 <_ZN12Adafruit_GFX5writeEh+0xf8>
 80a1496:	7a91      	ldrb	r1, [r2, #10]
 80a1498:	4299      	cmp	r1, r3
 80a149a:	d331      	bcc.n	80a1500 <_ZN12Adafruit_GFX5writeEh+0xf8>
#else
  // expression in __AVR__ section may generate "dereferencing type-punned
  // pointer will break strict-aliasing rules" warning In fact, on other
  // platforms (such as STM32) there is no need to do this pointer magic as
  // program memory may be read in a usual way So expression may be simplified
  return gfxFont->glyph + c;
 80a149c:	6851      	ldr	r1, [r2, #4]
 80a149e:	1b5d      	subs	r5, r3, r5
 80a14a0:	b2ed      	uxtb	r5, r5
 80a14a2:	eb01 05c5 	add.w	r5, r1, r5, lsl #3
          (int16_t)textsize_y * (uint8_t)pgm_read_byte(&gfxFont->yAdvance);
    } else if (c != '\r') {
      uint8_t first = pgm_read_byte(&gfxFont->first);
      if ((c >= first) && (c <= (uint8_t)pgm_read_byte(&gfxFont->last))) {
        GFXglyph *glyph = pgm_read_glyph_ptr(gfxFont, c - first);
        uint8_t w = pgm_read_byte(&glyph->width),
 80a14a6:	78a9      	ldrb	r1, [r5, #2]
                h = pgm_read_byte(&glyph->height);
        if ((w > 0) && (h > 0)) { // Is there an associated bitmap?
 80a14a8:	b321      	cbz	r1, 80a14f4 <_ZN12Adafruit_GFX5writeEh+0xec>
 80a14aa:	78e8      	ldrb	r0, [r5, #3]
 80a14ac:	b310      	cbz	r0, 80a14f4 <_ZN12Adafruit_GFX5writeEh+0xec>
          int16_t xo = (int8_t)pgm_read_byte(&glyph->xOffset); // sic
          if (wrap && ((cursor_x + textsize_x * (xo + w)) > _width)) {
 80a14ae:	7ee7      	ldrb	r7, [r4, #27]
 80a14b0:	7e66      	ldrb	r6, [r4, #25]
 80a14b2:	7e20      	ldrb	r0, [r4, #24]
 80a14b4:	b18f      	cbz	r7, 80a14da <_ZN12Adafruit_GFX5writeEh+0xd2>
 80a14b6:	f995 7005 	ldrsb.w	r7, [r5, #5]
 80a14ba:	4439      	add	r1, r7
 80a14bc:	f9b4 7010 	ldrsh.w	r7, [r4, #16]
 80a14c0:	fb00 7101 	mla	r1, r0, r1, r7
 80a14c4:	f9b4 700c 	ldrsh.w	r7, [r4, #12]
 80a14c8:	42b9      	cmp	r1, r7
 80a14ca:	dd06      	ble.n	80a14da <_ZN12Adafruit_GFX5writeEh+0xd2>
            cursor_x = 0;
 80a14cc:	2100      	movs	r1, #0
 80a14ce:	8221      	strh	r1, [r4, #16]
            cursor_y += (int16_t)textsize_y *
                        (uint8_t)pgm_read_byte(&gfxFont->yAdvance);
 80a14d0:	7b12      	ldrb	r2, [r2, #12]
 80a14d2:	8a61      	ldrh	r1, [r4, #18]
 80a14d4:	fb06 1202 	mla	r2, r6, r2, r1
 80a14d8:	8262      	strh	r2, [r4, #18]
          }
          drawChar(cursor_x, cursor_y, c, textcolor, textbgcolor, textsize_x,
                   textsize_y);
 80a14da:	9002      	str	r0, [sp, #8]
 80a14dc:	8ae0      	ldrh	r0, [r4, #22]
 80a14de:	f9b4 2012 	ldrsh.w	r2, [r4, #18]
 80a14e2:	9001      	str	r0, [sp, #4]
 80a14e4:	8aa0      	ldrh	r0, [r4, #20]
 80a14e6:	f9b4 1010 	ldrsh.w	r1, [r4, #16]
 80a14ea:	9000      	str	r0, [sp, #0]
 80a14ec:	9603      	str	r6, [sp, #12]
 80a14ee:	4620      	mov	r0, r4
 80a14f0:	f7ff fe30 	bl	80a1154 <_ZN12Adafruit_GFX8drawCharEsshtthh>
        }
        cursor_x +=
            (uint8_t)pgm_read_byte(&glyph->xAdvance) * (int16_t)textsize_x;
 80a14f4:	7929      	ldrb	r1, [r5, #4]
 80a14f6:	7e22      	ldrb	r2, [r4, #24]
 80a14f8:	8a23      	ldrh	r3, [r4, #16]
 80a14fa:	fb01 3302 	mla	r3, r1, r2, r3
 80a14fe:	8223      	strh	r3, [r4, #16]
      }
    }
  }
  return 1;
}
 80a1500:	2001      	movs	r0, #1
 80a1502:	b005      	add	sp, #20
 80a1504:	bdf0      	pop	{r4, r5, r6, r7, pc}

080a1506 <_GLOBAL__sub_I__ZN12Adafruit_GFXC2Ess>:
 80a1506:	f000 b95f 	b.w	80a17c8 <HAL_Pin_Map>

080a150a <_GLOBAL__sub_I__ZN15Adafruit_SPITFTC2Ettaaaaaa>:
 80a150a:	f000 b95d 	b.w	80a17c8 <HAL_Pin_Map>

080a150e <_GLOBAL__sub_I__ZN17Adafruit_GrayOLEDC2EhttP7TwoWireamm>:
 80a150e:	f000 b95b 	b.w	80a17c8 <HAL_Pin_Map>
	...

080a1514 <inet_gethostbyname>:
DYNALIB_FN(14, hal_wlan, wlan_set_error_count, void(uint32_t))
DYNALIB_FN(15, hal_wlan, wlan_fetch_ipconfig, int(WLanConfig*))
DYNALIB_FN(16, hal_wlan, wlan_setup, void(void))

DYNALIB_FN(17, hal_wlan, HAL_NET_SetNetWatchDog, uint32_t(uint32_t))
DYNALIB_FN(18, hal_wlan, inet_gethostbyname, int(const char*, uint16_t, HAL_IPAddress*, network_interface_t, void*))
 80a1514:	b508      	push	{r3, lr}
 80a1516:	4b02      	ldr	r3, [pc, #8]	; (80a1520 <inet_gethostbyname+0xc>)
 80a1518:	681b      	ldr	r3, [r3, #0]
 80a151a:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 80a151c:	9301      	str	r3, [sp, #4]
 80a151e:	bd08      	pop	{r3, pc}
 80a1520:	080601c0 	.word	0x080601c0

080a1524 <HAL_USB_USART_Init>:
#endif

DYNALIB_BEGIN(hal_usb)

#ifdef USB_CDC_ENABLE
DYNALIB_FN(0, hal_usb, HAL_USB_USART_Init, void(HAL_USB_USART_Serial, const HAL_USB_USART_Config*))
 80a1524:	b508      	push	{r3, lr}
 80a1526:	4b02      	ldr	r3, [pc, #8]	; (80a1530 <HAL_USB_USART_Init+0xc>)
 80a1528:	681b      	ldr	r3, [r3, #0]
 80a152a:	681b      	ldr	r3, [r3, #0]
 80a152c:	9301      	str	r3, [sp, #4]
 80a152e:	bd08      	pop	{r3, pc}
 80a1530:	080601d8 	.word	0x080601d8

080a1534 <HAL_USB_USART_Begin>:
DYNALIB_FN(1, hal_usb, HAL_USB_USART_Begin, void(HAL_USB_USART_Serial, uint32_t, void *))
 80a1534:	b508      	push	{r3, lr}
 80a1536:	4b02      	ldr	r3, [pc, #8]	; (80a1540 <HAL_USB_USART_Begin+0xc>)
 80a1538:	681b      	ldr	r3, [r3, #0]
 80a153a:	685b      	ldr	r3, [r3, #4]
 80a153c:	9301      	str	r3, [sp, #4]
 80a153e:	bd08      	pop	{r3, pc}
 80a1540:	080601d8 	.word	0x080601d8

080a1544 <HAL_USB_USART_End>:
DYNALIB_FN(2, hal_usb, HAL_USB_USART_End, void(HAL_USB_USART_Serial))
 80a1544:	b508      	push	{r3, lr}
 80a1546:	4b02      	ldr	r3, [pc, #8]	; (80a1550 <HAL_USB_USART_End+0xc>)
 80a1548:	681b      	ldr	r3, [r3, #0]
 80a154a:	689b      	ldr	r3, [r3, #8]
 80a154c:	9301      	str	r3, [sp, #4]
 80a154e:	bd08      	pop	{r3, pc}
 80a1550:	080601d8 	.word	0x080601d8

080a1554 <HAL_USB_USART_Available_Data>:
DYNALIB_FN(3, hal_usb, HAL_USB_USART_Baud_Rate, unsigned int(HAL_USB_USART_Serial))
DYNALIB_FN(4, hal_usb, HAL_USB_USART_Available_Data, int32_t(HAL_USB_USART_Serial))
 80a1554:	b508      	push	{r3, lr}
 80a1556:	4b02      	ldr	r3, [pc, #8]	; (80a1560 <HAL_USB_USART_Available_Data+0xc>)
 80a1558:	681b      	ldr	r3, [r3, #0]
 80a155a:	691b      	ldr	r3, [r3, #16]
 80a155c:	9301      	str	r3, [sp, #4]
 80a155e:	bd08      	pop	{r3, pc}
 80a1560:	080601d8 	.word	0x080601d8

080a1564 <HAL_USB_USART_Available_Data_For_Write>:
DYNALIB_FN(5, hal_usb, HAL_USB_USART_Available_Data_For_Write, int32_t(HAL_USB_USART_Serial))
 80a1564:	b508      	push	{r3, lr}
 80a1566:	4b02      	ldr	r3, [pc, #8]	; (80a1570 <HAL_USB_USART_Available_Data_For_Write+0xc>)
 80a1568:	681b      	ldr	r3, [r3, #0]
 80a156a:	695b      	ldr	r3, [r3, #20]
 80a156c:	9301      	str	r3, [sp, #4]
 80a156e:	bd08      	pop	{r3, pc}
 80a1570:	080601d8 	.word	0x080601d8

080a1574 <HAL_USB_USART_Receive_Data>:
DYNALIB_FN(6, hal_usb, HAL_USB_USART_Receive_Data, int32_t(HAL_USB_USART_Serial, uint8_t))
 80a1574:	b508      	push	{r3, lr}
 80a1576:	4b02      	ldr	r3, [pc, #8]	; (80a1580 <HAL_USB_USART_Receive_Data+0xc>)
 80a1578:	681b      	ldr	r3, [r3, #0]
 80a157a:	699b      	ldr	r3, [r3, #24]
 80a157c:	9301      	str	r3, [sp, #4]
 80a157e:	bd08      	pop	{r3, pc}
 80a1580:	080601d8 	.word	0x080601d8

080a1584 <HAL_USB_USART_Send_Data>:
DYNALIB_FN(7, hal_usb, HAL_USB_USART_Send_Data, int32_t(HAL_USB_USART_Serial, uint8_t))
 80a1584:	b508      	push	{r3, lr}
 80a1586:	4b02      	ldr	r3, [pc, #8]	; (80a1590 <HAL_USB_USART_Send_Data+0xc>)
 80a1588:	681b      	ldr	r3, [r3, #0]
 80a158a:	69db      	ldr	r3, [r3, #28]
 80a158c:	9301      	str	r3, [sp, #4]
 80a158e:	bd08      	pop	{r3, pc}
 80a1590:	080601d8 	.word	0x080601d8

080a1594 <HAL_USB_USART_Flush_Data>:
DYNALIB_FN(8, hal_usb, HAL_USB_USART_Flush_Data, void(HAL_USB_USART_Serial))
 80a1594:	b508      	push	{r3, lr}
 80a1596:	4b02      	ldr	r3, [pc, #8]	; (80a15a0 <HAL_USB_USART_Flush_Data+0xc>)
 80a1598:	681b      	ldr	r3, [r3, #0]
 80a159a:	6a1b      	ldr	r3, [r3, #32]
 80a159c:	9301      	str	r3, [sp, #4]
 80a159e:	bd08      	pop	{r3, pc}
 80a15a0:	080601d8 	.word	0x080601d8

080a15a4 <HAL_I2C_Set_Speed>:
#define BASE_IDX 16 // Base index for all subsequent functions
#else
#define BASE_IDX 0
#endif

DYNALIB_FN(BASE_IDX + 0, hal_i2c, HAL_I2C_Set_Speed, void(HAL_I2C_Interface, uint32_t, void*))
 80a15a4:	b508      	push	{r3, lr}
 80a15a6:	4b02      	ldr	r3, [pc, #8]	; (80a15b0 <HAL_I2C_Set_Speed+0xc>)
 80a15a8:	681b      	ldr	r3, [r3, #0]
 80a15aa:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 80a15ac:	9301      	str	r3, [sp, #4]
 80a15ae:	bd08      	pop	{r3, pc}
 80a15b0:	080601ac 	.word	0x080601ac

080a15b4 <HAL_I2C_Begin>:
DYNALIB_FN(BASE_IDX + 1, hal_i2c, HAL_I2C_Enable_DMA_Mode, void(HAL_I2C_Interface, bool, void*))
DYNALIB_FN(BASE_IDX + 2, hal_i2c, HAL_I2C_Stretch_Clock, void(HAL_I2C_Interface, bool, void*))
DYNALIB_FN(BASE_IDX + 3, hal_i2c, HAL_I2C_Begin, void(HAL_I2C_Interface, I2C_Mode, uint8_t, void*))
 80a15b4:	b508      	push	{r3, lr}
 80a15b6:	4b02      	ldr	r3, [pc, #8]	; (80a15c0 <HAL_I2C_Begin+0xc>)
 80a15b8:	681b      	ldr	r3, [r3, #0]
 80a15ba:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 80a15bc:	9301      	str	r3, [sp, #4]
 80a15be:	bd08      	pop	{r3, pc}
 80a15c0:	080601ac 	.word	0x080601ac

080a15c4 <HAL_I2C_Begin_Transmission>:
DYNALIB_FN(BASE_IDX + 4, hal_i2c, HAL_I2C_End, void(HAL_I2C_Interface, void*))
DYNALIB_FN(BASE_IDX + 5, hal_i2c, HAL_I2C_Request_Data, uint32_t(HAL_I2C_Interface, uint8_t, uint8_t, uint8_t, void*))
DYNALIB_FN(BASE_IDX + 6, hal_i2c, HAL_I2C_Begin_Transmission, void(HAL_I2C_Interface, uint8_t, const HAL_I2C_Transmission_Config*))
 80a15c4:	b508      	push	{r3, lr}
 80a15c6:	4b02      	ldr	r3, [pc, #8]	; (80a15d0 <HAL_I2C_Begin_Transmission+0xc>)
 80a15c8:	681b      	ldr	r3, [r3, #0]
 80a15ca:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 80a15cc:	9301      	str	r3, [sp, #4]
 80a15ce:	bd08      	pop	{r3, pc}
 80a15d0:	080601ac 	.word	0x080601ac

080a15d4 <HAL_I2C_End_Transmission>:
DYNALIB_FN(BASE_IDX + 7, hal_i2c, HAL_I2C_End_Transmission, uint8_t(HAL_I2C_Interface, uint8_t, void*))
 80a15d4:	b508      	push	{r3, lr}
 80a15d6:	4b02      	ldr	r3, [pc, #8]	; (80a15e0 <HAL_I2C_End_Transmission+0xc>)
 80a15d8:	681b      	ldr	r3, [r3, #0]
 80a15da:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 80a15dc:	9301      	str	r3, [sp, #4]
 80a15de:	bd08      	pop	{r3, pc}
 80a15e0:	080601ac 	.word	0x080601ac

080a15e4 <HAL_I2C_Write_Data>:
DYNALIB_FN(BASE_IDX + 8, hal_i2c, HAL_I2C_Write_Data, uint32_t(HAL_I2C_Interface, uint8_t, void*))
 80a15e4:	b508      	push	{r3, lr}
 80a15e6:	4b02      	ldr	r3, [pc, #8]	; (80a15f0 <HAL_I2C_Write_Data+0xc>)
 80a15e8:	681b      	ldr	r3, [r3, #0]
 80a15ea:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 80a15ec:	9301      	str	r3, [sp, #4]
 80a15ee:	bd08      	pop	{r3, pc}
 80a15f0:	080601ac 	.word	0x080601ac

080a15f4 <HAL_I2C_Available_Data>:
DYNALIB_FN(BASE_IDX + 9, hal_i2c, HAL_I2C_Available_Data, int32_t(HAL_I2C_Interface, void*))
 80a15f4:	b508      	push	{r3, lr}
 80a15f6:	4b02      	ldr	r3, [pc, #8]	; (80a1600 <HAL_I2C_Available_Data+0xc>)
 80a15f8:	681b      	ldr	r3, [r3, #0]
 80a15fa:	6e5b      	ldr	r3, [r3, #100]	; 0x64
 80a15fc:	9301      	str	r3, [sp, #4]
 80a15fe:	bd08      	pop	{r3, pc}
 80a1600:	080601ac 	.word	0x080601ac

080a1604 <HAL_I2C_Read_Data>:
DYNALIB_FN(BASE_IDX + 10, hal_i2c, HAL_I2C_Read_Data, int32_t(HAL_I2C_Interface, void*))
 80a1604:	b508      	push	{r3, lr}
 80a1606:	4b02      	ldr	r3, [pc, #8]	; (80a1610 <HAL_I2C_Read_Data+0xc>)
 80a1608:	681b      	ldr	r3, [r3, #0]
 80a160a:	6e9b      	ldr	r3, [r3, #104]	; 0x68
 80a160c:	9301      	str	r3, [sp, #4]
 80a160e:	bd08      	pop	{r3, pc}
 80a1610:	080601ac 	.word	0x080601ac

080a1614 <HAL_I2C_Peek_Data>:
DYNALIB_FN(BASE_IDX + 11, hal_i2c, HAL_I2C_Peek_Data, int32_t(HAL_I2C_Interface, void*))
 80a1614:	b508      	push	{r3, lr}
 80a1616:	4b02      	ldr	r3, [pc, #8]	; (80a1620 <HAL_I2C_Peek_Data+0xc>)
 80a1618:	681b      	ldr	r3, [r3, #0]
 80a161a:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 80a161c:	9301      	str	r3, [sp, #4]
 80a161e:	bd08      	pop	{r3, pc}
 80a1620:	080601ac 	.word	0x080601ac

080a1624 <HAL_I2C_Flush_Data>:
DYNALIB_FN(BASE_IDX + 12, hal_i2c, HAL_I2C_Flush_Data, void(HAL_I2C_Interface, void*))
 80a1624:	b508      	push	{r3, lr}
 80a1626:	4b02      	ldr	r3, [pc, #8]	; (80a1630 <HAL_I2C_Flush_Data+0xc>)
 80a1628:	681b      	ldr	r3, [r3, #0]
 80a162a:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 80a162c:	9301      	str	r3, [sp, #4]
 80a162e:	bd08      	pop	{r3, pc}
 80a1630:	080601ac 	.word	0x080601ac

080a1634 <HAL_I2C_Is_Enabled>:
DYNALIB_FN(BASE_IDX + 13, hal_i2c, HAL_I2C_Is_Enabled, bool(HAL_I2C_Interface, void*))
 80a1634:	b508      	push	{r3, lr}
 80a1636:	4b02      	ldr	r3, [pc, #8]	; (80a1640 <HAL_I2C_Is_Enabled+0xc>)
 80a1638:	681b      	ldr	r3, [r3, #0]
 80a163a:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 80a163c:	9301      	str	r3, [sp, #4]
 80a163e:	bd08      	pop	{r3, pc}
 80a1640:	080601ac 	.word	0x080601ac

080a1644 <HAL_I2C_Init>:
DYNALIB_FN(BASE_IDX + 14, hal_i2c, HAL_I2C_Set_Callback_On_Receive, void(HAL_I2C_Interface, void(*)(int), void*))
DYNALIB_FN(BASE_IDX + 15, hal_i2c, HAL_I2C_Set_Callback_On_Request, void(HAL_I2C_Interface, void(*)(void), void*))
DYNALIB_FN(BASE_IDX + 16, hal_i2c, HAL_I2C_Init, int(HAL_I2C_Interface, const HAL_I2C_Config*))
 80a1644:	b508      	push	{r3, lr}
 80a1646:	4b03      	ldr	r3, [pc, #12]	; (80a1654 <HAL_I2C_Init+0x10>)
 80a1648:	681b      	ldr	r3, [r3, #0]
 80a164a:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
 80a164e:	9301      	str	r3, [sp, #4]
 80a1650:	bd08      	pop	{r3, pc}
 80a1652:	0000      	.short	0x0000
 80a1654:	080601ac 	.word	0x080601ac

080a1658 <HAL_USART_Init>:
#define BASE_IDX 6 // Base index for all subsequent functions
#else
#define BASE_IDX 0
#endif

DYNALIB_FN(BASE_IDX + 0, hal_usart, HAL_USART_Init, void(HAL_USART_Serial, Ring_Buffer*, Ring_Buffer*))
 80a1658:	b508      	push	{r3, lr}
 80a165a:	4b02      	ldr	r3, [pc, #8]	; (80a1664 <HAL_USART_Init+0xc>)
 80a165c:	681b      	ldr	r3, [r3, #0]
 80a165e:	699b      	ldr	r3, [r3, #24]
 80a1660:	9301      	str	r3, [sp, #4]
 80a1662:	bd08      	pop	{r3, pc}
 80a1664:	080601c4 	.word	0x080601c4

080a1668 <HAL_USART_End>:
DYNALIB_FN(BASE_IDX + 1, hal_usart, HAL_USART_Begin, void(HAL_USART_Serial, uint32_t))
DYNALIB_FN(BASE_IDX + 2, hal_usart, HAL_USART_End, void(HAL_USART_Serial))
 80a1668:	b508      	push	{r3, lr}
 80a166a:	4b02      	ldr	r3, [pc, #8]	; (80a1674 <HAL_USART_End+0xc>)
 80a166c:	681b      	ldr	r3, [r3, #0]
 80a166e:	6a1b      	ldr	r3, [r3, #32]
 80a1670:	9301      	str	r3, [sp, #4]
 80a1672:	bd08      	pop	{r3, pc}
 80a1674:	080601c4 	.word	0x080601c4

080a1678 <HAL_USART_Write_Data>:
DYNALIB_FN(BASE_IDX + 3, hal_usart, HAL_USART_Write_Data, uint32_t(HAL_USART_Serial, uint8_t))
 80a1678:	b508      	push	{r3, lr}
 80a167a:	4b02      	ldr	r3, [pc, #8]	; (80a1684 <HAL_USART_Write_Data+0xc>)
 80a167c:	681b      	ldr	r3, [r3, #0]
 80a167e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80a1680:	9301      	str	r3, [sp, #4]
 80a1682:	bd08      	pop	{r3, pc}
 80a1684:	080601c4 	.word	0x080601c4

080a1688 <HAL_USART_Available_Data>:
DYNALIB_FN(BASE_IDX + 4, hal_usart, HAL_USART_Available_Data, int32_t(HAL_USART_Serial))
 80a1688:	b508      	push	{r3, lr}
 80a168a:	4b02      	ldr	r3, [pc, #8]	; (80a1694 <HAL_USART_Available_Data+0xc>)
 80a168c:	681b      	ldr	r3, [r3, #0]
 80a168e:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 80a1690:	9301      	str	r3, [sp, #4]
 80a1692:	bd08      	pop	{r3, pc}
 80a1694:	080601c4 	.word	0x080601c4

080a1698 <HAL_USART_Read_Data>:
DYNALIB_FN(BASE_IDX + 5, hal_usart, HAL_USART_Read_Data, int32_t(HAL_USART_Serial))
 80a1698:	b508      	push	{r3, lr}
 80a169a:	4b02      	ldr	r3, [pc, #8]	; (80a16a4 <HAL_USART_Read_Data+0xc>)
 80a169c:	681b      	ldr	r3, [r3, #0]
 80a169e:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80a16a0:	9301      	str	r3, [sp, #4]
 80a16a2:	bd08      	pop	{r3, pc}
 80a16a4:	080601c4 	.word	0x080601c4

080a16a8 <HAL_USART_Peek_Data>:
DYNALIB_FN(BASE_IDX + 6, hal_usart, HAL_USART_Peek_Data, int32_t(HAL_USART_Serial))
 80a16a8:	b508      	push	{r3, lr}
 80a16aa:	4b02      	ldr	r3, [pc, #8]	; (80a16b4 <HAL_USART_Peek_Data+0xc>)
 80a16ac:	681b      	ldr	r3, [r3, #0]
 80a16ae:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80a16b0:	9301      	str	r3, [sp, #4]
 80a16b2:	bd08      	pop	{r3, pc}
 80a16b4:	080601c4 	.word	0x080601c4

080a16b8 <HAL_USART_Flush_Data>:
DYNALIB_FN(BASE_IDX + 7, hal_usart, HAL_USART_Flush_Data, void(HAL_USART_Serial))
 80a16b8:	b508      	push	{r3, lr}
 80a16ba:	4b02      	ldr	r3, [pc, #8]	; (80a16c4 <HAL_USART_Flush_Data+0xc>)
 80a16bc:	681b      	ldr	r3, [r3, #0]
 80a16be:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 80a16c0:	9301      	str	r3, [sp, #4]
 80a16c2:	bd08      	pop	{r3, pc}
 80a16c4:	080601c4 	.word	0x080601c4

080a16c8 <HAL_USART_Is_Enabled>:
DYNALIB_FN(BASE_IDX + 8, hal_usart, HAL_USART_Is_Enabled, bool(HAL_USART_Serial))
 80a16c8:	b508      	push	{r3, lr}
 80a16ca:	4b02      	ldr	r3, [pc, #8]	; (80a16d4 <HAL_USART_Is_Enabled+0xc>)
 80a16cc:	681b      	ldr	r3, [r3, #0]
 80a16ce:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 80a16d0:	9301      	str	r3, [sp, #4]
 80a16d2:	bd08      	pop	{r3, pc}
 80a16d4:	080601c4 	.word	0x080601c4

080a16d8 <HAL_USART_Available_Data_For_Write>:
DYNALIB_FN(BASE_IDX + 9, hal_usart, HAL_USART_Half_Duplex, void(HAL_USART_Serial, bool))
DYNALIB_FN(BASE_IDX + 10, hal_usart, HAL_USART_Available_Data_For_Write, int32_t(HAL_USART_Serial))
 80a16d8:	b508      	push	{r3, lr}
 80a16da:	4b02      	ldr	r3, [pc, #8]	; (80a16e4 <HAL_USART_Available_Data_For_Write+0xc>)
 80a16dc:	681b      	ldr	r3, [r3, #0]
 80a16de:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 80a16e0:	9301      	str	r3, [sp, #4]
 80a16e2:	bd08      	pop	{r3, pc}
 80a16e4:	080601c4 	.word	0x080601c4

080a16e8 <HAL_USART_BeginConfig>:
#define BASE_IDX2 (BASE_IDX+13)
#else
#define BASE_IDX2 (BASE_IDX+11)
#endif

DYNALIB_FN(BASE_IDX2 + 0, hal_usart, HAL_USART_BeginConfig, void(HAL_USART_Serial serial, uint32_t baud, uint32_t config, void *ptr))
 80a16e8:	b508      	push	{r3, lr}
 80a16ea:	4b02      	ldr	r3, [pc, #8]	; (80a16f4 <HAL_USART_BeginConfig+0xc>)
 80a16ec:	681b      	ldr	r3, [r3, #0]
 80a16ee:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 80a16f0:	9301      	str	r3, [sp, #4]
 80a16f2:	bd08      	pop	{r3, pc}
 80a16f4:	080601c4 	.word	0x080601c4

080a16f8 <os_mutex_recursive_create>:
DYNALIB_FN(13, hal_concurrent, os_mutex_destroy, int(os_mutex_t))
DYNALIB_FN(14, hal_concurrent, os_mutex_lock, int(os_mutex_t))
DYNALIB_FN(15, hal_concurrent, os_mutex_trylock, int(os_mutex_t))
DYNALIB_FN(16, hal_concurrent, os_mutex_unlock, int(os_mutex_t))

DYNALIB_FN(17, hal_concurrent, os_mutex_recursive_create, int(os_mutex_recursive_t*))
 80a16f8:	b508      	push	{r3, lr}
 80a16fa:	4b02      	ldr	r3, [pc, #8]	; (80a1704 <os_mutex_recursive_create+0xc>)
 80a16fc:	681b      	ldr	r3, [r3, #0]
 80a16fe:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 80a1700:	9301      	str	r3, [sp, #4]
 80a1702:	bd08      	pop	{r3, pc}
 80a1704:	080601d0 	.word	0x080601d0

080a1708 <os_mutex_recursive_destroy>:
DYNALIB_FN(18, hal_concurrent, os_mutex_recursive_destroy, int(os_mutex_recursive_t))
 80a1708:	b508      	push	{r3, lr}
 80a170a:	4b02      	ldr	r3, [pc, #8]	; (80a1714 <os_mutex_recursive_destroy+0xc>)
 80a170c:	681b      	ldr	r3, [r3, #0]
 80a170e:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 80a1710:	9301      	str	r3, [sp, #4]
 80a1712:	bd08      	pop	{r3, pc}
 80a1714:	080601d0 	.word	0x080601d0

080a1718 <os_mutex_recursive_lock>:
DYNALIB_FN(19, hal_concurrent, os_mutex_recursive_lock, int(os_mutex_recursive_t))
 80a1718:	b508      	push	{r3, lr}
 80a171a:	4b02      	ldr	r3, [pc, #8]	; (80a1724 <os_mutex_recursive_lock+0xc>)
 80a171c:	681b      	ldr	r3, [r3, #0]
 80a171e:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 80a1720:	9301      	str	r3, [sp, #4]
 80a1722:	bd08      	pop	{r3, pc}
 80a1724:	080601d0 	.word	0x080601d0

080a1728 <os_mutex_recursive_unlock>:
DYNALIB_FN(20, hal_concurrent, os_mutex_recursive_trylock, int(os_mutex_recursive_t))
DYNALIB_FN(21, hal_concurrent, os_mutex_recursive_unlock, int(os_mutex_recursive_t))
 80a1728:	b508      	push	{r3, lr}
 80a172a:	4b02      	ldr	r3, [pc, #8]	; (80a1734 <os_mutex_recursive_unlock+0xc>)
 80a172c:	681b      	ldr	r3, [r3, #0]
 80a172e:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 80a1730:	9301      	str	r3, [sp, #4]
 80a1732:	bd08      	pop	{r3, pc}
 80a1734:	080601d0 	.word	0x080601d0

080a1738 <HAL_RNG_GetRandomNumber>:

DYNALIB_BEGIN(hal)

#if PLATFORM_ID > 3
DYNALIB_FN(0, hal, HAL_RNG_Configuration, void(void))
DYNALIB_FN(1, hal, HAL_RNG_GetRandomNumber, uint32_t(void))
 80a1738:	b508      	push	{r3, lr}
 80a173a:	4b02      	ldr	r3, [pc, #8]	; (80a1744 <HAL_RNG_GetRandomNumber+0xc>)
 80a173c:	681b      	ldr	r3, [r3, #0]
 80a173e:	685b      	ldr	r3, [r3, #4]
 80a1740:	9301      	str	r3, [sp, #4]
 80a1742:	bd08      	pop	{r3, pc}
 80a1744:	0806019c 	.word	0x0806019c

080a1748 <HAL_Delay_Microseconds>:
#else
#define BASE_IDX 0
#endif

DYNALIB_FN(BASE_IDX + 0, hal, HAL_Delay_Milliseconds, void(uint32_t))
DYNALIB_FN(BASE_IDX + 1, hal, HAL_Delay_Microseconds, void(uint32_t))
 80a1748:	b508      	push	{r3, lr}
 80a174a:	4b02      	ldr	r3, [pc, #8]	; (80a1754 <HAL_Delay_Microseconds+0xc>)
 80a174c:	681b      	ldr	r3, [r3, #0]
 80a174e:	68db      	ldr	r3, [r3, #12]
 80a1750:	9301      	str	r3, [sp, #4]
 80a1752:	bd08      	pop	{r3, pc}
 80a1754:	0806019c 	.word	0x0806019c

080a1758 <HAL_Timer_Get_Milli_Seconds>:
DYNALIB_FN(BASE_IDX + 2, hal, HAL_Timer_Get_Micro_Seconds, system_tick_t(void))
DYNALIB_FN(BASE_IDX + 3, hal, HAL_Timer_Get_Milli_Seconds, system_tick_t(void))
 80a1758:	b508      	push	{r3, lr}
 80a175a:	4b02      	ldr	r3, [pc, #8]	; (80a1764 <HAL_Timer_Get_Milli_Seconds+0xc>)
 80a175c:	681b      	ldr	r3, [r3, #0]
 80a175e:	695b      	ldr	r3, [r3, #20]
 80a1760:	9301      	str	r3, [sp, #4]
 80a1762:	bd08      	pop	{r3, pc}
 80a1764:	0806019c 	.word	0x0806019c

080a1768 <HAL_SPI_Begin>:
// New HAL functions must be added to the end of this list.
// GNINRAW

DYNALIB_BEGIN(hal_spi)

DYNALIB_FN(0, hal_spi, HAL_SPI_Begin, void(HAL_SPI_Interface, uint16_t))
 80a1768:	b508      	push	{r3, lr}
 80a176a:	4b02      	ldr	r3, [pc, #8]	; (80a1774 <HAL_SPI_Begin+0xc>)
 80a176c:	681b      	ldr	r3, [r3, #0]
 80a176e:	681b      	ldr	r3, [r3, #0]
 80a1770:	9301      	str	r3, [sp, #4]
 80a1772:	bd08      	pop	{r3, pc}
 80a1774:	080601b4 	.word	0x080601b4

080a1778 <HAL_SPI_Send_Receive_Data>:
DYNALIB_FN(1, hal_spi, HAL_SPI_End, void(HAL_SPI_Interface))
DYNALIB_FN(2, hal_spi, HAL_SPI_Set_Bit_Order, void(HAL_SPI_Interface, uint8_t))
DYNALIB_FN(3, hal_spi, HAL_SPI_Set_Data_Mode, void(HAL_SPI_Interface, uint8_t))
DYNALIB_FN(4, hal_spi, HAL_SPI_Set_Clock_Divider, void(HAL_SPI_Interface, uint8_t))
DYNALIB_FN(5, hal_spi, HAL_SPI_Send_Receive_Data, uint16_t(HAL_SPI_Interface, uint16_t))
 80a1778:	b508      	push	{r3, lr}
 80a177a:	4b02      	ldr	r3, [pc, #8]	; (80a1784 <HAL_SPI_Send_Receive_Data+0xc>)
 80a177c:	681b      	ldr	r3, [r3, #0]
 80a177e:	695b      	ldr	r3, [r3, #20]
 80a1780:	9301      	str	r3, [sp, #4]
 80a1782:	bd08      	pop	{r3, pc}
 80a1784:	080601b4 	.word	0x080601b4

080a1788 <HAL_SPI_Init>:
DYNALIB_FN(6, hal_spi, HAL_SPI_Is_Enabled_Old, bool(void))
DYNALIB_FN(7, hal_spi, HAL_SPI_Init, void(HAL_SPI_Interface))
 80a1788:	b508      	push	{r3, lr}
 80a178a:	4b02      	ldr	r3, [pc, #8]	; (80a1794 <HAL_SPI_Init+0xc>)
 80a178c:	681b      	ldr	r3, [r3, #0]
 80a178e:	69db      	ldr	r3, [r3, #28]
 80a1790:	9301      	str	r3, [sp, #4]
 80a1792:	bd08      	pop	{r3, pc}
 80a1794:	080601b4 	.word	0x080601b4

080a1798 <HAL_SPI_Is_Enabled>:
DYNALIB_FN(8, hal_spi, HAL_SPI_Is_Enabled, bool(HAL_SPI_Interface))
 80a1798:	b508      	push	{r3, lr}
 80a179a:	4b02      	ldr	r3, [pc, #8]	; (80a17a4 <HAL_SPI_Is_Enabled+0xc>)
 80a179c:	681b      	ldr	r3, [r3, #0]
 80a179e:	6a1b      	ldr	r3, [r3, #32]
 80a17a0:	9301      	str	r3, [sp, #4]
 80a17a2:	bd08      	pop	{r3, pc}
 80a17a4:	080601b4 	.word	0x080601b4

080a17a8 <HAL_SPI_Info>:
DYNALIB_FN(9, hal_spi, HAL_SPI_Info, void(HAL_SPI_Interface, hal_spi_info_t*, void*))
 80a17a8:	b508      	push	{r3, lr}
 80a17aa:	4b02      	ldr	r3, [pc, #8]	; (80a17b4 <HAL_SPI_Info+0xc>)
 80a17ac:	681b      	ldr	r3, [r3, #0]
 80a17ae:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80a17b0:	9301      	str	r3, [sp, #4]
 80a17b2:	bd08      	pop	{r3, pc}
 80a17b4:	080601b4 	.word	0x080601b4

080a17b8 <HAL_SPI_Set_Settings>:
DYNALIB_FN(10, hal_spi, HAL_SPI_DMA_Transfer, void(HAL_SPI_Interface, void*, void*, uint32_t, HAL_SPI_DMA_UserCallback))
DYNALIB_FN(11, hal_spi, HAL_SPI_Begin_Ext, void(HAL_SPI_Interface, SPI_Mode, uint16_t, void*))
DYNALIB_FN(12, hal_spi, HAL_SPI_Set_Callback_On_Select, void(HAL_SPI_Interface, HAL_SPI_Select_UserCallback, void*))
DYNALIB_FN(13, hal_spi, HAL_SPI_DMA_Transfer_Cancel, void(HAL_SPI_Interface))
DYNALIB_FN(14, hal_spi, HAL_SPI_DMA_Transfer_Status, int32_t(HAL_SPI_Interface, HAL_SPI_TransferStatus*))
DYNALIB_FN(15, hal_spi, HAL_SPI_Set_Settings, int32_t(HAL_SPI_Interface, uint8_t, uint8_t, uint8_t, uint8_t, void*))
 80a17b8:	b508      	push	{r3, lr}
 80a17ba:	4b02      	ldr	r3, [pc, #8]	; (80a17c4 <HAL_SPI_Set_Settings+0xc>)
 80a17bc:	681b      	ldr	r3, [r3, #0]
 80a17be:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 80a17c0:	9301      	str	r3, [sp, #4]
 80a17c2:	bd08      	pop	{r3, pc}
 80a17c4:	080601b4 	.word	0x080601b4

080a17c8 <HAL_Pin_Map>:
// New HAL functions must be added to the end of this list.
// GNINRAW

DYNALIB_BEGIN(hal_gpio)

DYNALIB_FN(0, hal_gpio, HAL_Pin_Map, Hal_Pin_Info*(void))
 80a17c8:	b508      	push	{r3, lr}
 80a17ca:	4b02      	ldr	r3, [pc, #8]	; (80a17d4 <HAL_Pin_Map+0xc>)
 80a17cc:	681b      	ldr	r3, [r3, #0]
 80a17ce:	681b      	ldr	r3, [r3, #0]
 80a17d0:	9301      	str	r3, [sp, #4]
 80a17d2:	bd08      	pop	{r3, pc}
 80a17d4:	080601b0 	.word	0x080601b0

080a17d8 <HAL_Pin_Mode>:
DYNALIB_FN(1, hal_gpio, HAL_Validate_Pin_Function, PinFunction(pin_t, PinFunction))
DYNALIB_FN(2, hal_gpio, HAL_Pin_Mode, void(pin_t, PinMode))
 80a17d8:	b508      	push	{r3, lr}
 80a17da:	4b02      	ldr	r3, [pc, #8]	; (80a17e4 <HAL_Pin_Mode+0xc>)
 80a17dc:	681b      	ldr	r3, [r3, #0]
 80a17de:	689b      	ldr	r3, [r3, #8]
 80a17e0:	9301      	str	r3, [sp, #4]
 80a17e2:	bd08      	pop	{r3, pc}
 80a17e4:	080601b0 	.word	0x080601b0

080a17e8 <HAL_Get_Pin_Mode>:
DYNALIB_FN(3, hal_gpio, HAL_Get_Pin_Mode, PinMode(pin_t))
 80a17e8:	b508      	push	{r3, lr}
 80a17ea:	4b02      	ldr	r3, [pc, #8]	; (80a17f4 <HAL_Get_Pin_Mode+0xc>)
 80a17ec:	681b      	ldr	r3, [r3, #0]
 80a17ee:	68db      	ldr	r3, [r3, #12]
 80a17f0:	9301      	str	r3, [sp, #4]
 80a17f2:	bd08      	pop	{r3, pc}
 80a17f4:	080601b0 	.word	0x080601b0

080a17f8 <HAL_GPIO_Write>:
DYNALIB_FN(4, hal_gpio, HAL_GPIO_Write, void(pin_t, uint8_t))
 80a17f8:	b508      	push	{r3, lr}
 80a17fa:	4b02      	ldr	r3, [pc, #8]	; (80a1804 <HAL_GPIO_Write+0xc>)
 80a17fc:	681b      	ldr	r3, [r3, #0]
 80a17fe:	691b      	ldr	r3, [r3, #16]
 80a1800:	9301      	str	r3, [sp, #4]
 80a1802:	bd08      	pop	{r3, pc}
 80a1804:	080601b0 	.word	0x080601b0

080a1808 <panic_>:
DYNALIB_FN(9, services, LED_Toggle, void(Led_TypeDef))
DYNALIB_FN(10, services, LED_Fade, void(Led_TypeDef))
DYNALIB_FN(11, services, Get_LED_Brightness, uint8_t(void))

DYNALIB_FN(12, services, set_logger_output, void(debug_output_fn, LoggerOutputLevel)) // Deprecated
DYNALIB_FN(13, services, panic_, void(ePanicCode, void*, void(*)(uint32_t)))
 80a1808:	b508      	push	{r3, lr}
 80a180a:	4b02      	ldr	r3, [pc, #8]	; (80a1814 <panic_+0xc>)
 80a180c:	681b      	ldr	r3, [r3, #0]
 80a180e:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 80a1810:	9301      	str	r3, [sp, #4]
 80a1812:	bd08      	pop	{r3, pc}
 80a1814:	080201a8 	.word	0x080201a8

080a1818 <log_message_v>:
DYNALIB_FN(17, services, LED_RGB_SetChangeHandler, void(led_update_handler_fn, void*))
DYNALIB_FN(18, services, log_print_direct_, void(int, void*, const char*, ...)) // Deprecated
DYNALIB_FN(19, services, LED_GetColor, uint32_t(uint32_t, void*))

DYNALIB_FN(20, services, log_message, void(int, const char*, LogAttributes*, void*, const char*, ...))
DYNALIB_FN(21, services, log_message_v, void(int, const char*, LogAttributes*, void*, const char*, va_list))
 80a1818:	b508      	push	{r3, lr}
 80a181a:	4b02      	ldr	r3, [pc, #8]	; (80a1824 <log_message_v+0xc>)
 80a181c:	681b      	ldr	r3, [r3, #0]
 80a181e:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 80a1820:	9301      	str	r3, [sp, #4]
 80a1822:	bd08      	pop	{r3, pc}
 80a1824:	080201a8 	.word	0x080201a8

080a1828 <log_level_name>:
DYNALIB_FN(22, services, log_write, void(int, const char*, const char*, size_t, void*))
DYNALIB_FN(23, services, log_printf, void(int, const char*, void*, const char*, ...))
DYNALIB_FN(24, services, log_printf_v, void(int, const char*, void*, const char*, va_list))
DYNALIB_FN(25, services, log_dump, void(int, const char*, const void*, size_t, int, void*))
DYNALIB_FN(26, services, log_enabled, int(int, const char*, void*))
DYNALIB_FN(27, services, log_level_name, const char*(int, void*))
 80a1828:	b508      	push	{r3, lr}
 80a182a:	4b02      	ldr	r3, [pc, #8]	; (80a1834 <log_level_name+0xc>)
 80a182c:	681b      	ldr	r3, [r3, #0]
 80a182e:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 80a1830:	9301      	str	r3, [sp, #4]
 80a1832:	bd08      	pop	{r3, pc}
 80a1834:	080201a8 	.word	0x080201a8

080a1838 <log_set_callbacks>:
DYNALIB_FN(28, services, log_set_callbacks, void(log_message_callback_type, log_write_callback_type, log_enabled_callback_type, void*))
 80a1838:	b508      	push	{r3, lr}
 80a183a:	4b02      	ldr	r3, [pc, #8]	; (80a1844 <log_set_callbacks+0xc>)
 80a183c:	681b      	ldr	r3, [r3, #0]
 80a183e:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 80a1840:	9301      	str	r3, [sp, #4]
 80a1842:	bd08      	pop	{r3, pc}
 80a1844:	080201a8 	.word	0x080201a8

080a1848 <spark_set_random_seed_from_cloud_handler>:
DYNALIB_FN(10, system_cloud, spark_unsubscribe, void(void*))
DYNALIB_FN(11, system_cloud, spark_sync_time, bool(void*))
DYNALIB_FN(12, system_cloud, spark_sync_time_pending, bool(void*))
DYNALIB_FN(13, system_cloud, spark_sync_time_last, system_tick_t(time_t*, void*))
DYNALIB_FN(14, system_cloud, spark_set_connection_property, int(unsigned, unsigned, particle::protocol::connection_properties_t*, void*))
DYNALIB_FN(15, system_cloud, spark_set_random_seed_from_cloud_handler, int(void (*handler)(unsigned int), void*))
 80a1848:	b508      	push	{r3, lr}
 80a184a:	4b02      	ldr	r3, [pc, #8]	; (80a1854 <spark_set_random_seed_from_cloud_handler+0xc>)
 80a184c:	681b      	ldr	r3, [r3, #0]
 80a184e:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 80a1850:	9301      	str	r3, [sp, #4]
 80a1852:	bd08      	pop	{r3, pc}
 80a1854:	080601cc 	.word	0x080601cc

080a1858 <network_connect>:
#endif

DYNALIB_BEGIN(system_net)

DYNALIB_FN(0, system_net, network_config, const void*(network_handle_t, uint32_t, void*))
DYNALIB_FN(1, system_net, network_connect, void(network_handle_t, uint32_t, uint32_t, void*))
 80a1858:	b508      	push	{r3, lr}
 80a185a:	4b02      	ldr	r3, [pc, #8]	; (80a1864 <network_connect+0xc>)
 80a185c:	681b      	ldr	r3, [r3, #0]
 80a185e:	685b      	ldr	r3, [r3, #4]
 80a1860:	9301      	str	r3, [sp, #4]
 80a1862:	bd08      	pop	{r3, pc}
 80a1864:	080601c8 	.word	0x080601c8

080a1868 <network_connecting>:
DYNALIB_FN(2, system_net, network_connecting, bool(network_handle_t, uint32_t, void*))
 80a1868:	b508      	push	{r3, lr}
 80a186a:	4b02      	ldr	r3, [pc, #8]	; (80a1874 <network_connecting+0xc>)
 80a186c:	681b      	ldr	r3, [r3, #0]
 80a186e:	689b      	ldr	r3, [r3, #8]
 80a1870:	9301      	str	r3, [sp, #4]
 80a1872:	bd08      	pop	{r3, pc}
 80a1874:	080601c8 	.word	0x080601c8

080a1878 <network_disconnect>:
DYNALIB_FN(3, system_net, network_disconnect, void(network_handle_t, uint32_t, void*))
 80a1878:	b508      	push	{r3, lr}
 80a187a:	4b02      	ldr	r3, [pc, #8]	; (80a1884 <network_disconnect+0xc>)
 80a187c:	681b      	ldr	r3, [r3, #0]
 80a187e:	68db      	ldr	r3, [r3, #12]
 80a1880:	9301      	str	r3, [sp, #4]
 80a1882:	bd08      	pop	{r3, pc}
 80a1884:	080601c8 	.word	0x080601c8

080a1888 <network_ready>:
DYNALIB_FN(4, system_net, network_ready, bool(network_handle_t, uint32_t, void*))
 80a1888:	b508      	push	{r3, lr}
 80a188a:	4b02      	ldr	r3, [pc, #8]	; (80a1894 <network_ready+0xc>)
 80a188c:	681b      	ldr	r3, [r3, #0]
 80a188e:	691b      	ldr	r3, [r3, #16]
 80a1890:	9301      	str	r3, [sp, #4]
 80a1892:	bd08      	pop	{r3, pc}
 80a1894:	080601c8 	.word	0x080601c8

080a1898 <network_on>:
DYNALIB_FN(5, system_net, network_on, void(network_handle_t, uint32_t, uint32_t, void*))
 80a1898:	b508      	push	{r3, lr}
 80a189a:	4b02      	ldr	r3, [pc, #8]	; (80a18a4 <network_on+0xc>)
 80a189c:	681b      	ldr	r3, [r3, #0]
 80a189e:	695b      	ldr	r3, [r3, #20]
 80a18a0:	9301      	str	r3, [sp, #4]
 80a18a2:	bd08      	pop	{r3, pc}
 80a18a4:	080601c8 	.word	0x080601c8

080a18a8 <network_off>:
DYNALIB_FN(6, system_net, network_off, void(network_handle_t, uint32_t, uint32_t, void*))
 80a18a8:	b508      	push	{r3, lr}
 80a18aa:	4b02      	ldr	r3, [pc, #8]	; (80a18b4 <network_off+0xc>)
 80a18ac:	681b      	ldr	r3, [r3, #0]
 80a18ae:	699b      	ldr	r3, [r3, #24]
 80a18b0:	9301      	str	r3, [sp, #4]
 80a18b2:	bd08      	pop	{r3, pc}
 80a18b4:	080601c8 	.word	0x080601c8

080a18b8 <network_listen>:
DYNALIB_FN(7, system_net, network_listen, void(network_handle_t, uint32_t, void*))
 80a18b8:	b508      	push	{r3, lr}
 80a18ba:	4b02      	ldr	r3, [pc, #8]	; (80a18c4 <network_listen+0xc>)
 80a18bc:	681b      	ldr	r3, [r3, #0]
 80a18be:	69db      	ldr	r3, [r3, #28]
 80a18c0:	9301      	str	r3, [sp, #4]
 80a18c2:	bd08      	pop	{r3, pc}
 80a18c4:	080601c8 	.word	0x080601c8

080a18c8 <network_listening>:
DYNALIB_FN(8, system_net, network_listening, bool(network_handle_t, uint32_t, void*))
 80a18c8:	b508      	push	{r3, lr}
 80a18ca:	4b02      	ldr	r3, [pc, #8]	; (80a18d4 <network_listening+0xc>)
 80a18cc:	681b      	ldr	r3, [r3, #0]
 80a18ce:	6a1b      	ldr	r3, [r3, #32]
 80a18d0:	9301      	str	r3, [sp, #4]
 80a18d2:	bd08      	pop	{r3, pc}
 80a18d4:	080601c8 	.word	0x080601c8

080a18d8 <network_set_listen_timeout>:
DYNALIB_FN(9, system_net, network_has_credentials, bool(network_handle_t, uint32_t, void*))
DYNALIB_FN(10, system_net, network_set_credentials, int(network_handle_t, uint32_t, NetworkCredentials*, void*))
DYNALIB_FN(11, system_net, network_clear_credentials, bool(network_handle_t, uint32_t, NetworkCredentials*, void*))
DYNALIB_FN(12, system_net, network_set_listen_timeout, void(network_handle_t, uint16_t, void*))
 80a18d8:	b508      	push	{r3, lr}
 80a18da:	4b02      	ldr	r3, [pc, #8]	; (80a18e4 <network_set_listen_timeout+0xc>)
 80a18dc:	681b      	ldr	r3, [r3, #0]
 80a18de:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80a18e0:	9301      	str	r3, [sp, #4]
 80a18e2:	bd08      	pop	{r3, pc}
 80a18e4:	080601c8 	.word	0x080601c8

080a18e8 <network_get_listen_timeout>:
DYNALIB_FN(13, system_net, network_get_listen_timeout, uint16_t(network_handle_t, uint32_t, void*))
 80a18e8:	b508      	push	{r3, lr}
 80a18ea:	4b02      	ldr	r3, [pc, #8]	; (80a18f4 <network_get_listen_timeout+0xc>)
 80a18ec:	681b      	ldr	r3, [r3, #0]
 80a18ee:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 80a18f0:	9301      	str	r3, [sp, #4]
 80a18f2:	bd08      	pop	{r3, pc}
 80a18f4:	080601c8 	.word	0x080601c8

080a18f8 <set_system_mode>:
#endif

DYNALIB_BEGIN(system)

DYNALIB_FN(0, system, system_mode, System_Mode_TypeDef(void))
DYNALIB_FN(1, system, set_system_mode, void(System_Mode_TypeDef))
 80a18f8:	b508      	push	{r3, lr}
 80a18fa:	4b02      	ldr	r3, [pc, #8]	; (80a1904 <set_system_mode+0xc>)
 80a18fc:	681b      	ldr	r3, [r3, #0]
 80a18fe:	685b      	ldr	r3, [r3, #4]
 80a1900:	9301      	str	r3, [sp, #4]
 80a1902:	bd08      	pop	{r3, pc}
 80a1904:	080601a4 	.word	0x080601a4

080a1908 <system_delay_ms>:

DYNALIB_FN(2, system, set_ymodem_serial_flash_update_handler, void(ymodem_serial_flash_update_handler))
DYNALIB_FN(3, system, system_firmwareUpdate, bool(Stream*, void*))
DYNALIB_FN(4, system, system_fileTransfer, bool(system_file_transfer_t*, void*))

DYNALIB_FN(5, system, system_delay_ms, void(unsigned long, bool))
 80a1908:	b508      	push	{r3, lr}
 80a190a:	4b02      	ldr	r3, [pc, #8]	; (80a1914 <system_delay_ms+0xc>)
 80a190c:	681b      	ldr	r3, [r3, #0]
 80a190e:	695b      	ldr	r3, [r3, #20]
 80a1910:	9301      	str	r3, [sp, #4]
 80a1912:	bd08      	pop	{r3, pc}
 80a1914:	080601a4 	.word	0x080601a4

080a1918 <system_ctrl_set_app_request_handler>:
DYNALIB_FN(BASE_IDX + 6, system, led_pattern_period, uint16_t(int, int, void*))
DYNALIB_FN(BASE_IDX + 7, system, system_set_tester_handlers, int(system_tester_handlers_t*, void*))
DYNALIB_FN(BASE_IDX + 8, system, system_format_diag_data, int(const uint16_t*, size_t, unsigned, appender_fn, void*, void*))

// Control requests
DYNALIB_FN(BASE_IDX + 9, system, system_ctrl_set_app_request_handler, int(ctrl_request_handler_fn, void*))
 80a1918:	b508      	push	{r3, lr}
 80a191a:	4b03      	ldr	r3, [pc, #12]	; (80a1928 <system_ctrl_set_app_request_handler+0x10>)
 80a191c:	681b      	ldr	r3, [r3, #0]
 80a191e:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 80a1922:	9301      	str	r3, [sp, #4]
 80a1924:	bd08      	pop	{r3, pc}
 80a1926:	0000      	.short	0x0000
 80a1928:	080601a4 	.word	0x080601a4

080a192c <system_ctrl_set_result>:
DYNALIB_FN(BASE_IDX + 10, system, system_ctrl_alloc_reply_data, int(ctrl_request*, size_t, void*))
DYNALIB_FN(BASE_IDX + 11, system, system_ctrl_free_request_data, void(ctrl_request*, void*))
DYNALIB_FN(BASE_IDX + 12, system, system_ctrl_set_result, void(ctrl_request*, int, ctrl_completion_handler_fn, void*, void*))
 80a192c:	b508      	push	{r3, lr}
 80a192e:	4b03      	ldr	r3, [pc, #12]	; (80a193c <system_ctrl_set_result+0x10>)
 80a1930:	681b      	ldr	r3, [r3, #0]
 80a1932:	f8d3 309c 	ldr.w	r3, [r3, #156]	; 0x9c
 80a1936:	9301      	str	r3, [sp, #4]
 80a1938:	bd08      	pop	{r3, pc}
 80a193a:	0000      	.short	0x0000
 80a193c:	080601a4 	.word	0x080601a4

080a1940 <malloc>:
#include <assert.h>
#endif

DYNALIB_BEGIN(rt)

DYNALIB_FN(0, rt, malloc, void*(size_t))
 80a1940:	b508      	push	{r3, lr}
 80a1942:	4b02      	ldr	r3, [pc, #8]	; (80a194c <malloc+0xc>)
 80a1944:	681b      	ldr	r3, [r3, #0]
 80a1946:	681b      	ldr	r3, [r3, #0]
 80a1948:	9301      	str	r3, [sp, #4]
 80a194a:	bd08      	pop	{r3, pc}
 80a194c:	080601a0 	.word	0x080601a0

080a1950 <free>:
DYNALIB_FN(1, rt, free, void(void*))
 80a1950:	b508      	push	{r3, lr}
 80a1952:	4b02      	ldr	r3, [pc, #8]	; (80a195c <free+0xc>)
 80a1954:	681b      	ldr	r3, [r3, #0]
 80a1956:	685b      	ldr	r3, [r3, #4]
 80a1958:	9301      	str	r3, [sp, #4]
 80a195a:	bd08      	pop	{r3, pc}
 80a195c:	080601a0 	.word	0x080601a0

080a1960 <realloc>:
DYNALIB_FN(2, rt, realloc, void*(void*, size_t))
 80a1960:	b508      	push	{r3, lr}
 80a1962:	4b02      	ldr	r3, [pc, #8]	; (80a196c <realloc+0xc>)
 80a1964:	681b      	ldr	r3, [r3, #0]
 80a1966:	689b      	ldr	r3, [r3, #8]
 80a1968:	9301      	str	r3, [sp, #4]
 80a196a:	bd08      	pop	{r3, pc}
 80a196c:	080601a0 	.word	0x080601a0

080a1970 <vsnprintf>:
DYNALIB_FN(4, rt, siprintf, int(char*, const char*, ...))
DYNALIB_FN(5, rt, sscanf, int(const char*, const char*, ...))
DYNALIB_FN(6, rt, siscanf, int(const char*, const char*, ...))
DYNALIB_FN(7, rt, snprintf, int(char*, size_t, const char*, ...))
DYNALIB_FN(8, rt, sniprintf, int(char*, size_t, const char*, ...))
DYNALIB_FN(9, rt, vsnprintf, int(char*, size_t, const char*, va_list))
 80a1970:	b508      	push	{r3, lr}
 80a1972:	4b02      	ldr	r3, [pc, #8]	; (80a197c <vsnprintf+0xc>)
 80a1974:	681b      	ldr	r3, [r3, #0]
 80a1976:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80a1978:	9301      	str	r3, [sp, #4]
 80a197a:	bd08      	pop	{r3, pc}
 80a197c:	080601a0 	.word	0x080601a0

080a1980 <_ZN12_GLOBAL__N_19skipTokenEPK9jsmntok_t>:
#include <cstdarg>

namespace {

// Skips token and all its children tokens if any
const jsmntok_t* skipToken(const jsmntok_t *t) {
 80a1980:	f100 0210 	add.w	r2, r0, #16
    size_t n = 1;
 80a1984:	2301      	movs	r3, #1
    do {
        if (t->type == JSMN_OBJECT) {
 80a1986:	f812 1c10 	ldrb.w	r1, [r2, #-16]
 80a198a:	4610      	mov	r0, r2
 80a198c:	2901      	cmp	r1, #1
 80a198e:	d104      	bne.n	80a199a <_ZN12_GLOBAL__N_19skipTokenEPK9jsmntok_t+0x1a>
            n += t->size * 2; // Number of name and value tokens
 80a1990:	f852 1c04 	ldr.w	r1, [r2, #-4]
 80a1994:	eb03 0341 	add.w	r3, r3, r1, lsl #1
 80a1998:	e004      	b.n	80a19a4 <_ZN12_GLOBAL__N_19skipTokenEPK9jsmntok_t+0x24>
        } else if (t->type == JSMN_ARRAY) {
 80a199a:	2902      	cmp	r1, #2
            n += t->size; // Number of value tokens
 80a199c:	bf04      	itt	eq
 80a199e:	f852 1c04 	ldreq.w	r1, [r2, #-4]
 80a19a2:	185b      	addeq	r3, r3, r1
namespace {

// Skips token and all its children tokens if any
const jsmntok_t* skipToken(const jsmntok_t *t) {
    size_t n = 1;
    do {
 80a19a4:	3b01      	subs	r3, #1
 80a19a6:	f102 0210 	add.w	r2, r2, #16
 80a19aa:	d1ec      	bne.n	80a1986 <_ZN12_GLOBAL__N_19skipTokenEPK9jsmntok_t+0x6>
        }
        ++t;
        --n;
    } while (n);
    return t;
}
 80a19ac:	4770      	bx	lr

080a19ae <_ZN5spark10JSONWriter6printfEPKcz>:
    write("null", 4);
    state_ = NEXT;
    return *this;
}

void spark::JSONWriter::printf(const char *fmt, ...) {
 80a19ae:	b40e      	push	{r1, r2, r3}
 80a19b0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80a19b4:	b087      	sub	sp, #28
 80a19b6:	af00      	add	r7, sp, #0
 80a19b8:	f107 0434 	add.w	r4, r7, #52	; 0x34
 80a19bc:	f854 6b04 	ldr.w	r6, [r4], #4
 80a19c0:	4605      	mov	r5, r0
    char buf[16];
    va_list args;
    va_start(args, fmt);
    int n = vsnprintf(buf, sizeof(buf), fmt, args);
 80a19c2:	4623      	mov	r3, r4
 80a19c4:	4632      	mov	r2, r6
 80a19c6:	2110      	movs	r1, #16
 80a19c8:	f107 0008 	add.w	r0, r7, #8
}

void spark::JSONWriter::printf(const char *fmt, ...) {
    char buf[16];
    va_list args;
    va_start(args, fmt);
 80a19cc:	607c      	str	r4, [r7, #4]
    int n = vsnprintf(buf, sizeof(buf), fmt, args);
 80a19ce:	f7ff ffcf 	bl	80a1970 <vsnprintf>
    va_end(args);
    if ((size_t)n >= sizeof(buf)) {
 80a19d2:	280f      	cmp	r0, #15
 80a19d4:	d916      	bls.n	80a1a04 <_ZN5spark10JSONWriter6printfEPKcz+0x56>
        char buf[n + 1]; // Use larger buffer
 80a19d6:	f100 0308 	add.w	r3, r0, #8
 80a19da:	f023 0307 	bic.w	r3, r3, #7
        va_start(args, fmt);
        n = vsnprintf(buf, sizeof(buf), fmt, args);
        va_end(args);
        if (n > 0) {
            write(buf, n);
        }
 80a19de:	46e8      	mov	r8, sp
    va_list args;
    va_start(args, fmt);
    int n = vsnprintf(buf, sizeof(buf), fmt, args);
    va_end(args);
    if ((size_t)n >= sizeof(buf)) {
        char buf[n + 1]; // Use larger buffer
 80a19e0:	ebad 0d03 	sub.w	sp, sp, r3
        va_start(args, fmt);
        n = vsnprintf(buf, sizeof(buf), fmt, args);
 80a19e4:	4632      	mov	r2, r6
 80a19e6:	1c41      	adds	r1, r0, #1
 80a19e8:	4623      	mov	r3, r4
 80a19ea:	4668      	mov	r0, sp
    va_start(args, fmt);
    int n = vsnprintf(buf, sizeof(buf), fmt, args);
    va_end(args);
    if ((size_t)n >= sizeof(buf)) {
        char buf[n + 1]; // Use larger buffer
        va_start(args, fmt);
 80a19ec:	607c      	str	r4, [r7, #4]
        n = vsnprintf(buf, sizeof(buf), fmt, args);
 80a19ee:	f7ff ffbf 	bl	80a1970 <vsnprintf>
        va_end(args);
        if (n > 0) {
 80a19f2:	1e02      	subs	r2, r0, #0
 80a19f4:	dd04      	ble.n	80a1a00 <_ZN5spark10JSONWriter6printfEPKcz+0x52>
            write(buf, n);
 80a19f6:	682b      	ldr	r3, [r5, #0]
 80a19f8:	4669      	mov	r1, sp
 80a19fa:	689b      	ldr	r3, [r3, #8]
 80a19fc:	4628      	mov	r0, r5
 80a19fe:	4798      	blx	r3
 80a1a00:	46c5      	mov	sp, r8
 80a1a02:	e007      	b.n	80a1a14 <_ZN5spark10JSONWriter6printfEPKcz+0x66>
        }
    } else if (n > 0) {
 80a1a04:	b130      	cbz	r0, 80a1a14 <_ZN5spark10JSONWriter6printfEPKcz+0x66>
        write(buf, n);
 80a1a06:	682b      	ldr	r3, [r5, #0]
 80a1a08:	4602      	mov	r2, r0
 80a1a0a:	689b      	ldr	r3, [r3, #8]
 80a1a0c:	f107 0108 	add.w	r1, r7, #8
 80a1a10:	4628      	mov	r0, r5
 80a1a12:	4798      	blx	r3
    }
}
 80a1a14:	371c      	adds	r7, #28
 80a1a16:	46bd      	mov	sp, r7
 80a1a18:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
 80a1a1c:	b003      	add	sp, #12
 80a1a1e:	4770      	bx	lr

080a1a20 <_ZNSt16_Sp_counted_baseILN9__gnu_cxx12_Lock_policyE0EE10_M_releaseEv.part.3.constprop.12>:
    _Sp_counted_base<_S_single>::_M_add_ref_copy()
    { ++_M_use_count; }

  template<>
    inline void
    _Sp_counted_base<_S_single>::_M_release() noexcept
 80a1a20:	b510      	push	{r4, lr}
 80a1a22:	4604      	mov	r4, r0
    {
      if (--_M_use_count == 0)
        {
          _M_dispose();
 80a1a24:	6803      	ldr	r3, [r0, #0]
 80a1a26:	689b      	ldr	r3, [r3, #8]
 80a1a28:	4798      	blx	r3
          if (--_M_weak_count == 0)
 80a1a2a:	68a3      	ldr	r3, [r4, #8]
 80a1a2c:	3b01      	subs	r3, #1
 80a1a2e:	60a3      	str	r3, [r4, #8]
 80a1a30:	b92b      	cbnz	r3, 80a1a3e <_ZNSt16_Sp_counted_baseILN9__gnu_cxx12_Lock_policyE0EE10_M_releaseEv.part.3.constprop.12+0x1e>
            _M_destroy();
 80a1a32:	6823      	ldr	r3, [r4, #0]
 80a1a34:	4620      	mov	r0, r4
        }
    }
 80a1a36:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    {
      if (--_M_use_count == 0)
        {
          _M_dispose();
          if (--_M_weak_count == 0)
            _M_destroy();
 80a1a3a:	68db      	ldr	r3, [r3, #12]
 80a1a3c:	4718      	bx	r3
 80a1a3e:	bd10      	pop	{r4, pc}

080a1a40 <_ZN5spark10JSONWriter5writeEc>:

inline spark::JSONWriter& spark::JSONWriter::value(const String &val) {
    return value(val.c_str(), val.length());
}

inline void spark::JSONWriter::write(char c) {
 80a1a40:	b513      	push	{r0, r1, r4, lr}
    write(&c, 1);
 80a1a42:	6802      	ldr	r2, [r0, #0]

inline spark::JSONWriter& spark::JSONWriter::value(const String &val) {
    return value(val.c_str(), val.length());
}

inline void spark::JSONWriter::write(char c) {
 80a1a44:	ab02      	add	r3, sp, #8
 80a1a46:	f803 1d01 	strb.w	r1, [r3, #-1]!
    write(&c, 1);
 80a1a4a:	6894      	ldr	r4, [r2, #8]
 80a1a4c:	4619      	mov	r1, r3
 80a1a4e:	2201      	movs	r2, #1
 80a1a50:	47a0      	blx	r4
}
 80a1a52:	b002      	add	sp, #8
 80a1a54:	bd10      	pop	{r4, pc}

080a1a56 <_ZNK5spark9JSONValue4typeEv>:
        return 0.0;
    }
}

spark::JSONType spark::JSONValue::type() const {
    if (!t_) {
 80a1a56:	6883      	ldr	r3, [r0, #8]
 80a1a58:	b1fb      	cbz	r3, 80a1a9a <_ZNK5spark9JSONValue4typeEv+0x44>
        return JSON_TYPE_INVALID;
    }
    switch (t_->type) {
 80a1a5a:	781a      	ldrb	r2, [r3, #0]
 80a1a5c:	2a03      	cmp	r2, #3
 80a1a5e:	d81a      	bhi.n	80a1a96 <_ZNK5spark9JSONValue4typeEv+0x40>
 80a1a60:	e8df f002 	tbb	[pc, r2]
 80a1a64:	1d021704 	.word	0x1d021704
        return JSON_TYPE_INVALID;
    }
    case JSMN_STRING:
        return JSON_TYPE_STRING;
    case JSMN_ARRAY:
        return JSON_TYPE_ARRAY;
 80a1a68:	2005      	movs	r0, #5
 80a1a6a:	4770      	bx	lr
    if (!t_) {
        return JSON_TYPE_INVALID;
    }
    switch (t_->type) {
    case JSMN_PRIMITIVE: {
        const char c = d_->json[t_->start];
 80a1a6c:	6802      	ldr	r2, [r0, #0]
 80a1a6e:	685b      	ldr	r3, [r3, #4]
 80a1a70:	6852      	ldr	r2, [r2, #4]
 80a1a72:	5cd0      	ldrb	r0, [r2, r3]
        if (c == '-' || (c >= '0' && c <= '9')) {
 80a1a74:	282d      	cmp	r0, #45	; 0x2d
 80a1a76:	d014      	beq.n	80a1aa2 <_ZNK5spark9JSONValue4typeEv+0x4c>
 80a1a78:	f1a0 0330 	sub.w	r3, r0, #48	; 0x30
 80a1a7c:	2b09      	cmp	r3, #9
 80a1a7e:	d910      	bls.n	80a1aa2 <_ZNK5spark9JSONValue4typeEv+0x4c>
            return JSON_TYPE_NUMBER;
        } else if (c == 't' || c == 'f') { // Literal names are always in lower case
 80a1a80:	2874      	cmp	r0, #116	; 0x74
 80a1a82:	d010      	beq.n	80a1aa6 <_ZNK5spark9JSONValue4typeEv+0x50>
 80a1a84:	2866      	cmp	r0, #102	; 0x66
 80a1a86:	d00e      	beq.n	80a1aa6 <_ZNK5spark9JSONValue4typeEv+0x50>
    }
}

spark::JSONType spark::JSONValue::type() const {
    if (!t_) {
        return JSON_TYPE_INVALID;
 80a1a88:	f1a0 036e 	sub.w	r3, r0, #110	; 0x6e
 80a1a8c:	4258      	negs	r0, r3
 80a1a8e:	4158      	adcs	r0, r3
 80a1a90:	4770      	bx	lr
    case JSMN_STRING:
        return JSON_TYPE_STRING;
    case JSMN_ARRAY:
        return JSON_TYPE_ARRAY;
    case JSMN_OBJECT:
        return JSON_TYPE_OBJECT;
 80a1a92:	2006      	movs	r0, #6
 80a1a94:	4770      	bx	lr
    default:
        return JSON_TYPE_INVALID;
 80a1a96:	2000      	movs	r0, #0
 80a1a98:	4770      	bx	lr
    }
}

spark::JSONType spark::JSONValue::type() const {
    if (!t_) {
        return JSON_TYPE_INVALID;
 80a1a9a:	4618      	mov	r0, r3
 80a1a9c:	4770      	bx	lr
            return JSON_TYPE_NULL;
        }
        return JSON_TYPE_INVALID;
    }
    case JSMN_STRING:
        return JSON_TYPE_STRING;
 80a1a9e:	2004      	movs	r0, #4
 80a1aa0:	4770      	bx	lr
    }
    switch (t_->type) {
    case JSMN_PRIMITIVE: {
        const char c = d_->json[t_->start];
        if (c == '-' || (c >= '0' && c <= '9')) {
            return JSON_TYPE_NUMBER;
 80a1aa2:	2003      	movs	r0, #3
 80a1aa4:	4770      	bx	lr
        } else if (c == 't' || c == 'f') { // Literal names are always in lower case
            return JSON_TYPE_BOOL;
 80a1aa6:	2002      	movs	r0, #2
    case JSMN_OBJECT:
        return JSON_TYPE_OBJECT;
    default:
        return JSON_TYPE_INVALID;
    }
}
 80a1aa8:	4770      	bx	lr

080a1aaa <_ZNK5spark9JSONValue5toIntEv>:
    default:
        return false;
    }
}

int spark::JSONValue::toInt() const {
 80a1aaa:	b510      	push	{r4, lr}
 80a1aac:	4604      	mov	r4, r0
    switch (type()) {
 80a1aae:	f7ff ffd2 	bl	80a1a56 <_ZNK5spark9JSONValue4typeEv>
 80a1ab2:	2802      	cmp	r0, #2
 80a1ab4:	d00d      	beq.n	80a1ad2 <_ZNK5spark9JSONValue5toIntEv+0x28>
 80a1ab6:	d316      	bcc.n	80a1ae6 <_ZNK5spark9JSONValue5toIntEv+0x3c>
 80a1ab8:	2804      	cmp	r0, #4
 80a1aba:	d814      	bhi.n	80a1ae6 <_ZNK5spark9JSONValue5toIntEv+0x3c>
    }
    case JSON_TYPE_NUMBER:
    case JSON_TYPE_STRING: {
        // toInt() may produce incorrect results for floating point numbers, since we want to keep
        // compile-time dependency on strtod() optional
        const char* const s = d_->json + t_->start;
 80a1abc:	6822      	ldr	r2, [r4, #0]
 80a1abe:	68a3      	ldr	r3, [r4, #8]
        return strtol(s, nullptr, 10);
 80a1ac0:	6850      	ldr	r0, [r2, #4]
 80a1ac2:	685b      	ldr	r3, [r3, #4]
 80a1ac4:	220a      	movs	r2, #10
 80a1ac6:	2100      	movs	r1, #0
 80a1ac8:	4418      	add	r0, r3
    }
    default:
        return 0;
    }
}
 80a1aca:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    case JSON_TYPE_NUMBER:
    case JSON_TYPE_STRING: {
        // toInt() may produce incorrect results for floating point numbers, since we want to keep
        // compile-time dependency on strtod() optional
        const char* const s = d_->json + t_->start;
        return strtol(s, nullptr, 10);
 80a1ace:	f002 ba23 	b.w	80a3f18 <strtol>
}

int spark::JSONValue::toInt() const {
    switch (type()) {
    case JSON_TYPE_BOOL: {
        const char* const s = d_->json + t_->start;
 80a1ad2:	6822      	ldr	r2, [r4, #0]
 80a1ad4:	68a3      	ldr	r3, [r4, #8]
        return *s == 't';
 80a1ad6:	6852      	ldr	r2, [r2, #4]
 80a1ad8:	685b      	ldr	r3, [r3, #4]
 80a1ada:	5cd0      	ldrb	r0, [r2, r3]
 80a1adc:	f1a0 0374 	sub.w	r3, r0, #116	; 0x74
 80a1ae0:	4258      	negs	r0, r3
 80a1ae2:	4158      	adcs	r0, r3
 80a1ae4:	bd10      	pop	{r4, pc}
        // compile-time dependency on strtod() optional
        const char* const s = d_->json + t_->start;
        return strtol(s, nullptr, 10);
    }
    default:
        return 0;
 80a1ae6:	2000      	movs	r0, #0
    }
}
 80a1ae8:	bd10      	pop	{r4, pc}

080a1aea <_ZN5spark18JSONObjectIterator4nextEv>:
        n_ = t->size; // Number of properties
        d_ = d;
    }
}

bool spark::JSONObjectIterator::next() {
 80a1aea:	b510      	push	{r4, lr}
    if (!n_) {
 80a1aec:	6943      	ldr	r3, [r0, #20]
        n_ = t->size; // Number of properties
        d_ = d;
    }
}

bool spark::JSONObjectIterator::next() {
 80a1aee:	4604      	mov	r4, r0
    if (!n_) {
 80a1af0:	b15b      	cbz	r3, 80a1b0a <_ZN5spark18JSONObjectIterator4nextEv+0x20>
        return false;
    }
    k_ = t_; // Name
 80a1af2:	6880      	ldr	r0, [r0, #8]
    ++t_;
    v_ = t_; // Value
    --n_;
 80a1af4:	3b01      	subs	r3, #1

bool spark::JSONObjectIterator::next() {
    if (!n_) {
        return false;
    }
    k_ = t_; // Name
 80a1af6:	60e0      	str	r0, [r4, #12]
    ++t_;
 80a1af8:	3010      	adds	r0, #16
 80a1afa:	60a0      	str	r0, [r4, #8]
    v_ = t_; // Value
 80a1afc:	6120      	str	r0, [r4, #16]
    --n_;
 80a1afe:	6163      	str	r3, [r4, #20]
    if (n_) {
 80a1b00:	b12b      	cbz	r3, 80a1b0e <_ZN5spark18JSONObjectIterator4nextEv+0x24>
        t_ = skipToken(t_);
 80a1b02:	f7ff ff3d 	bl	80a1980 <_ZN12_GLOBAL__N_19skipTokenEPK9jsmntok_t>
 80a1b06:	60a0      	str	r0, [r4, #8]
 80a1b08:	e001      	b.n	80a1b0e <_ZN5spark18JSONObjectIterator4nextEv+0x24>
    }
}

bool spark::JSONObjectIterator::next() {
    if (!n_) {
        return false;
 80a1b0a:	4618      	mov	r0, r3
 80a1b0c:	bd10      	pop	{r4, pc}
    v_ = t_; // Value
    --n_;
    if (n_) {
        t_ = skipToken(t_);
    }
    return true;
 80a1b0e:	2001      	movs	r0, #1
}
 80a1b10:	bd10      	pop	{r4, pc}

080a1b12 <_ZN5spark10JSONWriter9endObjectEv>:
    write('{');
    state_ = BEGIN;
    return *this;
}

spark::JSONWriter& spark::JSONWriter::endObject() {
 80a1b12:	b510      	push	{r4, lr}
 80a1b14:	4604      	mov	r4, r0
    write('}');
 80a1b16:	217d      	movs	r1, #125	; 0x7d
 80a1b18:	f7ff ff92 	bl	80a1a40 <_ZN5spark10JSONWriter5writeEc>
    state_ = NEXT;
 80a1b1c:	2301      	movs	r3, #1
 80a1b1e:	7123      	strb	r3, [r4, #4]
    return *this;
}
 80a1b20:	4620      	mov	r0, r4
 80a1b22:	bd10      	pop	{r4, pc}

080a1b24 <_ZN5spark10JSONWriter14writeSeparatorEv>:
    } else if (n > 0) {
        write(buf, n);
    }
}

void spark::JSONWriter::writeSeparator() {
 80a1b24:	b508      	push	{r3, lr}
    switch (state_) {
 80a1b26:	7903      	ldrb	r3, [r0, #4]
 80a1b28:	2b01      	cmp	r3, #1
 80a1b2a:	d002      	beq.n	80a1b32 <_ZN5spark10JSONWriter14writeSeparatorEv+0xe>
 80a1b2c:	2b02      	cmp	r3, #2
 80a1b2e:	d002      	beq.n	80a1b36 <_ZN5spark10JSONWriter14writeSeparatorEv+0x12>
 80a1b30:	bd08      	pop	{r3, pc}
    case NEXT:
        write(',');
 80a1b32:	212c      	movs	r1, #44	; 0x2c
 80a1b34:	e000      	b.n	80a1b38 <_ZN5spark10JSONWriter14writeSeparatorEv+0x14>
        break;
    case VALUE:
        write(':');
 80a1b36:	213a      	movs	r1, #58	; 0x3a
 80a1b38:	f7ff ff82 	bl	80a1a40 <_ZN5spark10JSONWriter5writeEc>
 80a1b3c:	bd08      	pop	{r3, pc}

080a1b3e <_ZN5spark10JSONWriter11beginObjectEv>:
    write(']');
    state_ = NEXT;
    return *this;
}

spark::JSONWriter& spark::JSONWriter::beginObject() {
 80a1b3e:	b510      	push	{r4, lr}
 80a1b40:	4604      	mov	r4, r0
    writeSeparator();
 80a1b42:	f7ff ffef 	bl	80a1b24 <_ZN5spark10JSONWriter14writeSeparatorEv>
    write('{');
 80a1b46:	4620      	mov	r0, r4
 80a1b48:	217b      	movs	r1, #123	; 0x7b
 80a1b4a:	f7ff ff79 	bl	80a1a40 <_ZN5spark10JSONWriter5writeEc>
    state_ = BEGIN;
 80a1b4e:	2300      	movs	r3, #0
 80a1b50:	7123      	strb	r3, [r4, #4]
    return *this;
}
 80a1b52:	4620      	mov	r0, r4
 80a1b54:	bd10      	pop	{r4, pc}
	...

080a1b58 <_ZN5spark10JSONWriter5valueEi>:
    }
    state_ = NEXT;
    return *this;
}

spark::JSONWriter& spark::JSONWriter::value(int val) {
 80a1b58:	b538      	push	{r3, r4, r5, lr}
 80a1b5a:	4604      	mov	r4, r0
 80a1b5c:	460d      	mov	r5, r1
    writeSeparator();
 80a1b5e:	f7ff ffe1 	bl	80a1b24 <_ZN5spark10JSONWriter14writeSeparatorEv>
    printf("%d", val);
 80a1b62:	6823      	ldr	r3, [r4, #0]
 80a1b64:	4620      	mov	r0, r4
 80a1b66:	68db      	ldr	r3, [r3, #12]
 80a1b68:	462a      	mov	r2, r5
 80a1b6a:	4903      	ldr	r1, [pc, #12]	; (80a1b78 <_ZN5spark10JSONWriter5valueEi+0x20>)
 80a1b6c:	4798      	blx	r3
    state_ = NEXT;
 80a1b6e:	2301      	movs	r3, #1
 80a1b70:	7123      	strb	r3, [r4, #4]
    return *this;
}
 80a1b72:	4620      	mov	r0, r4
 80a1b74:	bd38      	pop	{r3, r4, r5, pc}
 80a1b76:	bf00      	nop
 80a1b78:	080a4a63 	.word	0x080a4a63

080a1b7c <_ZN5spark10JSONWriter5valueEj>:

spark::JSONWriter& spark::JSONWriter::value(unsigned val) {
 80a1b7c:	b538      	push	{r3, r4, r5, lr}
 80a1b7e:	4604      	mov	r4, r0
 80a1b80:	460d      	mov	r5, r1
    writeSeparator();
 80a1b82:	f7ff ffcf 	bl	80a1b24 <_ZN5spark10JSONWriter14writeSeparatorEv>
    printf("%u", val);
 80a1b86:	6823      	ldr	r3, [r4, #0]
 80a1b88:	4620      	mov	r0, r4
 80a1b8a:	68db      	ldr	r3, [r3, #12]
 80a1b8c:	462a      	mov	r2, r5
 80a1b8e:	4903      	ldr	r1, [pc, #12]	; (80a1b9c <_ZN5spark10JSONWriter5valueEj+0x20>)
 80a1b90:	4798      	blx	r3
    state_ = NEXT;
 80a1b92:	2301      	movs	r3, #1
 80a1b94:	7123      	strb	r3, [r4, #4]
    return *this;
}
 80a1b96:	4620      	mov	r0, r4
 80a1b98:	bd38      	pop	{r3, r4, r5, pc}
 80a1b9a:	bf00      	nop
 80a1b9c:	080a4a66 	.word	0x080a4a66

080a1ba0 <_ZN5spark10JSONWriter12writeEscapedEPKcj>:
    default:
        break;
    }
}

void spark::JSONWriter::writeEscaped(const char *str, size_t size) {
 80a1ba0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80a1ba2:	460d      	mov	r5, r1
 80a1ba4:	4617      	mov	r7, r2
    write('"');
 80a1ba6:	2122      	movs	r1, #34	; 0x22
    default:
        break;
    }
}

void spark::JSONWriter::writeEscaped(const char *str, size_t size) {
 80a1ba8:	4604      	mov	r4, r0
    write('"');
 80a1baa:	f7ff ff49 	bl	80a1a40 <_ZN5spark10JSONWriter5writeEc>
 80a1bae:	462a      	mov	r2, r5
    const char* const end = str + size;
 80a1bb0:	4629      	mov	r1, r5
 80a1bb2:	442f      	add	r7, r5
    const char *s = str;
    while (s != end) {
 80a1bb4:	42ba      	cmp	r2, r7
 80a1bb6:	d038      	beq.n	80a1c2a <_ZN5spark10JSONWriter12writeEscapedEPKcj+0x8a>
        const char c = *s;
 80a1bb8:	4616      	mov	r6, r2
 80a1bba:	f816 5b01 	ldrb.w	r5, [r6], #1
        if (c == '"' || c == '\\' || (c >= 0 && c <= 0x1f)) {
 80a1bbe:	2d22      	cmp	r5, #34	; 0x22
 80a1bc0:	d003      	beq.n	80a1bca <_ZN5spark10JSONWriter12writeEscapedEPKcj+0x2a>
 80a1bc2:	2d5c      	cmp	r5, #92	; 0x5c
 80a1bc4:	d001      	beq.n	80a1bca <_ZN5spark10JSONWriter12writeEscapedEPKcj+0x2a>
 80a1bc6:	2d1f      	cmp	r5, #31
 80a1bc8:	d82d      	bhi.n	80a1c26 <_ZN5spark10JSONWriter12writeEscapedEPKcj+0x86>
            write(str, s - str); // Write preceeding characters
 80a1bca:	6823      	ldr	r3, [r4, #0]
 80a1bcc:	1a52      	subs	r2, r2, r1
 80a1bce:	689b      	ldr	r3, [r3, #8]
 80a1bd0:	4620      	mov	r0, r4
 80a1bd2:	4798      	blx	r3
            write('\\');
 80a1bd4:	215c      	movs	r1, #92	; 0x5c
 80a1bd6:	4620      	mov	r0, r4
 80a1bd8:	f7ff ff32 	bl	80a1a40 <_ZN5spark10JSONWriter5writeEc>
            switch (c) {
 80a1bdc:	2d0c      	cmp	r5, #12
 80a1bde:	d019      	beq.n	80a1c14 <_ZN5spark10JSONWriter12writeEscapedEPKcj+0x74>
 80a1be0:	d807      	bhi.n	80a1bf2 <_ZN5spark10JSONWriter12writeEscapedEPKcj+0x52>
 80a1be2:	2d09      	cmp	r5, #9
 80a1be4:	d00f      	beq.n	80a1c06 <_ZN5spark10JSONWriter12writeEscapedEPKcj+0x66>
 80a1be6:	2d0a      	cmp	r5, #10
 80a1be8:	d012      	beq.n	80a1c10 <_ZN5spark10JSONWriter12writeEscapedEPKcj+0x70>
 80a1bea:	2d08      	cmp	r5, #8
 80a1bec:	d114      	bne.n	80a1c18 <_ZN5spark10JSONWriter12writeEscapedEPKcj+0x78>
            case '"':
            case '\\':
                write(c);
                break;
            case 0x08: // Backspace
                write('b');
 80a1bee:	2162      	movs	r1, #98	; 0x62
 80a1bf0:	e00a      	b.n	80a1c08 <_ZN5spark10JSONWriter12writeEscapedEPKcj+0x68>
    while (s != end) {
        const char c = *s;
        if (c == '"' || c == '\\' || (c >= 0 && c <= 0x1f)) {
            write(str, s - str); // Write preceeding characters
            write('\\');
            switch (c) {
 80a1bf2:	2d22      	cmp	r5, #34	; 0x22
 80a1bf4:	d005      	beq.n	80a1c02 <_ZN5spark10JSONWriter12writeEscapedEPKcj+0x62>
 80a1bf6:	2d5c      	cmp	r5, #92	; 0x5c
 80a1bf8:	d003      	beq.n	80a1c02 <_ZN5spark10JSONWriter12writeEscapedEPKcj+0x62>
 80a1bfa:	2d0d      	cmp	r5, #13
 80a1bfc:	d10c      	bne.n	80a1c18 <_ZN5spark10JSONWriter12writeEscapedEPKcj+0x78>
                break;
            case 0x0c: // Form feed
                write('f');
                break;
            case 0x0d: // Carriage return
                write('r');
 80a1bfe:	2172      	movs	r1, #114	; 0x72
 80a1c00:	e002      	b.n	80a1c08 <_ZN5spark10JSONWriter12writeEscapedEPKcj+0x68>
            write(str, s - str); // Write preceeding characters
            write('\\');
            switch (c) {
            case '"':
            case '\\':
                write(c);
 80a1c02:	4629      	mov	r1, r5
 80a1c04:	e000      	b.n	80a1c08 <_ZN5spark10JSONWriter12writeEscapedEPKcj+0x68>
                break;
            case 0x08: // Backspace
                write('b');
                break;
            case 0x09: // Tab
                write('t');
 80a1c06:	2174      	movs	r1, #116	; 0x74
            case '"':
            case '\\':
                write(c);
                break;
            case 0x08: // Backspace
                write('b');
 80a1c08:	4620      	mov	r0, r4
 80a1c0a:	f7ff ff19 	bl	80a1a40 <_ZN5spark10JSONWriter5writeEc>
                break;
 80a1c0e:	e009      	b.n	80a1c24 <_ZN5spark10JSONWriter12writeEscapedEPKcj+0x84>
            case 0x09: // Tab
                write('t');
                break;
            case 0x0a: // Line feed
                write('n');
 80a1c10:	216e      	movs	r1, #110	; 0x6e
 80a1c12:	e7f9      	b.n	80a1c08 <_ZN5spark10JSONWriter12writeEscapedEPKcj+0x68>
                break;
            case 0x0c: // Form feed
                write('f');
 80a1c14:	2166      	movs	r1, #102	; 0x66
 80a1c16:	e7f7      	b.n	80a1c08 <_ZN5spark10JSONWriter12writeEscapedEPKcj+0x68>
            case 0x0d: // Carriage return
                write('r');
                break;
            default:
                // All other control characters are written in hex, e.g. "\u001f"
                printf("u%04x", (unsigned)c);
 80a1c18:	6823      	ldr	r3, [r4, #0]
 80a1c1a:	462a      	mov	r2, r5
 80a1c1c:	68db      	ldr	r3, [r3, #12]
 80a1c1e:	4909      	ldr	r1, [pc, #36]	; (80a1c44 <_ZN5spark10JSONWriter12writeEscapedEPKcj+0xa4>)
 80a1c20:	4620      	mov	r0, r4
 80a1c22:	4798      	blx	r3
                break;
            }
            str = s + 1;
 80a1c24:	4631      	mov	r1, r6

void spark::JSONWriter::writeEscaped(const char *str, size_t size) {
    write('"');
    const char* const end = str + size;
    const char *s = str;
    while (s != end) {
 80a1c26:	4632      	mov	r2, r6
 80a1c28:	e7c4      	b.n	80a1bb4 <_ZN5spark10JSONWriter12writeEscapedEPKcj+0x14>
            }
            str = s + 1;
        }
        ++s;
    }
    if (s != str) {
 80a1c2a:	4291      	cmp	r1, r2
 80a1c2c:	d004      	beq.n	80a1c38 <_ZN5spark10JSONWriter12writeEscapedEPKcj+0x98>
        write(str, s - str); // Write remaining characters
 80a1c2e:	6823      	ldr	r3, [r4, #0]
 80a1c30:	1a52      	subs	r2, r2, r1
 80a1c32:	689d      	ldr	r5, [r3, #8]
 80a1c34:	4620      	mov	r0, r4
 80a1c36:	47a8      	blx	r5
    }
    write('"');
 80a1c38:	2122      	movs	r1, #34	; 0x22
 80a1c3a:	4620      	mov	r0, r4
 80a1c3c:	f7ff ff00 	bl	80a1a40 <_ZN5spark10JSONWriter5writeEc>
 80a1c40:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 80a1c42:	bf00      	nop
 80a1c44:	080a4a77 	.word	0x080a4a77

080a1c48 <_ZN5spark10JSONWriter4nameEPKcj>:
    write('}');
    state_ = NEXT;
    return *this;
}

spark::JSONWriter& spark::JSONWriter::name(const char *name, size_t size) {
 80a1c48:	b570      	push	{r4, r5, r6, lr}
 80a1c4a:	4604      	mov	r4, r0
 80a1c4c:	460d      	mov	r5, r1
 80a1c4e:	4616      	mov	r6, r2
    writeSeparator();
 80a1c50:	f7ff ff68 	bl	80a1b24 <_ZN5spark10JSONWriter14writeSeparatorEv>
    writeEscaped(name, size);
 80a1c54:	4620      	mov	r0, r4
 80a1c56:	4632      	mov	r2, r6
 80a1c58:	4629      	mov	r1, r5
 80a1c5a:	f7ff ffa1 	bl	80a1ba0 <_ZN5spark10JSONWriter12writeEscapedEPKcj>
    state_ = VALUE;
 80a1c5e:	2302      	movs	r3, #2
 80a1c60:	7123      	strb	r3, [r4, #4]
    return *this;
}
 80a1c62:	4620      	mov	r0, r4
 80a1c64:	bd70      	pop	{r4, r5, r6, pc}

080a1c66 <_ZN5spark10JSONWriter5valueEPKcj>:
    printf("%g", val);
    state_ = NEXT;
    return *this;
}

spark::JSONWriter& spark::JSONWriter::value(const char *val, size_t size) {
 80a1c66:	b570      	push	{r4, r5, r6, lr}
 80a1c68:	4604      	mov	r4, r0
 80a1c6a:	460d      	mov	r5, r1
 80a1c6c:	4616      	mov	r6, r2
    writeSeparator();
 80a1c6e:	f7ff ff59 	bl	80a1b24 <_ZN5spark10JSONWriter14writeSeparatorEv>
    writeEscaped(val, size);
 80a1c72:	4620      	mov	r0, r4
 80a1c74:	4632      	mov	r2, r6
 80a1c76:	4629      	mov	r1, r5
 80a1c78:	f7ff ff92 	bl	80a1ba0 <_ZN5spark10JSONWriter12writeEscapedEPKcj>
    state_ = NEXT;
 80a1c7c:	2301      	movs	r3, #1
 80a1c7e:	7123      	strb	r3, [r4, #4]
    return *this;
}
 80a1c80:	4620      	mov	r0, r4
 80a1c82:	bd70      	pop	{r4, r5, r6, pc}

080a1c84 <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EED1Ev>:
      explicit __shared_count(const __weak_count<_Lp>& __r);

      // Does not throw if __r._M_get_use_count() == 0, caller must check.
      explicit __shared_count(const __weak_count<_Lp>& __r, std::nothrow_t);

      ~__shared_count() noexcept
 80a1c84:	b510      	push	{r4, lr}
 80a1c86:	4604      	mov	r4, r0
      {
	if (_M_pi != nullptr)
 80a1c88:	6800      	ldr	r0, [r0, #0]
 80a1c8a:	b128      	cbz	r0, 80a1c98 <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EED1Ev+0x14>

  template<>
    inline void
    _Sp_counted_base<_S_single>::_M_release() noexcept
    {
      if (--_M_use_count == 0)
 80a1c8c:	6843      	ldr	r3, [r0, #4]
 80a1c8e:	3b01      	subs	r3, #1
 80a1c90:	6043      	str	r3, [r0, #4]
 80a1c92:	b90b      	cbnz	r3, 80a1c98 <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EED1Ev+0x14>
 80a1c94:	f7ff fec4 	bl	80a1a20 <_ZNSt16_Sp_counted_baseILN9__gnu_cxx12_Lock_policyE0EE10_M_releaseEv.part.3.constprop.12>

      ~__shared_count() noexcept
      {
	if (_M_pi != nullptr)
	  _M_pi->_M_release();
      }
 80a1c98:	4620      	mov	r0, r4
 80a1c9a:	bd10      	pop	{r4, pc}

080a1c9c <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EEaSERKS2_>:
	if (_M_pi != 0)
	  _M_pi->_M_add_ref_copy();
      }

      __shared_count&
      operator=(const __shared_count& __r) noexcept
 80a1c9c:	b538      	push	{r3, r4, r5, lr}
      {
	_Sp_counted_base<_Lp>* __tmp = __r._M_pi;
 80a1c9e:	680c      	ldr	r4, [r1, #0]
	if (__tmp != _M_pi)
 80a1ca0:	6803      	ldr	r3, [r0, #0]
	if (_M_pi != 0)
	  _M_pi->_M_add_ref_copy();
      }

      __shared_count&
      operator=(const __shared_count& __r) noexcept
 80a1ca2:	4605      	mov	r5, r0
      {
	_Sp_counted_base<_Lp>* __tmp = __r._M_pi;
	if (__tmp != _M_pi)
 80a1ca4:	429c      	cmp	r4, r3
 80a1ca6:	d00c      	beq.n	80a1cc2 <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EEaSERKS2_+0x26>
	  {
	    if (__tmp != 0)
 80a1ca8:	b114      	cbz	r4, 80a1cb0 <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EEaSERKS2_+0x14>
    }

  template<>
    inline void
    _Sp_counted_base<_S_single>::_M_add_ref_copy()
    { ++_M_use_count; }
 80a1caa:	6863      	ldr	r3, [r4, #4]
 80a1cac:	3301      	adds	r3, #1
 80a1cae:	6063      	str	r3, [r4, #4]
	_Sp_counted_base<_Lp>* __tmp = __r._M_pi;
	if (__tmp != _M_pi)
	  {
	    if (__tmp != 0)
	      __tmp->_M_add_ref_copy();
	    if (_M_pi != 0)
 80a1cb0:	6828      	ldr	r0, [r5, #0]
 80a1cb2:	b128      	cbz	r0, 80a1cc0 <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EEaSERKS2_+0x24>

  template<>
    inline void
    _Sp_counted_base<_S_single>::_M_release() noexcept
    {
      if (--_M_use_count == 0)
 80a1cb4:	6843      	ldr	r3, [r0, #4]
 80a1cb6:	3b01      	subs	r3, #1
 80a1cb8:	6043      	str	r3, [r0, #4]
 80a1cba:	b90b      	cbnz	r3, 80a1cc0 <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EEaSERKS2_+0x24>
 80a1cbc:	f7ff feb0 	bl	80a1a20 <_ZNSt16_Sp_counted_baseILN9__gnu_cxx12_Lock_policyE0EE10_M_releaseEv.part.3.constprop.12>
	  {
	    if (__tmp != 0)
	      __tmp->_M_add_ref_copy();
	    if (_M_pi != 0)
	      _M_pi->_M_release();
	    _M_pi = __tmp;
 80a1cc0:	602c      	str	r4, [r5, #0]
	  }
	return *this;
      }
 80a1cc2:	4628      	mov	r0, r5
 80a1cc4:	bd38      	pop	{r3, r4, r5, pc}
	...

080a1cc8 <_ZN5spark10JSONStringC1EPK9jsmntok_tSt10shared_ptrINS_6detail8JSONDataEE>:
    t->end = str - json; // Update string length
    return true;
}

// spark::JSONString
spark::JSONString::JSONString(const jsmntok_t *t, detail::JSONDataPtr d) :
 80a1cc8:	b510      	push	{r4, lr}
 80a1cca:	4604      	mov	r4, r0

    public:
      typedef _Tp   element_type;

      constexpr __shared_ptr() noexcept
      : _M_ptr(0), _M_refcount()
 80a1ccc:	2300      	movs	r3, #0
 80a1cce:	6003      	str	r3, [r0, #0]

  template<_Lock_policy _Lp>
    class __shared_count
    {
    public:
      constexpr __shared_count() noexcept : _M_pi(0)
 80a1cd0:	6043      	str	r3, [r0, #4]
}

// spark::JSONString
inline spark::JSONString::JSONString() :
        s_(""),
        n_(0) {
 80a1cd2:	4810      	ldr	r0, [pc, #64]	; (80a1d14 <_ZN5spark10JSONStringC1EPK9jsmntok_tSt10shared_ptrINS_6detail8JSONDataEE+0x4c>)
 80a1cd4:	60e3      	str	r3, [r4, #12]
 80a1cd6:	60a0      	str	r0, [r4, #8]
        JSONString() {
    if (t && (t->type == JSMN_STRING || t->type == JSMN_PRIMITIVE)) {
 80a1cd8:	b1d1      	cbz	r1, 80a1d10 <_ZN5spark10JSONStringC1EPK9jsmntok_tSt10shared_ptrINS_6detail8JSONDataEE+0x48>
 80a1cda:	780b      	ldrb	r3, [r1, #0]
 80a1cdc:	2b03      	cmp	r3, #3
 80a1cde:	d006      	beq.n	80a1cee <_ZN5spark10JSONStringC1EPK9jsmntok_tSt10shared_ptrINS_6detail8JSONDataEE+0x26>
 80a1ce0:	b9b3      	cbnz	r3, 80a1d10 <_ZN5spark10JSONStringC1EPK9jsmntok_tSt10shared_ptrINS_6detail8JSONDataEE+0x48>
        if (t->type != JSMN_PRIMITIVE || d->json[t->start] != 'n') { // Nulls are treated as empty strings
 80a1ce2:	6813      	ldr	r3, [r2, #0]
 80a1ce4:	6858      	ldr	r0, [r3, #4]
 80a1ce6:	684b      	ldr	r3, [r1, #4]
 80a1ce8:	5cc3      	ldrb	r3, [r0, r3]
 80a1cea:	2b6e      	cmp	r3, #110	; 0x6e
 80a1cec:	d008      	beq.n	80a1d00 <_ZN5spark10JSONStringC1EPK9jsmntok_tSt10shared_ptrINS_6detail8JSONDataEE+0x38>
            s_ = d->json + t->start;
 80a1cee:	6813      	ldr	r3, [r2, #0]
 80a1cf0:	6858      	ldr	r0, [r3, #4]
 80a1cf2:	684b      	ldr	r3, [r1, #4]
 80a1cf4:	4403      	add	r3, r0
 80a1cf6:	60a3      	str	r3, [r4, #8]
            n_ = t->end - t->start;
 80a1cf8:	688b      	ldr	r3, [r1, #8]
 80a1cfa:	6849      	ldr	r1, [r1, #4]
 80a1cfc:	1a5b      	subs	r3, r3, r1
 80a1cfe:	60e3      	str	r3, [r4, #12]
    __enable_shared_from_this_helper(const __shared_count<_Lp>&, ...) noexcept
    { }


  template<typename _Tp, _Lock_policy _Lp>
    class __shared_ptr
 80a1d00:	4611      	mov	r1, r2
 80a1d02:	4620      	mov	r0, r4
 80a1d04:	f851 3b04 	ldr.w	r3, [r1], #4
 80a1d08:	f840 3b04 	str.w	r3, [r0], #4
 80a1d0c:	f7ff ffc6 	bl	80a1c9c <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EEaSERKS2_>
        }
        d_ = d;
    }
}
 80a1d10:	4620      	mov	r0, r4
 80a1d12:	bd10      	pop	{r4, pc}
 80a1d14:	080a4c57 	.word	0x080a4c57

080a1d18 <_ZN5spark18JSONObjectIteratorC1EPK9jsmntok_tSt10shared_ptrINS_6detail8JSONDataEE>:

    public:
      typedef _Tp   element_type;

      constexpr __shared_ptr() noexcept
      : _M_ptr(0), _M_refcount()
 80a1d18:	2300      	movs	r3, #0
bool spark::JSONString::operator==(const JSONString &str) const {
    return n_ == str.n_ && strncmp(s_, str.s_, n_) == 0;
}

// spark::JSONObjectIterator
spark::JSONObjectIterator::JSONObjectIterator(const jsmntok_t *t, detail::JSONDataPtr d) :
 80a1d1a:	b510      	push	{r4, lr}
 80a1d1c:	4604      	mov	r4, r0
 80a1d1e:	6003      	str	r3, [r0, #0]

  template<_Lock_policy _Lp>
    class __shared_count
    {
    public:
      constexpr __shared_count() noexcept : _M_pi(0)
 80a1d20:	6043      	str	r3, [r0, #4]
// spark::JSONObjectIterator
inline spark::JSONObjectIterator::JSONObjectIterator() :
        t_(nullptr),
        k_(nullptr),
        v_(nullptr),
        n_(0) {
 80a1d22:	6083      	str	r3, [r0, #8]
 80a1d24:	60c3      	str	r3, [r0, #12]
 80a1d26:	6103      	str	r3, [r0, #16]
 80a1d28:	6143      	str	r3, [r0, #20]
        JSONObjectIterator() {
    if (t && t->type == JSMN_OBJECT) {
 80a1d2a:	b171      	cbz	r1, 80a1d4a <_ZN5spark18JSONObjectIteratorC1EPK9jsmntok_tSt10shared_ptrINS_6detail8JSONDataEE+0x32>
 80a1d2c:	780b      	ldrb	r3, [r1, #0]
 80a1d2e:	2b01      	cmp	r3, #1
 80a1d30:	d10b      	bne.n	80a1d4a <_ZN5spark18JSONObjectIteratorC1EPK9jsmntok_tSt10shared_ptrINS_6detail8JSONDataEE+0x32>
        t_ = t + 1; // First property's name
 80a1d32:	f101 0310 	add.w	r3, r1, #16
 80a1d36:	6083      	str	r3, [r0, #8]
        n_ = t->size; // Number of properties
 80a1d38:	68cb      	ldr	r3, [r1, #12]
    __enable_shared_from_this_helper(const __shared_count<_Lp>&, ...) noexcept
    { }


  template<typename _Tp, _Lock_policy _Lp>
    class __shared_ptr
 80a1d3a:	4611      	mov	r1, r2
 80a1d3c:	6143      	str	r3, [r0, #20]
 80a1d3e:	f851 3b04 	ldr.w	r3, [r1], #4
 80a1d42:	f840 3b04 	str.w	r3, [r0], #4
 80a1d46:	f7ff ffa9 	bl	80a1c9c <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EEaSERKS2_>
        d_ = d;
    }
}
 80a1d4a:	4620      	mov	r0, r4
 80a1d4c:	bd10      	pop	{r4, pc}

080a1d4e <_ZN5spark9JSONValueC1EPK9jsmntok_tSt10shared_ptrINS_6detail8JSONDataEE>:

    public:
      typedef _Tp   element_type;

      constexpr __shared_ptr() noexcept
      : _M_ptr(0), _M_refcount()
 80a1d4e:	2300      	movs	r3, #0
        }
    }
};

// spark::JSONValue
spark::JSONValue::JSONValue(const jsmntok_t *t, detail::JSONDataPtr d) :
 80a1d50:	b510      	push	{r4, lr}
 80a1d52:	4604      	mov	r4, r0
 80a1d54:	6003      	str	r3, [r0, #0]

  template<_Lock_policy _Lp>
    class __shared_count
    {
    public:
      constexpr __shared_count() noexcept : _M_pi(0)
 80a1d56:	6043      	str	r3, [r0, #4]
        JSONValue() {
    if (t) {
        t_ = t;
 80a1d58:	6081      	str	r1, [r0, #8]
};

// spark::JSONValue
spark::JSONValue::JSONValue(const jsmntok_t *t, detail::JSONDataPtr d) :
        JSONValue() {
    if (t) {
 80a1d5a:	b131      	cbz	r1, 80a1d6a <_ZN5spark9JSONValueC1EPK9jsmntok_tSt10shared_ptrINS_6detail8JSONDataEE+0x1c>
    __enable_shared_from_this_helper(const __shared_count<_Lp>&, ...) noexcept
    { }


  template<typename _Tp, _Lock_policy _Lp>
    class __shared_ptr
 80a1d5c:	4611      	mov	r1, r2
 80a1d5e:	f851 3b04 	ldr.w	r3, [r1], #4
 80a1d62:	f840 3b04 	str.w	r3, [r0], #4
 80a1d66:	f7ff ff99 	bl	80a1c9c <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EEaSERKS2_>
        t_ = t;
        d_ = d;
    }
}
 80a1d6a:	4620      	mov	r0, r4
 80a1d6c:	bd10      	pop	{r4, pc}

080a1d6e <_ZN5spark12NetworkClass7connectEj>:
        return Network;
    }
}

void NetworkClass::connect(unsigned flags) {
    network_connect(*this, flags, 0, nullptr);
 80a1d6e:	2300      	movs	r3, #0
 80a1d70:	461a      	mov	r2, r3
 80a1d72:	6840      	ldr	r0, [r0, #4]
 80a1d74:	f7ff bd70 	b.w	80a1858 <network_connect>

080a1d78 <_ZN5spark12NetworkClass10disconnectEv>:
}

void NetworkClass::disconnect() {
    network_disconnect(*this, NETWORK_DISCONNECT_REASON_USER, nullptr);
 80a1d78:	2200      	movs	r2, #0
 80a1d7a:	2102      	movs	r1, #2
 80a1d7c:	6840      	ldr	r0, [r0, #4]
 80a1d7e:	f7ff bd7b 	b.w	80a1878 <network_disconnect>

080a1d82 <_ZN5spark12NetworkClass10connectingEv>:
}

bool NetworkClass::connecting() {
    return network_connecting(*this, 0, nullptr);
 80a1d82:	2200      	movs	r2, #0
 80a1d84:	4611      	mov	r1, r2
 80a1d86:	6840      	ldr	r0, [r0, #4]
 80a1d88:	f7ff bd6e 	b.w	80a1868 <network_connecting>

080a1d8c <_ZN5spark12NetworkClass5readyEv>:
}

bool NetworkClass::ready() {
    return network_ready(*this, 0, nullptr);
 80a1d8c:	2200      	movs	r2, #0
 80a1d8e:	4611      	mov	r1, r2
 80a1d90:	6840      	ldr	r0, [r0, #4]
 80a1d92:	f7ff bd79 	b.w	80a1888 <network_ready>

080a1d96 <_ZN5spark12NetworkClass2onEv>:
}

void NetworkClass::on() {
    network_on(*this, 0, 0, nullptr);
 80a1d96:	2300      	movs	r3, #0
 80a1d98:	461a      	mov	r2, r3
 80a1d9a:	4619      	mov	r1, r3
 80a1d9c:	6840      	ldr	r0, [r0, #4]
 80a1d9e:	f7ff bd7b 	b.w	80a1898 <network_on>

080a1da2 <_ZN5spark12NetworkClass3offEv>:
}

void NetworkClass::off() {
    network_off(*this, 0, 0, nullptr);
 80a1da2:	2300      	movs	r3, #0
 80a1da4:	461a      	mov	r2, r3
 80a1da6:	4619      	mov	r1, r3
 80a1da8:	6840      	ldr	r0, [r0, #4]
 80a1daa:	f7ff bd7d 	b.w	80a18a8 <network_off>

080a1dae <_ZN5spark12NetworkClass6listenEb>:
}

void NetworkClass::listen(bool begin) {
    network_listen(*this, begin ? 0 : 1, nullptr);
 80a1dae:	2200      	movs	r2, #0
 80a1db0:	f081 0101 	eor.w	r1, r1, #1
 80a1db4:	6840      	ldr	r0, [r0, #4]
 80a1db6:	f7ff bd7f 	b.w	80a18b8 <network_listen>

080a1dba <_ZN5spark12NetworkClass16setListenTimeoutEt>:
}

void NetworkClass::setListenTimeout(uint16_t timeout) {
    network_set_listen_timeout(*this, timeout, nullptr);
 80a1dba:	2200      	movs	r2, #0
 80a1dbc:	6840      	ldr	r0, [r0, #4]
 80a1dbe:	f7ff bd8b 	b.w	80a18d8 <network_set_listen_timeout>

080a1dc2 <_ZN5spark12NetworkClass16getListenTimeoutEv>:
}

uint16_t NetworkClass::getListenTimeout() {
    return network_get_listen_timeout(*this, 0, nullptr);
 80a1dc2:	2200      	movs	r2, #0
 80a1dc4:	4611      	mov	r1, r2
 80a1dc6:	6840      	ldr	r0, [r0, #4]
 80a1dc8:	f7ff bd8e 	b.w	80a18e8 <network_get_listen_timeout>

080a1dcc <_ZN5spark12NetworkClass9listeningEv>:
}

bool NetworkClass::listening() {
    return network_listening(*this, 0, nullptr);
 80a1dcc:	2200      	movs	r2, #0
 80a1dce:	4611      	mov	r1, r2
 80a1dd0:	6840      	ldr	r0, [r0, #4]
 80a1dd2:	f7ff bd79 	b.w	80a18c8 <network_listening>
	...

080a1dd8 <_ZN5spark12NetworkClass7resolveEPKc>:
}

IPAddress NetworkClass::resolve(const char* name) {
 80a1dd8:	b570      	push	{r4, r5, r6, lr}
 80a1dda:	4616      	mov	r6, r2
 80a1ddc:	b08e      	sub	sp, #56	; 0x38
 80a1dde:	4604      	mov	r4, r0
    IPAddress addr;
 80a1de0:	a808      	add	r0, sp, #32
 80a1de2:	f000 f9dd 	bl	80a21a0 <_ZN9IPAddressC1Ev>
    }

#if !HAL_USE_INET_HAL_POSIX
    IPAddress resolve(const char* name)
    {
        HAL_IPAddress ip = {};
 80a1de6:	2211      	movs	r2, #17
 80a1de8:	2100      	movs	r1, #0
 80a1dea:	a803      	add	r0, sp, #12
 80a1dec:	f001 ff8c 	bl	80a3d08 <memset>
        return (inet_gethostbyname(name, strlen(name), &ip, *this, NULL) != 0) ?
 80a1df0:	4630      	mov	r0, r6
 80a1df2:	f001 ffdb 	bl	80a3dac <strlen>
 80a1df6:	2500      	movs	r5, #0
 80a1df8:	4b0a      	ldr	r3, [pc, #40]	; (80a1e24 <_ZN5spark12NetworkClass7resolveEPKc+0x4c>)
 80a1dfa:	9500      	str	r5, [sp, #0]
 80a1dfc:	b281      	uxth	r1, r0
 80a1dfe:	685b      	ldr	r3, [r3, #4]
 80a1e00:	aa03      	add	r2, sp, #12
 80a1e02:	4630      	mov	r0, r6
 80a1e04:	f7ff fb86 	bl	80a1514 <inet_gethostbyname>
                IPAddress(uint32_t(0)) : IPAddress(ip);
 80a1e08:	b120      	cbz	r0, 80a1e14 <_ZN5spark12NetworkClass7resolveEPKc+0x3c>
 80a1e0a:	4629      	mov	r1, r5
 80a1e0c:	4620      	mov	r0, r4
 80a1e0e:	f000 f9e7 	bl	80a21e0 <_ZN9IPAddressC1Em>
 80a1e12:	e003      	b.n	80a1e1c <_ZN5spark12NetworkClass7resolveEPKc+0x44>
 80a1e14:	a903      	add	r1, sp, #12
 80a1e16:	4620      	mov	r0, r4
 80a1e18:	f000 f9d0 	bl	80a21bc <_ZN9IPAddressC1ERK16_HAL_IPAddress_t>
    return Cellular.resolve(name);
#endif // Wiring_Cellular

#endif // HAL_USE_INET_HAL_POSIX
    return addr;
}
 80a1e1c:	4620      	mov	r0, r4
 80a1e1e:	b00e      	add	sp, #56	; 0x38
 80a1e20:	bd70      	pop	{r4, r5, r6, pc}
 80a1e22:	bf00      	nop
 80a1e24:	20000128 	.word	0x20000128

080a1e28 <_GLOBAL__sub_I__ZN5spark7NetworkE>:
    static NetworkClass& from(network_interface_t nif);

    virtual IPAddress resolve(const char* name);

    explicit NetworkClass(network_interface_t iface)
            : iface_(iface) {
 80a1e28:	4b02      	ldr	r3, [pc, #8]	; (80a1e34 <_GLOBAL__sub_I__ZN5spark7NetworkE+0xc>)
 80a1e2a:	4a03      	ldr	r2, [pc, #12]	; (80a1e38 <_GLOBAL__sub_I__ZN5spark7NetworkE+0x10>)
 80a1e2c:	601a      	str	r2, [r3, #0]
 80a1e2e:	2200      	movs	r2, #0
 80a1e30:	605a      	str	r2, [r3, #4]
 80a1e32:	4770      	bx	lr
 80a1e34:	20000120 	.word	0x20000120
 80a1e38:	080a4a88 	.word	0x080a4a88

080a1e3c <_ZN5spark9WiFiClass5readyEv>:
    bool connecting(void) {
        return network_connecting(*this, 0, NULL);
    }

    bool ready(void) {
        return network_ready(*this, 0, NULL);
 80a1e3c:	2200      	movs	r2, #0
 80a1e3e:	4611      	mov	r1, r2
 80a1e40:	6840      	ldr	r0, [r0, #4]
 80a1e42:	f7ff bd21 	b.w	80a1888 <network_ready>

080a1e46 <_ZN5spark9WiFiClass7resolveEPKc>:
    WLanSelectAntenna_TypeDef getAntenna() {
        return wlan_get_antenna(nullptr);
    }

#if !HAL_USE_INET_HAL_POSIX
    IPAddress resolve(const char* name)
 80a1e46:	b5f0      	push	{r4, r5, r6, r7, lr}
 80a1e48:	4616      	mov	r6, r2
 80a1e4a:	b089      	sub	sp, #36	; 0x24
    {
        HAL_IPAddress ip = {};
 80a1e4c:	2211      	movs	r2, #17
    WLanSelectAntenna_TypeDef getAntenna() {
        return wlan_get_antenna(nullptr);
    }

#if !HAL_USE_INET_HAL_POSIX
    IPAddress resolve(const char* name)
 80a1e4e:	460f      	mov	r7, r1
 80a1e50:	4604      	mov	r4, r0
    {
        HAL_IPAddress ip = {};
 80a1e52:	2100      	movs	r1, #0
 80a1e54:	a803      	add	r0, sp, #12
 80a1e56:	f001 ff57 	bl	80a3d08 <memset>
        return (inet_gethostbyname(name, strlen(name), &ip, *this, NULL) != 0) ?
 80a1e5a:	4630      	mov	r0, r6
 80a1e5c:	f001 ffa6 	bl	80a3dac <strlen>
 80a1e60:	2500      	movs	r5, #0
 80a1e62:	9500      	str	r5, [sp, #0]
 80a1e64:	b281      	uxth	r1, r0
 80a1e66:	687b      	ldr	r3, [r7, #4]
 80a1e68:	aa03      	add	r2, sp, #12
 80a1e6a:	4630      	mov	r0, r6
 80a1e6c:	f7ff fb52 	bl	80a1514 <inet_gethostbyname>
                IPAddress(uint32_t(0)) : IPAddress(ip);
 80a1e70:	b120      	cbz	r0, 80a1e7c <_ZN5spark9WiFiClass7resolveEPKc+0x36>
 80a1e72:	4629      	mov	r1, r5
 80a1e74:	4620      	mov	r0, r4
 80a1e76:	f000 f9b3 	bl	80a21e0 <_ZN9IPAddressC1Em>
 80a1e7a:	e003      	b.n	80a1e84 <_ZN5spark9WiFiClass7resolveEPKc+0x3e>
 80a1e7c:	a903      	add	r1, sp, #12
 80a1e7e:	4620      	mov	r0, r4
 80a1e80:	f000 f99c 	bl	80a21bc <_ZN9IPAddressC1ERK16_HAL_IPAddress_t>
    }
 80a1e84:	4620      	mov	r0, r4
 80a1e86:	b009      	add	sp, #36	; 0x24
 80a1e88:	bdf0      	pop	{r4, r5, r6, r7, pc}

080a1e8a <_ZN5spark9WiFiClass9listeningEv>:
    uint16_t getListenTimeout(void) {
        return network_get_listen_timeout(*this, 0, NULL);
    }

    bool listening(void) {
        return network_listening(*this, 0, NULL);
 80a1e8a:	2200      	movs	r2, #0
 80a1e8c:	4611      	mov	r1, r2
 80a1e8e:	6840      	ldr	r0, [r0, #4]
 80a1e90:	f7ff bd1a 	b.w	80a18c8 <network_listening>

080a1e94 <_ZN5spark9WiFiClass16getListenTimeoutEv>:
        network_set_listen_timeout(*this, timeout, NULL);
    }
    inline void setListenTimeout(std::chrono::seconds s) { setListenTimeout(s.count()); }

    uint16_t getListenTimeout(void) {
        return network_get_listen_timeout(*this, 0, NULL);
 80a1e94:	2200      	movs	r2, #0
 80a1e96:	4611      	mov	r1, r2
 80a1e98:	6840      	ldr	r0, [r0, #4]
 80a1e9a:	f7ff bd25 	b.w	80a18e8 <network_get_listen_timeout>

080a1e9e <_ZN5spark9WiFiClass16setListenTimeoutEt>:
    void listen(bool begin=true) {
        network_listen(*this, begin ? 0 : 1, NULL);
    }

    void setListenTimeout(uint16_t timeout) {
        network_set_listen_timeout(*this, timeout, NULL);
 80a1e9e:	2200      	movs	r2, #0
 80a1ea0:	6840      	ldr	r0, [r0, #4]
 80a1ea2:	f7ff bd19 	b.w	80a18d8 <network_set_listen_timeout>

080a1ea6 <_ZN5spark9WiFiClass6listenEb>:
    void off(void) {
        network_off(*this, 0, 0, NULL);
    }

    void listen(bool begin=true) {
        network_listen(*this, begin ? 0 : 1, NULL);
 80a1ea6:	2200      	movs	r2, #0
 80a1ea8:	f081 0101 	eor.w	r1, r1, #1
 80a1eac:	6840      	ldr	r0, [r0, #4]
 80a1eae:	f7ff bd03 	b.w	80a18b8 <network_listen>

080a1eb2 <_ZN5spark9WiFiClass3offEv>:
    void on(void) {
        network_on(*this, 0, 0, NULL);
    }

    void off(void) {
        network_off(*this, 0, 0, NULL);
 80a1eb2:	2300      	movs	r3, #0
 80a1eb4:	461a      	mov	r2, r3
 80a1eb6:	4619      	mov	r1, r3
 80a1eb8:	6840      	ldr	r0, [r0, #4]
 80a1eba:	f7ff bcf5 	b.w	80a18a8 <network_off>

080a1ebe <_ZN5spark9WiFiClass2onEv>:
    bool ready(void) {
        return network_ready(*this, 0, NULL);
    }

    void on(void) {
        network_on(*this, 0, 0, NULL);
 80a1ebe:	2300      	movs	r3, #0
 80a1ec0:	461a      	mov	r2, r3
 80a1ec2:	4619      	mov	r1, r3
 80a1ec4:	6840      	ldr	r0, [r0, #4]
 80a1ec6:	f7ff bce7 	b.w	80a1898 <network_on>

080a1eca <_ZN5spark9WiFiClass10connectingEv>:
    void disconnect(void) {
        network_disconnect(*this, NETWORK_DISCONNECT_REASON_USER, NULL);
    }

    bool connecting(void) {
        return network_connecting(*this, 0, NULL);
 80a1eca:	2200      	movs	r2, #0
 80a1ecc:	4611      	mov	r1, r2
 80a1ece:	6840      	ldr	r0, [r0, #4]
 80a1ed0:	f7ff bcca 	b.w	80a1868 <network_connecting>

080a1ed4 <_ZN5spark9WiFiClass10disconnectEv>:
    void connect(unsigned flags=0) {
        network_connect(*this, flags, 0, NULL);
    }

    void disconnect(void) {
        network_disconnect(*this, NETWORK_DISCONNECT_REASON_USER, NULL);
 80a1ed4:	2200      	movs	r2, #0
 80a1ed6:	2102      	movs	r1, #2
 80a1ed8:	6840      	ldr	r0, [r0, #4]
 80a1eda:	f7ff bccd 	b.w	80a1878 <network_disconnect>

080a1ede <_ZN5spark9WiFiClass7connectEj>:
    uint32_t ping(IPAddress remoteIP, uint8_t nTries) {
        return inet_ping(&remoteIP.raw(), *this, nTries, NULL);
    }

    void connect(unsigned flags=0) {
        network_connect(*this, flags, 0, NULL);
 80a1ede:	2300      	movs	r3, #0
 80a1ee0:	461a      	mov	r2, r3
 80a1ee2:	6840      	ldr	r0, [r0, #4]
 80a1ee4:	f7ff bcb8 	b.w	80a1858 <network_connect>

080a1ee8 <_GLOBAL__sub_I__ZN10WiFiSignalC2ERK21wlan_connected_info_t>:
 80a1ee8:	4b02      	ldr	r3, [pc, #8]	; (80a1ef4 <_GLOBAL__sub_I__ZN10WiFiSignalC2ERK21wlan_connected_info_t+0xc>)
 80a1eea:	2204      	movs	r2, #4
 80a1eec:	605a      	str	r2, [r3, #4]
        wlan_set_ipaddress_source(source, true, NULL);
    }

public:
    WiFiClass() :
            NetworkClass(NETWORK_INTERFACE_WIFI_STA) {
 80a1eee:	4a02      	ldr	r2, [pc, #8]	; (80a1ef8 <_GLOBAL__sub_I__ZN10WiFiSignalC2ERK21wlan_connected_info_t+0x10>)
 80a1ef0:	601a      	str	r2, [r3, #0]
 80a1ef2:	4770      	bx	lr
 80a1ef4:	20000128 	.word	0x20000128
 80a1ef8:	080a4abc 	.word	0x080a4abc

080a1efc <_ZN7TwoWireD1Ev>:
private:
  HAL_I2C_Interface _i2c;

public:
  TwoWire(HAL_I2C_Interface i2c, const HAL_I2C_Config& config);
  virtual ~TwoWire() {};
 80a1efc:	4770      	bx	lr

080a1efe <_ZN7TwoWire5writeEPKhj>:

// must be called in:
// slave tx event callback
// or after beginTransmission(address)
size_t TwoWire::write(const uint8_t *data, size_t quantity)
{
 80a1efe:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80a1f00:	4606      	mov	r6, r0
 80a1f02:	4615      	mov	r5, r2
 80a1f04:	460c      	mov	r4, r1
 80a1f06:	188f      	adds	r7, r1, r2
  // in master/slave transmitter mode
  for(size_t i = 0; i < quantity; ++i)
 80a1f08:	42bc      	cmp	r4, r7
 80a1f0a:	d006      	beq.n	80a1f1a <_ZN7TwoWire5writeEPKhj+0x1c>
  {
    write(data[i]);
 80a1f0c:	6833      	ldr	r3, [r6, #0]
 80a1f0e:	f814 1b01 	ldrb.w	r1, [r4], #1
 80a1f12:	689b      	ldr	r3, [r3, #8]
 80a1f14:	4630      	mov	r0, r6
 80a1f16:	4798      	blx	r3
// slave tx event callback
// or after beginTransmission(address)
size_t TwoWire::write(const uint8_t *data, size_t quantity)
{
  // in master/slave transmitter mode
  for(size_t i = 0; i < quantity; ++i)
 80a1f18:	e7f6      	b.n	80a1f08 <_ZN7TwoWire5writeEPKhj+0xa>
  {
    write(data[i]);
  }

  return quantity;
}
 80a1f1a:	4628      	mov	r0, r5
 80a1f1c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

080a1f1e <_ZN7TwoWire5writeEh>:
// must be called in:
// slave tx event callback
// or after beginTransmission(address)
size_t TwoWire::write(uint8_t data)
{
  return HAL_I2C_Write_Data(_i2c, data, NULL);
 80a1f1e:	2200      	movs	r2, #0
 80a1f20:	7c00      	ldrb	r0, [r0, #16]
 80a1f22:	f7ff bb5f 	b.w	80a15e4 <HAL_I2C_Write_Data>

080a1f26 <_ZN7TwoWire9availableEv>:
// must be called in:
// slave rx event callback
// or after requestFrom(address, numBytes)
int TwoWire::available(void)
{
  return HAL_I2C_Available_Data(_i2c, NULL);
 80a1f26:	2100      	movs	r1, #0
 80a1f28:	7c00      	ldrb	r0, [r0, #16]
 80a1f2a:	f7ff bb63 	b.w	80a15f4 <HAL_I2C_Available_Data>

080a1f2e <_ZN7TwoWire4readEv>:
// must be called in:
// slave rx event callback
// or after requestFrom(address, numBytes)
int TwoWire::read(void)
{
  return HAL_I2C_Read_Data(_i2c, NULL);
 80a1f2e:	2100      	movs	r1, #0
 80a1f30:	7c00      	ldrb	r0, [r0, #16]
 80a1f32:	f7ff bb67 	b.w	80a1604 <HAL_I2C_Read_Data>

080a1f36 <_ZN7TwoWire4peekEv>:
// must be called in:
// slave rx event callback
// or after requestFrom(address, numBytes)
int TwoWire::peek(void)
{
  return HAL_I2C_Peek_Data(_i2c, NULL);
 80a1f36:	2100      	movs	r1, #0
 80a1f38:	7c00      	ldrb	r0, [r0, #16]
 80a1f3a:	f7ff bb6b 	b.w	80a1614 <HAL_I2C_Peek_Data>

080a1f3e <_ZN7TwoWire5flushEv>:
}

void TwoWire::flush(void)
{
  HAL_I2C_Flush_Data(_i2c, NULL);
 80a1f3e:	2100      	movs	r1, #0
 80a1f40:	7c00      	ldrb	r0, [r0, #16]
 80a1f42:	f7ff bb6f 	b.w	80a1624 <HAL_I2C_Flush_Data>

080a1f46 <_ZN7TwoWireD0Ev>:
 80a1f46:	b510      	push	{r4, lr}
 80a1f48:	4604      	mov	r4, r0
 80a1f4a:	2114      	movs	r1, #20
 80a1f4c:	f001 fd4c 	bl	80a39e8 <_ZdlPvj>
 80a1f50:	4620      	mov	r0, r4
 80a1f52:	bd10      	pop	{r4, pc}

080a1f54 <_ZN7TwoWireC1E17HAL_I2C_InterfaceRK14HAL_I2C_Config>:
#include "i2c_hal.h"
#include "spark_wiring_thread.h"

// Constructors ////////////////////////////////////////////////////////////////

TwoWire::TwoWire(HAL_I2C_Interface i2c, const HAL_I2C_Config& conf)
 80a1f54:	b510      	push	{r4, lr}
 80a1f56:	4604      	mov	r4, r0
  protected:
    void setWriteError(int err = 1) { write_error = err; }
    size_t printf_impl(bool newline, const char* format, ...);

  public:
    Print() : write_error(0) {}
 80a1f58:	2300      	movs	r3, #0
 80a1f5a:	6063      	str	r3, [r4, #4]
    virtual int available() = 0;
    virtual int read() = 0;
    virtual int peek() = 0;
    virtual void flush() = 0;

    Stream() {_timeout=1000;}
 80a1f5c:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 80a1f60:	60a3      	str	r3, [r4, #8]
 80a1f62:	4b04      	ldr	r3, [pc, #16]	; (80a1f74 <_ZN7TwoWireC1E17HAL_I2C_InterfaceRK14HAL_I2C_Config+0x20>)
{
  _i2c = i2c;
 80a1f64:	7421      	strb	r1, [r4, #16]
#include "i2c_hal.h"
#include "spark_wiring_thread.h"

// Constructors ////////////////////////////////////////////////////////////////

TwoWire::TwoWire(HAL_I2C_Interface i2c, const HAL_I2C_Config& conf)
 80a1f66:	4608      	mov	r0, r1
 80a1f68:	6023      	str	r3, [r4, #0]
{
  _i2c = i2c;
  HAL_I2C_Init(_i2c, &conf);
 80a1f6a:	4611      	mov	r1, r2
 80a1f6c:	f7ff fb6a 	bl	80a1644 <HAL_I2C_Init>
}
 80a1f70:	4620      	mov	r0, r4
 80a1f72:	bd10      	pop	{r4, pc}
 80a1f74:	080a4af0 	.word	0x080a4af0

080a1f78 <_ZN7TwoWire8setSpeedEm>:
// Public Methods //////////////////////////////////////////////////////////////

//setSpeed() should be called before begin() else default to 100KHz
void TwoWire::setSpeed(uint32_t clockSpeed)
{
  HAL_I2C_Set_Speed(_i2c, clockSpeed, NULL);
 80a1f78:	2200      	movs	r2, #0
 80a1f7a:	7c00      	ldrb	r0, [r0, #16]
 80a1f7c:	f7ff bb12 	b.w	80a15a4 <HAL_I2C_Set_Speed>

080a1f80 <_ZN7TwoWire5beginEv>:
  HAL_I2C_Stretch_Clock(_i2c, stretch, NULL);
}

void TwoWire::begin(void)
{
	HAL_I2C_Begin(_i2c, I2C_MODE_MASTER, 0x00, NULL);
 80a1f80:	2300      	movs	r3, #0
 80a1f82:	461a      	mov	r2, r3
 80a1f84:	4619      	mov	r1, r3
 80a1f86:	7c00      	ldrb	r0, [r0, #16]
 80a1f88:	f7ff bb14 	b.w	80a15b4 <HAL_I2C_Begin>

080a1f8c <_ZN7TwoWire17beginTransmissionEh>:
  return HAL_I2C_Request_Data_Ex(_i2c, &conf, nullptr);
}

void TwoWire::beginTransmission(uint8_t address)
{
	HAL_I2C_Begin_Transmission(_i2c, address, NULL);
 80a1f8c:	2200      	movs	r2, #0
 80a1f8e:	7c00      	ldrb	r0, [r0, #16]
 80a1f90:	f7ff bb18 	b.w	80a15c4 <HAL_I2C_Begin_Transmission>

080a1f94 <_ZN7TwoWire17beginTransmissionEi>:
}

void TwoWire::beginTransmission(int address)
{
  beginTransmission((uint8_t)address);
 80a1f94:	b2c9      	uxtb	r1, r1
 80a1f96:	f7ff bff9 	b.w	80a1f8c <_ZN7TwoWire17beginTransmissionEh>

080a1f9a <_ZN7TwoWire15endTransmissionEh>:
//	no call to endTransmission(true) is made. Some I2C
//	devices will behave oddly if they do not see a STOP.
//
uint8_t TwoWire::endTransmission(uint8_t sendStop)
{
	return HAL_I2C_End_Transmission(_i2c, sendStop, NULL);
 80a1f9a:	2200      	movs	r2, #0
 80a1f9c:	7c00      	ldrb	r0, [r0, #16]
 80a1f9e:	f7ff bb19 	b.w	80a15d4 <HAL_I2C_End_Transmission>

080a1fa2 <_ZN7TwoWire15endTransmissionEv>:
//	This provides backwards compatibility with the original
//	definition, and expected behaviour, of endTransmission
//
uint8_t TwoWire::endTransmission(void)
{
  return endTransmission(true);
 80a1fa2:	2101      	movs	r1, #1
 80a1fa4:	f7ff bff9 	b.w	80a1f9a <_ZN7TwoWire15endTransmissionEh>

080a1fa8 <_ZN7TwoWire9isEnabledEv>:
  HAL_I2C_Set_Callback_On_Request(_i2c, function, NULL);
}

bool TwoWire::isEnabled()
{
  return HAL_I2C_Is_Enabled(_i2c, NULL);
 80a1fa8:	2100      	movs	r1, #0
 80a1faa:	7c00      	ldrb	r0, [r0, #16]
 80a1fac:	f7ff bb42 	b.w	80a1634 <HAL_I2C_Is_Enabled>

080a1fb0 <_ZN9USBSerial14blockOnOverrunEb>:
  HAL_USB_USART_Flush_Data(_serial);
}

void USBSerial::blockOnOverrun(bool block)
{
  _blocking = block;
 80a1fb0:	7441      	strb	r1, [r0, #17]
 80a1fb2:	4770      	bx	lr

080a1fb4 <_ZN9USBSerialD1Ev>:
#include "usb_hal.h"
#include "system_task.h"
#include "spark_wiring_startup.h"
#include "concurrent_hal.h"

class USBSerial : public Stream
 80a1fb4:	4770      	bx	lr

080a1fb6 <_ZN9USBSerial4readEv>:
}


// Read data from buffer
int USBSerial::read()
{
 80a1fb6:	b508      	push	{r3, lr}
	return std::max(-1, (int)HAL_USB_USART_Receive_Data(_serial, false));
 80a1fb8:	2100      	movs	r1, #0
 80a1fba:	7c00      	ldrb	r0, [r0, #16]
 80a1fbc:	f7ff fada 	bl	80a1574 <HAL_USB_USART_Receive_Data>
}
 80a1fc0:	ea30 0020 	bics.w	r0, r0, r0, asr #32
 80a1fc4:	bf28      	it	cs
 80a1fc6:	f04f 30ff 	movcs.w	r0, #4294967295
 80a1fca:	bd08      	pop	{r3, pc}

080a1fcc <_ZN9USBSerial4peekEv>:
{
  _blocking = block;
}

int USBSerial::peek()
{
 80a1fcc:	b508      	push	{r3, lr}
	return std::max(-1, (int)HAL_USB_USART_Receive_Data(_serial, true));
 80a1fce:	2101      	movs	r1, #1
 80a1fd0:	7c00      	ldrb	r0, [r0, #16]
 80a1fd2:	f7ff facf 	bl	80a1574 <HAL_USB_USART_Receive_Data>
}
 80a1fd6:	ea30 0020 	bics.w	r0, r0, r0, asr #32
 80a1fda:	bf28      	it	cs
 80a1fdc:	f04f 30ff 	movcs.w	r0, #4294967295
 80a1fe0:	bd08      	pop	{r3, pc}

080a1fe2 <_ZN9USBSerial17availableForWriteEv>:
{
	return std::max(-1, (int)HAL_USB_USART_Receive_Data(_serial, false));
}

int USBSerial::availableForWrite()
{
 80a1fe2:	b508      	push	{r3, lr}
  return std::max(0, (int)HAL_USB_USART_Available_Data_For_Write(_serial));
 80a1fe4:	7c00      	ldrb	r0, [r0, #16]
 80a1fe6:	f7ff fabd 	bl	80a1564 <HAL_USB_USART_Available_Data_For_Write>
}
 80a1fea:	ea20 70e0 	bic.w	r0, r0, r0, asr #31
 80a1fee:	bd08      	pop	{r3, pc}

080a1ff0 <_ZN9USBSerial9availableEv>:

int USBSerial::available()
{
 80a1ff0:	b508      	push	{r3, lr}
	return std::max(0, (int)HAL_USB_USART_Available_Data(_serial));
 80a1ff2:	7c00      	ldrb	r0, [r0, #16]
 80a1ff4:	f7ff faae 	bl	80a1554 <HAL_USB_USART_Available_Data>
}
 80a1ff8:	ea20 70e0 	bic.w	r0, r0, r0, asr #31
 80a1ffc:	bd08      	pop	{r3, pc}

080a1ffe <_ZN9USBSerial5flushEv>:
  return 0;
}

void USBSerial::flush()
{
  HAL_USB_USART_Flush_Data(_serial);
 80a1ffe:	7c00      	ldrb	r0, [r0, #16]
 80a2000:	f7ff bac8 	b.w	80a1594 <HAL_USB_USART_Flush_Data>

080a2004 <_ZN9USBSerialD0Ev>:
 80a2004:	b510      	push	{r4, lr}
 80a2006:	4604      	mov	r4, r0
 80a2008:	2114      	movs	r1, #20
 80a200a:	f001 fced 	bl	80a39e8 <_ZdlPvj>
 80a200e:	4620      	mov	r0, r4
 80a2010:	bd10      	pop	{r4, pc}

080a2012 <_ZN9USBSerial5writeEh>:
{
	return std::max(0, (int)HAL_USB_USART_Available_Data(_serial));
}

size_t USBSerial::write(uint8_t byte)
{
 80a2012:	b538      	push	{r3, r4, r5, lr}
 80a2014:	4604      	mov	r4, r0
  if (HAL_USB_USART_Available_Data_For_Write(_serial) > 0 || _blocking) {
 80a2016:	7c00      	ldrb	r0, [r0, #16]
{
	return std::max(0, (int)HAL_USB_USART_Available_Data(_serial));
}

size_t USBSerial::write(uint8_t byte)
{
 80a2018:	460d      	mov	r5, r1
  if (HAL_USB_USART_Available_Data_For_Write(_serial) > 0 || _blocking) {
 80a201a:	f7ff faa3 	bl	80a1564 <HAL_USB_USART_Available_Data_For_Write>
 80a201e:	2800      	cmp	r0, #0
 80a2020:	dc01      	bgt.n	80a2026 <_ZN9USBSerial5writeEh+0x14>
 80a2022:	7c60      	ldrb	r0, [r4, #17]
 80a2024:	b128      	cbz	r0, 80a2032 <_ZN9USBSerial5writeEh+0x20>
    return std::max(0, (int)HAL_USB_USART_Send_Data(_serial, byte));
 80a2026:	4629      	mov	r1, r5
 80a2028:	7c20      	ldrb	r0, [r4, #16]
 80a202a:	f7ff faab 	bl	80a1584 <HAL_USB_USART_Send_Data>
 80a202e:	ea20 70e0 	bic.w	r0, r0, r0, asr #31
  }
  return 0;
}
 80a2032:	bd38      	pop	{r3, r4, r5, pc}

080a2034 <_ZN9USBSerialC1E20HAL_USB_USART_SerialRK20HAL_USB_USART_Config>:

  HAL_USB_USART_Config conf = acquireSerialBuffer();
  HAL_USB_USART_Init(_serial, &conf);
}

USBSerial::USBSerial(HAL_USB_USART_Serial serial, const HAL_USB_USART_Config& conf)
 80a2034:	b510      	push	{r4, lr}
 80a2036:	4604      	mov	r4, r0
 80a2038:	2300      	movs	r3, #0
 80a203a:	6063      	str	r3, [r4, #4]
 80a203c:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 80a2040:	60a3      	str	r3, [r4, #8]
 80a2042:	4b05      	ldr	r3, [pc, #20]	; (80a2058 <_ZN9USBSerialC1E20HAL_USB_USART_SerialRK20HAL_USB_USART_Config+0x24>)
 80a2044:	4608      	mov	r0, r1
 80a2046:	6023      	str	r3, [r4, #0]
{
  _serial = serial;
  _blocking = true;
 80a2048:	2301      	movs	r3, #1
  HAL_USB_USART_Init(_serial, &conf);
}

USBSerial::USBSerial(HAL_USB_USART_Serial serial, const HAL_USB_USART_Config& conf)
{
  _serial = serial;
 80a204a:	7421      	strb	r1, [r4, #16]
  _blocking = true;
 80a204c:	7463      	strb	r3, [r4, #17]

  HAL_USB_USART_Init(_serial, &conf);
 80a204e:	4611      	mov	r1, r2
 80a2050:	f7ff fa68 	bl	80a1524 <HAL_USB_USART_Init>
}
 80a2054:	4620      	mov	r0, r4
 80a2056:	bd10      	pop	{r4, pc}
 80a2058:	080a4b18 	.word	0x080a4b18

080a205c <_ZN9USBSerial5beginEl>:
// Public methods
//

void USBSerial::begin(long speed)
{
    HAL_USB_USART_Begin(_serial, speed, NULL);
 80a205c:	2200      	movs	r2, #0
 80a205e:	7c00      	ldrb	r0, [r0, #16]
 80a2060:	f7ff ba68 	b.w	80a1534 <HAL_USB_USART_Begin>

080a2064 <_ZN9USBSerial3endEv>:
}

void USBSerial::end()
{
    HAL_USB_USART_End(_serial);
 80a2064:	7c00      	ldrb	r0, [r0, #16]
 80a2066:	f7ff ba6d 	b.w	80a1544 <HAL_USB_USART_End>
	...

080a206c <_Z19acquireSerialBufferv>:

// Preinstantiate Objects //////////////////////////////////////////////////////
#ifdef SPARK_USB_SERIAL

HAL_USB_USART_Config __attribute__((weak)) acquireSerialBuffer()
{
 80a206c:	b510      	push	{r4, lr}
 80a206e:	4604      	mov	r4, r0
  HAL_USB_USART_Config conf = {0};
 80a2070:	2214      	movs	r2, #20
 80a2072:	2100      	movs	r1, #0
 80a2074:	f001 fe48 	bl	80a3d08 <memset>

#if defined(USB_SERIAL_USERSPACE_BUFFERS) && ((MODULE_FUNCTION == MOD_FUNC_USER_PART) || (MODULE_FUNCTION == MOD_FUNC_MONO_FIRMWARE))
  static uint8_t serial_rx_buffer[USB_RX_BUFFER_SIZE];
  static uint8_t serial_tx_buffer[USB_TX_BUFFER_SIZE];

  conf.rx_buffer = serial_rx_buffer;
 80a2078:	4b05      	ldr	r3, [pc, #20]	; (80a2090 <_Z19acquireSerialBufferv+0x24>)
  conf.rx_buffer_size = USB_RX_BUFFER_SIZE;
  conf.tx_buffer_size = USB_TX_BUFFER_SIZE;
#endif

  return conf;
}
 80a207a:	4620      	mov	r0, r4

#if defined(USB_SERIAL_USERSPACE_BUFFERS) && ((MODULE_FUNCTION == MOD_FUNC_USER_PART) || (MODULE_FUNCTION == MOD_FUNC_MONO_FIRMWARE))
  static uint8_t serial_rx_buffer[USB_RX_BUFFER_SIZE];
  static uint8_t serial_tx_buffer[USB_TX_BUFFER_SIZE];

  conf.rx_buffer = serial_rx_buffer;
 80a207c:	6063      	str	r3, [r4, #4]
  conf.tx_buffer = serial_tx_buffer;
 80a207e:	4b05      	ldr	r3, [pc, #20]	; (80a2094 <_Z19acquireSerialBufferv+0x28>)
 80a2080:	60e3      	str	r3, [r4, #12]
  conf.rx_buffer_size = USB_RX_BUFFER_SIZE;
 80a2082:	f240 1301 	movw	r3, #257	; 0x101
 80a2086:	8123      	strh	r3, [r4, #8]
  conf.tx_buffer_size = USB_TX_BUFFER_SIZE;
 80a2088:	2381      	movs	r3, #129	; 0x81
 80a208a:	8223      	strh	r3, [r4, #16]
#endif

  return conf;
}
 80a208c:	bd10      	pop	{r4, pc}
 80a208e:	bf00      	nop
 80a2090:	200001b5 	.word	0x200001b5
 80a2094:	20000134 	.word	0x20000134

080a2098 <_Z16_fetch_usbserialv>:

USBSerial& _fetch_usbserial()
{
 80a2098:	b530      	push	{r4, r5, lr}
  HAL_USB_USART_Config conf = acquireSerialBuffer();
	static USBSerial _usbserial(HAL_USB_USART_SERIAL, conf);
 80a209a:	4d0e      	ldr	r5, [pc, #56]	; (80a20d4 <_Z16_fetch_usbserialv+0x3c>)

  return conf;
}

USBSerial& _fetch_usbserial()
{
 80a209c:	b087      	sub	sp, #28
  HAL_USB_USART_Config conf = acquireSerialBuffer();
 80a209e:	a801      	add	r0, sp, #4
 80a20a0:	f7ff ffe4 	bl	80a206c <_Z19acquireSerialBufferv>
	static USBSerial _usbserial(HAL_USB_USART_SERIAL, conf);
 80a20a4:	6829      	ldr	r1, [r5, #0]
 80a20a6:	f011 0401 	ands.w	r4, r1, #1
 80a20aa:	d110      	bne.n	80a20ce <_Z16_fetch_usbserialv+0x36>
 80a20ac:	4628      	mov	r0, r5
 80a20ae:	f7fe f801 	bl	80a00b4 <__cxa_guard_acquire>
 80a20b2:	b160      	cbz	r0, 80a20ce <_Z16_fetch_usbserialv+0x36>
 80a20b4:	aa01      	add	r2, sp, #4
 80a20b6:	4621      	mov	r1, r4
 80a20b8:	4807      	ldr	r0, [pc, #28]	; (80a20d8 <_Z16_fetch_usbserialv+0x40>)
 80a20ba:	f7ff ffbb 	bl	80a2034 <_ZN9USBSerialC1E20HAL_USB_USART_SerialRK20HAL_USB_USART_Config>
 80a20be:	4628      	mov	r0, r5
 80a20c0:	f7fd fffd 	bl	80a00be <__cxa_guard_release>
 80a20c4:	4a05      	ldr	r2, [pc, #20]	; (80a20dc <_Z16_fetch_usbserialv+0x44>)
 80a20c6:	4906      	ldr	r1, [pc, #24]	; (80a20e0 <_Z16_fetch_usbserialv+0x48>)
 80a20c8:	4803      	ldr	r0, [pc, #12]	; (80a20d8 <_Z16_fetch_usbserialv+0x40>)
 80a20ca:	f001 fc7f 	bl	80a39cc <__aeabi_atexit>
	return _usbserial;
}
 80a20ce:	4802      	ldr	r0, [pc, #8]	; (80a20d8 <_Z16_fetch_usbserialv+0x40>)
 80a20d0:	b007      	add	sp, #28
 80a20d2:	bd30      	pop	{r4, r5, pc}
 80a20d4:	20000130 	.word	0x20000130
 80a20d8:	200002b8 	.word	0x200002b8
 80a20dc:	20000074 	.word	0x20000074
 80a20e0:	080a1fb5 	.word	0x080a1fb5

080a20e4 <_Z23acquireUSBSerial1Bufferv>:

#if Wiring_USBSerial1

HAL_USB_USART_Config __attribute__((weak)) acquireUSBSerial1Buffer()
{
 80a20e4:	b510      	push	{r4, lr}
 80a20e6:	4604      	mov	r4, r0
  HAL_USB_USART_Config conf = {0};
 80a20e8:	2214      	movs	r2, #20
 80a20ea:	2100      	movs	r1, #0
 80a20ec:	f001 fe0c 	bl	80a3d08 <memset>

#if defined(USB_SERIAL_USERSPACE_BUFFERS) && ((MODULE_FUNCTION == MOD_FUNC_USER_PART) || (MODULE_FUNCTION == MOD_FUNC_MONO_FIRMWARE))
  static uint8_t usbserial1_rx_buffer[USB_RX_BUFFER_SIZE];
  static uint8_t usbserial1_tx_buffer[USB_TX_BUFFER_SIZE];

  conf.rx_buffer = usbserial1_rx_buffer;
 80a20f0:	4b05      	ldr	r3, [pc, #20]	; (80a2108 <_Z23acquireUSBSerial1Bufferv+0x24>)
  conf.rx_buffer_size = USB_RX_BUFFER_SIZE;
  conf.tx_buffer_size = USB_TX_BUFFER_SIZE;
#endif

  return conf;
}
 80a20f2:	4620      	mov	r0, r4

#if defined(USB_SERIAL_USERSPACE_BUFFERS) && ((MODULE_FUNCTION == MOD_FUNC_USER_PART) || (MODULE_FUNCTION == MOD_FUNC_MONO_FIRMWARE))
  static uint8_t usbserial1_rx_buffer[USB_RX_BUFFER_SIZE];
  static uint8_t usbserial1_tx_buffer[USB_TX_BUFFER_SIZE];

  conf.rx_buffer = usbserial1_rx_buffer;
 80a20f4:	6063      	str	r3, [r4, #4]
  conf.tx_buffer = usbserial1_tx_buffer;
 80a20f6:	4b05      	ldr	r3, [pc, #20]	; (80a210c <_Z23acquireUSBSerial1Bufferv+0x28>)
 80a20f8:	60e3      	str	r3, [r4, #12]
  conf.rx_buffer_size = USB_RX_BUFFER_SIZE;
 80a20fa:	f240 1301 	movw	r3, #257	; 0x101
 80a20fe:	8123      	strh	r3, [r4, #8]
  conf.tx_buffer_size = USB_TX_BUFFER_SIZE;
 80a2100:	2381      	movs	r3, #129	; 0x81
 80a2102:	8223      	strh	r3, [r4, #16]
#endif

  return conf;
}
 80a2104:	bd10      	pop	{r4, pc}
 80a2106:	bf00      	nop
 80a2108:	20000368 	.word	0x20000368
 80a210c:	200002d0 	.word	0x200002d0

080a2110 <_Z17_fetch_usbserial1v>:

USBSerial& _fetch_usbserial1()
{
 80a2110:	b510      	push	{r4, lr}
  HAL_USB_USART_Config conf = acquireUSBSerial1Buffer();
  static USBSerial _usbserial1(HAL_USB_USART_SERIAL1, conf);
 80a2112:	4c0e      	ldr	r4, [pc, #56]	; (80a214c <_Z17_fetch_usbserial1v+0x3c>)

  return conf;
}

USBSerial& _fetch_usbserial1()
{
 80a2114:	b086      	sub	sp, #24
  HAL_USB_USART_Config conf = acquireUSBSerial1Buffer();
 80a2116:	a801      	add	r0, sp, #4
 80a2118:	f7ff ffe4 	bl	80a20e4 <_Z23acquireUSBSerial1Bufferv>
  static USBSerial _usbserial1(HAL_USB_USART_SERIAL1, conf);
 80a211c:	6823      	ldr	r3, [r4, #0]
 80a211e:	07db      	lsls	r3, r3, #31
 80a2120:	d410      	bmi.n	80a2144 <_Z17_fetch_usbserial1v+0x34>
 80a2122:	4620      	mov	r0, r4
 80a2124:	f7fd ffc6 	bl	80a00b4 <__cxa_guard_acquire>
 80a2128:	b160      	cbz	r0, 80a2144 <_Z17_fetch_usbserial1v+0x34>
 80a212a:	aa01      	add	r2, sp, #4
 80a212c:	2101      	movs	r1, #1
 80a212e:	4808      	ldr	r0, [pc, #32]	; (80a2150 <_Z17_fetch_usbserial1v+0x40>)
 80a2130:	f7ff ff80 	bl	80a2034 <_ZN9USBSerialC1E20HAL_USB_USART_SerialRK20HAL_USB_USART_Config>
 80a2134:	4620      	mov	r0, r4
 80a2136:	f7fd ffc2 	bl	80a00be <__cxa_guard_release>
 80a213a:	4a06      	ldr	r2, [pc, #24]	; (80a2154 <_Z17_fetch_usbserial1v+0x44>)
 80a213c:	4906      	ldr	r1, [pc, #24]	; (80a2158 <_Z17_fetch_usbserial1v+0x48>)
 80a213e:	4804      	ldr	r0, [pc, #16]	; (80a2150 <_Z17_fetch_usbserial1v+0x40>)
 80a2140:	f001 fc44 	bl	80a39cc <__aeabi_atexit>
  return _usbserial1;
}
 80a2144:	4802      	ldr	r0, [pc, #8]	; (80a2150 <_Z17_fetch_usbserial1v+0x40>)
 80a2146:	b006      	add	sp, #24
 80a2148:	bd10      	pop	{r4, pc}
 80a214a:	bf00      	nop
 80a214c:	200002cc 	.word	0x200002cc
 80a2150:	20000354 	.word	0x20000354
 80a2154:	20000074 	.word	0x20000074
 80a2158:	080a1fb5 	.word	0x080a1fb5

080a215c <_ZN9IPAddressD1Ev>:
    IPAddress(uint8_t first_octet, uint8_t second_octet, uint8_t third_octet, uint8_t fourth_octet);
    IPAddress(uint32_t address);
    IPAddress(const uint8_t* address);
    IPAddress(const HAL_IPAddress& address);

    virtual ~IPAddress() {}
 80a215c:	4770      	bx	lr

080a215e <_ZN9IPAddressD0Ev>:
 80a215e:	b510      	push	{r4, lr}
 80a2160:	4604      	mov	r4, r0
 80a2162:	2118      	movs	r1, #24
 80a2164:	f001 fc40 	bl	80a39e8 <_ZdlPvj>
 80a2168:	4620      	mov	r0, r4
 80a216a:	bd10      	pop	{r4, pc}

080a216c <_ZNK9IPAddress7printToER5Print>:
#endif // Wiring_IPv6
	return address.ipv4==that.address.ipv4;
}

size_t IPAddress::printTo(Print& p) const
{
 80a216c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80a216e:	460f      	mov	r7, r1
 80a2170:	f100 0608 	add.w	r6, r0, #8
 80a2174:	1d05      	adds	r5, r0, #4
 80a2176:	2400      	movs	r4, #0
            t = print('-');
            val = -n;
        } else {
            val = n;
        }
        return printNumber(val, base) + t;
 80a2178:	f816 1d01 	ldrb.w	r1, [r6, #-1]!
 80a217c:	220a      	movs	r2, #10
 80a217e:	4638      	mov	r0, r7
 80a2180:	f001 f92d 	bl	80a33de <_ZN5Print11printNumberEmh>
#else
#pragma message "HAL_USE_INET_HAL_POSIX is required for IPv6 support in IPAddress::printTo()"
#endif // HAL_USE_INET_HAL_POSIX
#endif // Wiring_IPv6
    size_t n = 0;
    for (int i = 0; i < 4; i++)
 80a2184:	42ae      	cmp	r6, r5
    {
        if (n)
            n += p.print('.');
        n += p.print((*this)[i], DEC);
 80a2186:	4404      	add	r4, r0
#else
#pragma message "HAL_USE_INET_HAL_POSIX is required for IPv6 support in IPAddress::printTo()"
#endif // HAL_USE_INET_HAL_POSIX
#endif // Wiring_IPv6
    size_t n = 0;
    for (int i = 0; i < 4; i++)
 80a2188:	d007      	beq.n	80a219a <_ZNK9IPAddress7printToER5Print+0x2e>
    {
        if (n)
 80a218a:	2c00      	cmp	r4, #0
 80a218c:	d0f4      	beq.n	80a2178 <_ZNK9IPAddress7printToER5Print+0xc>
            n += p.print('.');
 80a218e:	212e      	movs	r1, #46	; 0x2e
 80a2190:	4638      	mov	r0, r7
 80a2192:	f001 f915 	bl	80a33c0 <_ZN5Print5printEc>
 80a2196:	4404      	add	r4, r0
 80a2198:	e7ee      	b.n	80a2178 <_ZNK9IPAddress7printToER5Print+0xc>
        n += p.print((*this)[i], DEC);
    }
    return n;
}
 80a219a:	4620      	mov	r0, r4
 80a219c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	...

080a21a0 <_ZN9IPAddressC1Ev>:

#if HAL_USE_INET_HAL_POSIX
#include <arpa/inet.h>
#endif // HAL_USE_INET_HAL_POSIX

IPAddress::IPAddress()
 80a21a0:	b510      	push	{r4, lr}
 80a21a2:	4604      	mov	r4, r0
 80a21a4:	4b04      	ldr	r3, [pc, #16]	; (80a21b8 <_ZN9IPAddressC1Ev+0x18>)
        return address;
    }

    virtual size_t printTo(Print& p) const;

    void clear() { memset(&address, 0, sizeof (address)); }
 80a21a6:	2211      	movs	r2, #17
 80a21a8:	f840 3b04 	str.w	r3, [r0], #4
 80a21ac:	2100      	movs	r1, #0
 80a21ae:	f001 fdab 	bl	80a3d08 <memset>
{
    clear();
}
 80a21b2:	4620      	mov	r0, r4
 80a21b4:	bd10      	pop	{r4, pc}
 80a21b6:	bf00      	nop
 80a21b8:	080a4b48 	.word	0x080a4b48

080a21bc <_ZN9IPAddressC1ERK16_HAL_IPAddress_t>:

IPAddress::IPAddress(const HAL_IPAddress& address)
 80a21bc:	4603      	mov	r3, r0
 80a21be:	4a07      	ldr	r2, [pc, #28]	; (80a21dc <_ZN9IPAddressC1ERK16_HAL_IPAddress_t+0x20>)
 80a21c0:	b510      	push	{r4, lr}
 80a21c2:	f843 2b04 	str.w	r2, [r3], #4
{
    memcpy(&this->address, &address, sizeof(address));
 80a21c6:	f101 0210 	add.w	r2, r1, #16
 80a21ca:	f851 4b04 	ldr.w	r4, [r1], #4
 80a21ce:	4291      	cmp	r1, r2
 80a21d0:	f843 4b04 	str.w	r4, [r3], #4
 80a21d4:	d1f9      	bne.n	80a21ca <_ZN9IPAddressC1ERK16_HAL_IPAddress_t+0xe>
 80a21d6:	780a      	ldrb	r2, [r1, #0]
 80a21d8:	701a      	strb	r2, [r3, #0]
}
 80a21da:	bd10      	pop	{r4, pc}
 80a21dc:	080a4b48 	.word	0x080a4b48

080a21e0 <_ZN9IPAddressC1Em>:
IPAddress::IPAddress(uint8_t first_octet, uint8_t second_octet, uint8_t third_octet, uint8_t fourth_octet)
{
    set_ipv4(first_octet, second_octet, third_octet, fourth_octet);
}

IPAddress::IPAddress(uint32_t address)
 80a21e0:	4a02      	ldr	r2, [pc, #8]	; (80a21ec <_ZN9IPAddressC1Em+0xc>)
    return *this;
}

IPAddress& IPAddress::operator=(uint32_t ipv4)
{
    address.ipv4 = ipv4;
 80a21e2:	6041      	str	r1, [r0, #4]
IPAddress::IPAddress(uint8_t first_octet, uint8_t second_octet, uint8_t third_octet, uint8_t fourth_octet)
{
    set_ipv4(first_octet, second_octet, third_octet, fourth_octet);
}

IPAddress::IPAddress(uint32_t address)
 80a21e4:	6002      	str	r2, [r0, #0]
        return &address;
    }

    inline void setVersion(uint8_t version) {
#if HAL_IPv6
        address.v = version;
 80a21e6:	2204      	movs	r2, #4
 80a21e8:	7502      	strb	r2, [r0, #20]
{
    *this = address;
}
 80a21ea:	4770      	bx	lr
 80a21ec:	080a4b48 	.word	0x080a4b48

080a21f0 <_ZN9IPAddress8set_ipv4Ehhhh>:
    return address.ipv4!=0;
#endif
}

void IPAddress::set_ipv4(uint8_t b0, uint8_t b1, uint8_t b2, uint8_t b3)
{
 80a21f0:	b510      	push	{r4, lr}
    address.ipv4 = b0<<24 | b1 << 16 | b2 << 8 | b3;
 80a21f2:	f89d 4008 	ldrb.w	r4, [sp, #8]
 80a21f6:	ea44 2303 	orr.w	r3, r4, r3, lsl #8
 80a21fa:	ea43 4202 	orr.w	r2, r3, r2, lsl #16
 80a21fe:	ea42 6101 	orr.w	r1, r2, r1, lsl #24
 80a2202:	2304      	movs	r3, #4
 80a2204:	6041      	str	r1, [r0, #4]
 80a2206:	7503      	strb	r3, [r0, #20]
 80a2208:	bd10      	pop	{r4, pc}
	...

080a220c <_ZN9IPAddressC1Ehhhh>:
{
    memcpy(&this->address, &address, sizeof(address));
}


IPAddress::IPAddress(uint8_t first_octet, uint8_t second_octet, uint8_t third_octet, uint8_t fourth_octet)
 80a220c:	b537      	push	{r0, r1, r2, r4, r5, lr}
 80a220e:	4d04      	ldr	r5, [pc, #16]	; (80a2220 <_ZN9IPAddressC1Ehhhh+0x14>)
 80a2210:	6005      	str	r5, [r0, #0]
{
    set_ipv4(first_octet, second_octet, third_octet, fourth_octet);
 80a2212:	f89d 5018 	ldrb.w	r5, [sp, #24]
 80a2216:	9500      	str	r5, [sp, #0]
 80a2218:	f7ff ffea 	bl	80a21f0 <_ZN9IPAddress8set_ipv4Ehhhh>
}
 80a221c:	b003      	add	sp, #12
 80a221e:	bd30      	pop	{r4, r5, pc}
 80a2220:	080a4b48 	.word	0x080a4b48

080a2224 <_ZNSt14_Function_baseD1Ev>:
	}
      };

    _Function_base() : _M_manager(nullptr) { }

    ~_Function_base()
 80a2224:	b510      	push	{r4, lr}
    {
      if (_M_manager)
 80a2226:	6883      	ldr	r3, [r0, #8]
	}
      };

    _Function_base() : _M_manager(nullptr) { }

    ~_Function_base()
 80a2228:	4604      	mov	r4, r0
    {
      if (_M_manager)
 80a222a:	b113      	cbz	r3, 80a2232 <_ZNSt14_Function_baseD1Ev+0xe>
	_M_manager(_M_functor, _M_functor, __destroy_functor);
 80a222c:	2203      	movs	r2, #3
 80a222e:	4601      	mov	r1, r0
 80a2230:	4798      	blx	r3
    }
 80a2232:	4620      	mov	r0, r4
 80a2234:	bd10      	pop	{r4, pc}

080a2236 <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EEC1ERKS2_>:
	if (_M_pi != nullptr)
	  _M_pi->_M_release();
      }

      __shared_count(const __shared_count& __r) noexcept
      : _M_pi(__r._M_pi)
 80a2236:	680b      	ldr	r3, [r1, #0]
 80a2238:	6003      	str	r3, [r0, #0]
      {
	if (_M_pi != 0)
 80a223a:	b113      	cbz	r3, 80a2242 <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EEC1ERKS2_+0xc>
    }

  template<>
    inline void
    _Sp_counted_base<_S_single>::_M_add_ref_copy()
    { ++_M_use_count; }
 80a223c:	685a      	ldr	r2, [r3, #4]
 80a223e:	3201      	adds	r2, #1
 80a2240:	605a      	str	r2, [r3, #4]
      __shared_count(const __shared_count& __r) noexcept
      : _M_pi(__r._M_pi)
      {
	if (_M_pi != 0)
	  _M_pi->_M_add_ref_copy();
      }
 80a2242:	4770      	bx	lr

080a2244 <delay>:
    return (value - fromStart) * (toEnd - toStart) / (fromEnd - fromStart) + toStart;
}

void delay(unsigned long ms)
{
    system_delay_ms(ms, false);
 80a2244:	2100      	movs	r1, #0
 80a2246:	f7ff bb5f 	b.w	80a1908 <system_delay_ms>
	...

080a224c <serialEventRun>:

/**
 * Provides background processing of serial data.
 */
void serialEventRun()
{
 80a224c:	b508      	push	{r3, lr}
    if (serialEvent && Serial.available()>0)
 80a224e:	4b14      	ldr	r3, [pc, #80]	; (80a22a0 <serialEventRun+0x54>)
 80a2250:	b133      	cbz	r3, 80a2260 <serialEventRun+0x14>
 80a2252:	f7ff ff21 	bl	80a2098 <_Z16_fetch_usbserialv>
 80a2256:	6803      	ldr	r3, [r0, #0]
 80a2258:	691b      	ldr	r3, [r3, #16]
 80a225a:	4798      	blx	r3
 80a225c:	2800      	cmp	r0, #0
 80a225e:	dc16      	bgt.n	80a228e <serialEventRun+0x42>
        serialEvent();

    if (serialEvent1 && Serial1.available()>0)
 80a2260:	4b10      	ldr	r3, [pc, #64]	; (80a22a4 <serialEventRun+0x58>)
 80a2262:	b133      	cbz	r3, 80a2272 <serialEventRun+0x26>
 80a2264:	f001 f97a 	bl	80a355c <_Z22__fetch_global_Serial1v>
 80a2268:	6803      	ldr	r3, [r0, #0]
 80a226a:	691b      	ldr	r3, [r3, #16]
 80a226c:	4798      	blx	r3
 80a226e:	2800      	cmp	r0, #0
 80a2270:	dc10      	bgt.n	80a2294 <serialEventRun+0x48>
        serialEvent1();

#if Wiring_Serial2
    if (serialEventRun2) serialEventRun2();
 80a2272:	4b0d      	ldr	r3, [pc, #52]	; (80a22a8 <serialEventRun+0x5c>)
 80a2274:	b10b      	cbz	r3, 80a227a <serialEventRun+0x2e>
 80a2276:	f3af 8000 	nop.w
#if Wiring_Serial5
    if (serialEventRun5) serialEventRun5();
#endif

#if Wiring_USBSerial1
    if (usbSerialEvent1 && USBSerial1.available()>0)
 80a227a:	4b0c      	ldr	r3, [pc, #48]	; (80a22ac <serialEventRun+0x60>)
 80a227c:	b17b      	cbz	r3, 80a229e <serialEventRun+0x52>
 80a227e:	f7ff ff47 	bl	80a2110 <_Z17_fetch_usbserial1v>
 80a2282:	6803      	ldr	r3, [r0, #0]
 80a2284:	691b      	ldr	r3, [r3, #16]
 80a2286:	4798      	blx	r3
 80a2288:	2800      	cmp	r0, #0
 80a228a:	dc06      	bgt.n	80a229a <serialEventRun+0x4e>
 80a228c:	bd08      	pop	{r3, pc}
 * Provides background processing of serial data.
 */
void serialEventRun()
{
    if (serialEvent && Serial.available()>0)
        serialEvent();
 80a228e:	f3af 8000 	nop.w
 80a2292:	e7e5      	b.n	80a2260 <serialEventRun+0x14>

    if (serialEvent1 && Serial1.available()>0)
        serialEvent1();
 80a2294:	f3af 8000 	nop.w
 80a2298:	e7eb      	b.n	80a2272 <serialEventRun+0x26>
    if (serialEventRun5) serialEventRun5();
#endif

#if Wiring_USBSerial1
    if (usbSerialEvent1 && USBSerial1.available()>0)
        usbSerialEvent1();
 80a229a:	f3af 8000 	nop.w
 80a229e:	bd08      	pop	{r3, pc}
	...

080a22b0 <_post_loop>:
#if Wiring_Serial5
void serialEvent5() __attribute__((weak));
#endif

void _post_loop()
{
 80a22b0:	b508      	push	{r3, lr}
	serialEventRun();
 80a22b2:	f7ff ffcb 	bl	80a224c <serialEventRun>
		return !timeout_fn;
	}

	static inline system_tick_t current_time()
	{
		return HAL_Timer_Get_Milli_Seconds();
 80a22b6:	f7ff fa4f 	bl	80a1758 <HAL_Timer_Get_Milli_Seconds>
	/**
	 * Lifesign that the application is still working normally.
	 */
	static void checkin()
	{
		last_checkin = current_time();
 80a22ba:	4b01      	ldr	r3, [pc, #4]	; (80a22c0 <_post_loop+0x10>)
 80a22bc:	6018      	str	r0, [r3, #0]
 80a22be:	bd08      	pop	{r3, pc}
 80a22c0:	2000061c 	.word	0x2000061c

080a22c4 <_Z33system_initialize_user_backup_ramv>:
 * the dynamically linked application module.
 */
void system_initialize_user_backup_ram()
{
    size_t len = &link_global_retained_end-&link_global_retained_start;
    memcpy(&link_global_retained_start, &link_global_retained_initial_values, len);
 80a22c4:	4802      	ldr	r0, [pc, #8]	; (80a22d0 <_Z33system_initialize_user_backup_ramv+0xc>)
 80a22c6:	4a03      	ldr	r2, [pc, #12]	; (80a22d4 <_Z33system_initialize_user_backup_ramv+0x10>)
 80a22c8:	4903      	ldr	r1, [pc, #12]	; (80a22d8 <_Z33system_initialize_user_backup_ramv+0x14>)
 80a22ca:	1a12      	subs	r2, r2, r0
 80a22cc:	f001 bcf6 	b.w	80a3cbc <memcpy>
 80a22d0:	40024000 	.word	0x40024000
 80a22d4:	40024004 	.word	0x40024004
 80a22d8:	080a4ed0 	.word	0x080a4ed0

080a22dc <_Z27ctrl_request_custom_handlerP12ctrl_request>:
bool __backup_ram_was_valid() { return false; }

#endif

// Default handler for CTRL_REQUEST_APP_CUSTOM requests
void __attribute((weak)) ctrl_request_custom_handler(ctrl_request* req) {
 80a22dc:	b507      	push	{r0, r1, r2, lr}
    system_ctrl_set_result(req, SYSTEM_ERROR_NOT_SUPPORTED, nullptr, nullptr, nullptr);
 80a22de:	2300      	movs	r3, #0
 80a22e0:	9300      	str	r3, [sp, #0]
 80a22e2:	461a      	mov	r2, r3
 80a22e4:	f06f 0177 	mvn.w	r1, #119	; 0x77
 80a22e8:	f7ff fb20 	bl	80a192c <system_ctrl_set_result>
}
 80a22ec:	b003      	add	sp, #12
 80a22ee:	f85d fb04 	ldr.w	pc, [sp], #4
	...

080a22f4 <_ZL20ctrl_request_handlerP12ctrl_request>:
// Callback invoked to process a logging configuration request
void(*log_process_ctrl_request_callback)(ctrl_request* req) = nullptr;
#endif

// Application handler for control requests
static void ctrl_request_handler(ctrl_request* req) {
 80a22f4:	b507      	push	{r0, r1, r2, lr}
    switch (req->type) {
 80a22f6:	8843      	ldrh	r3, [r0, #2]
 80a22f8:	2b0a      	cmp	r3, #10
 80a22fa:	d008      	beq.n	80a230e <_ZL20ctrl_request_handlerP12ctrl_request+0x1a>
 80a22fc:	2b50      	cmp	r3, #80	; 0x50
 80a22fe:	d109      	bne.n	80a2314 <_ZL20ctrl_request_handlerP12ctrl_request+0x20>
#if Wiring_LogConfig
    case CTRL_REQUEST_LOG_CONFIG: {
        if (log_process_ctrl_request_callback) {
 80a2300:	4b09      	ldr	r3, [pc, #36]	; (80a2328 <_ZL20ctrl_request_handlerP12ctrl_request+0x34>)
 80a2302:	681b      	ldr	r3, [r3, #0]
 80a2304:	b13b      	cbz	r3, 80a2316 <_ZL20ctrl_request_handlerP12ctrl_request+0x22>
    }
    default:
        system_ctrl_set_result(req, SYSTEM_ERROR_NOT_SUPPORTED, nullptr, nullptr, nullptr);
        break;
    }
}
 80a2306:	b003      	add	sp, #12
 80a2308:	f85d eb04 	ldr.w	lr, [sp], #4
static void ctrl_request_handler(ctrl_request* req) {
    switch (req->type) {
#if Wiring_LogConfig
    case CTRL_REQUEST_LOG_CONFIG: {
        if (log_process_ctrl_request_callback) {
            log_process_ctrl_request_callback(req);
 80a230c:	4718      	bx	r3
        }
        break;
    }
#endif
    case CTRL_REQUEST_APP_CUSTOM: {
        ctrl_request_custom_handler(req);
 80a230e:	f7ff ffe5 	bl	80a22dc <_Z27ctrl_request_custom_handlerP12ctrl_request>
        break;
 80a2312:	e006      	b.n	80a2322 <_ZL20ctrl_request_handlerP12ctrl_request+0x2e>
    }
    default:
        system_ctrl_set_result(req, SYSTEM_ERROR_NOT_SUPPORTED, nullptr, nullptr, nullptr);
 80a2314:	2300      	movs	r3, #0
 80a2316:	9300      	str	r3, [sp, #0]
 80a2318:	461a      	mov	r2, r3
 80a231a:	f06f 0177 	mvn.w	r1, #119	; 0x77
 80a231e:	f7ff fb05 	bl	80a192c <system_ctrl_set_result>
        break;
    }
}
 80a2322:	b003      	add	sp, #12
 80a2324:	f85d fb04 	ldr.w	pc, [sp], #4
 80a2328:	2000046c 	.word	0x2000046c

080a232c <module_user_init_hook>:

void module_user_init_hook()
{
 80a232c:	b538      	push	{r3, r4, r5, lr}
#if HAL_PLATFORM_BACKUP_RAM
    backup_ram_was_valid_ =  __backup_sram_signature==signature;
 80a232e:	4c10      	ldr	r4, [pc, #64]	; (80a2370 <module_user_init_hook+0x44>)
 80a2330:	4d10      	ldr	r5, [pc, #64]	; (80a2374 <module_user_init_hook+0x48>)
 80a2332:	6823      	ldr	r3, [r4, #0]
 80a2334:	42ab      	cmp	r3, r5
 80a2336:	4b10      	ldr	r3, [pc, #64]	; (80a2378 <module_user_init_hook+0x4c>)
 80a2338:	bf0c      	ite	eq
 80a233a:	2201      	moveq	r2, #1
 80a233c:	2200      	movne	r2, #0
 80a233e:	701a      	strb	r2, [r3, #0]
    if (!backup_ram_was_valid_) {
 80a2340:	d002      	beq.n	80a2348 <module_user_init_hook+0x1c>
        system_initialize_user_backup_ram();
 80a2342:	f7ff ffbf 	bl	80a22c4 <_Z33system_initialize_user_backup_ramv>
        __backup_sram_signature = signature;
 80a2346:	6025      	str	r5, [r4, #0]
    }
#endif

#if HAL_PLATFORM_RNG
    // Initialize the default stdlib PRNG using hardware RNG as a seed
    const uint32_t seed = HAL_RNG_GetRandomNumber();
 80a2348:	f7ff f9f6 	bl	80a1738 <HAL_RNG_GetRandomNumber>
 80a234c:	4604      	mov	r4, r0
    srand(seed);
 80a234e:	f001 fce3 	bl	80a3d18 <srand>

    // If the user defines random_seed_from_cloud, call it with a seed value
    // generated by a hardware RNG as well.
    if (random_seed_from_cloud) {
 80a2352:	4b0a      	ldr	r3, [pc, #40]	; (80a237c <module_user_init_hook+0x50>)
 80a2354:	b113      	cbz	r3, 80a235c <module_user_init_hook+0x30>
        random_seed_from_cloud(seed);
 80a2356:	4620      	mov	r0, r4
 80a2358:	f3af 8000 	nop.w
    }
#endif
    // Register the random_seed_from_cloud handler
    spark_set_random_seed_from_cloud_handler(&random_seed_from_cloud, nullptr);
 80a235c:	2100      	movs	r1, #0
 80a235e:	4807      	ldr	r0, [pc, #28]	; (80a237c <module_user_init_hook+0x50>)
 80a2360:	f7ff fa72 	bl	80a1848 <spark_set_random_seed_from_cloud_handler>

    // Register application handler for the control requests
    system_ctrl_set_app_request_handler(ctrl_request_handler, nullptr);
}
 80a2364:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
#endif
    // Register the random_seed_from_cloud handler
    spark_set_random_seed_from_cloud_handler(&random_seed_from_cloud, nullptr);

    // Register application handler for the control requests
    system_ctrl_set_app_request_handler(ctrl_request_handler, nullptr);
 80a2368:	2100      	movs	r1, #0
 80a236a:	4805      	ldr	r0, [pc, #20]	; (80a2380 <module_user_init_hook+0x54>)
 80a236c:	f7ff bad4 	b.w	80a1918 <system_ctrl_set_app_request_handler>
 80a2370:	40024000 	.word	0x40024000
 80a2374:	9a271c1e 	.word	0x9a271c1e
 80a2378:	20000470 	.word	0x20000470
 80a237c:	00000000 	.word	0x00000000
 80a2380:	080a22f5 	.word	0x080a22f5

080a2384 <_ZN8RGBClassD1Ev>:
#include "rgbled.h"

typedef void (raw_rgb_change_handler_t)(uint8_t, uint8_t, uint8_t);
typedef std::function<raw_rgb_change_handler_t> wiring_rgb_change_handler_t;

class RGBClass {
 80a2384:	b510      	push	{r4, lr}
 80a2386:	4604      	mov	r4, r0
   *  @ingroup functors
   *
   *  Polymorphic function wrapper.
   */
  template<typename _Res, typename... _ArgTypes>
    class function<_Res(_ArgTypes...)>
 80a2388:	f7ff ff4c 	bl	80a2224 <_ZNSt14_Function_baseD1Ev>
 80a238c:	4620      	mov	r0, r4
 80a238e:	bd10      	pop	{r4, pc}

080a2390 <_GLOBAL__sub_I_RGB>:
	{
	  _Base::_M_init_functor(__functor, std::__addressof(__f.get()));
	}
      };

    _Function_base() : _M_manager(nullptr) { }
 80a2390:	4803      	ldr	r0, [pc, #12]	; (80a23a0 <_GLOBAL__sub_I_RGB+0x10>)
 80a2392:	2300      	movs	r3, #0
 80a2394:	6083      	str	r3, [r0, #8]
#include "spark_wiring_rgb.h"
#include "spark_wiring_interrupts.h"

#include "core_hal.h"

RGBClass RGB;
 80a2396:	4a03      	ldr	r2, [pc, #12]	; (80a23a4 <_GLOBAL__sub_I_RGB+0x14>)
 80a2398:	4903      	ldr	r1, [pc, #12]	; (80a23a8 <_GLOBAL__sub_I_RGB+0x18>)
 80a239a:	f001 bb17 	b.w	80a39cc <__aeabi_atexit>
 80a239e:	bf00      	nop
 80a23a0:	20000474 	.word	0x20000474
 80a23a4:	20000074 	.word	0x20000074
 80a23a8:	080a2385 	.word	0x080a2385

080a23ac <_GLOBAL__sub_I_TIME_FORMAT_DEFAULT>:
            calendar_time_cache = Convert_UnixTime_To_CalendarTime(unix_time);
            unix_time_cache = unix_time;
    }
}

const char* TimeClass::format_spec = TIME_FORMAT_DEFAULT;
 80a23ac:	4b02      	ldr	r3, [pc, #8]	; (80a23b8 <_GLOBAL__sub_I_TIME_FORMAT_DEFAULT+0xc>)
 80a23ae:	681a      	ldr	r2, [r3, #0]
 80a23b0:	4b02      	ldr	r3, [pc, #8]	; (80a23bc <_GLOBAL__sub_I_TIME_FORMAT_DEFAULT+0x10>)
 80a23b2:	601a      	str	r2, [r3, #0]
 80a23b4:	4770      	bx	lr
 80a23b6:	bf00      	nop
 80a23b8:	20000000 	.word	0x20000000
 80a23bc:	20000484 	.word	0x20000484

080a23c0 <_ZN5spark16JSONStreamWriter5writeEPKcj>:
inline Print* spark::JSONStreamWriter::stream() const {
    return &strm_;
}

inline void spark::JSONStreamWriter::write(const char *data, size_t size) {
    strm_.write((const uint8_t*)data, size);
 80a23c0:	6880      	ldr	r0, [r0, #8]
 80a23c2:	6803      	ldr	r3, [r0, #0]
 80a23c4:	68db      	ldr	r3, [r3, #12]
 80a23c6:	4718      	bx	r3

080a23c8 <_ZN5spark20JSONStreamLogHandler5writeEPKcj>:
inline void spark::StreamLogHandler::printf(const char *fmt, ArgsT... args) {
    stream_->printf(fmt, args...);
}

// spark::JSONStreamLogHandler
inline void spark::JSONStreamLogHandler::write(const char *data, size_t size) {
 80a23c8:	4770      	bx	lr

080a23ca <_ZN5spark17LogHandlerFactory14destroyHandlerEPNS_10LogHandlerE>:

#if Wiring_LogConfig

// spark::LogHandlerFactory
inline void spark::LogHandlerFactory::destroyHandler(LogHandler *handler) {
    delete handler;
 80a23ca:	b119      	cbz	r1, 80a23d4 <_ZN5spark17LogHandlerFactory14destroyHandlerEPNS_10LogHandlerE+0xa>
 80a23cc:	680b      	ldr	r3, [r1, #0]
 80a23ce:	4608      	mov	r0, r1
 80a23d0:	685b      	ldr	r3, [r3, #4]
 80a23d2:	4718      	bx	r3
 80a23d4:	4770      	bx	lr

080a23d6 <_ZN5spark19OutputStreamFactory13destroyStreamEP5Print>:
}

// spark::OutputStreamFactory
inline void spark::OutputStreamFactory::destroyStream(Print *stream) {
    delete stream;
 80a23d6:	b119      	cbz	r1, 80a23e0 <_ZN5spark19OutputStreamFactory13destroyStreamEP5Print+0xa>
 80a23d8:	680b      	ldr	r3, [r1, #0]
 80a23da:	4608      	mov	r0, r1
 80a23dc:	685b      	ldr	r3, [r3, #4]
 80a23de:	4718      	bx	r3
 80a23e0:	4770      	bx	lr

080a23e2 <_ZN5spark26DefaultOutputStreamFactoryD1Ev>:

    virtual Print* createStream(const char *type, const JSONValue &params) = 0;
    virtual void destroyStream(Print *stream);
};

class DefaultOutputStreamFactory: public OutputStreamFactory {
 80a23e2:	4770      	bx	lr

080a23e4 <_ZN5spark24DefaultLogHandlerFactoryD1Ev>:
    virtual LogHandler* createHandler(const char *type, LogLevel level, LogCategoryFilters filters, Print *stream,
            const JSONValue &params) = 0; // TODO: Use some generic container or a buffer instead of JSONValue
    virtual void destroyHandler(LogHandler *handler);
};

class DefaultLogHandlerFactory: public LogHandlerFactory {
 80a23e4:	4770      	bx	lr

080a23e6 <_ZN5spark16JSONStreamWriterD1Ev>:
    void writeSeparator();
    void writeEscaped(const char *data, size_t size);
    void write(char c);
};

class JSONStreamWriter: public JSONWriter {
 80a23e6:	4770      	bx	lr

080a23e8 <_ZN12_GLOBAL__N_119nextSubcategoryNameERPKcRj>:
    return s;
}
#endif

// Iterates over subcategory names separated by '.' character
const char* nextSubcategoryName(const char* &category, size_t &size) {
 80a23e8:	b538      	push	{r3, r4, r5, lr}
 80a23ea:	4604      	mov	r4, r0
 80a23ec:	460d      	mov	r5, r1
    const char *s = strchrnul(category, '.');
 80a23ee:	6800      	ldr	r0, [r0, #0]
 80a23f0:	212e      	movs	r1, #46	; 0x2e
 80a23f2:	f001 fcc7 	bl	80a3d84 <strchrnul>
    size = s - category;
 80a23f6:	6823      	ldr	r3, [r4, #0]
 80a23f8:	1ac3      	subs	r3, r0, r3
 80a23fa:	602b      	str	r3, [r5, #0]
    if (size) {
 80a23fc:	b123      	cbz	r3, 80a2408 <_ZN12_GLOBAL__N_119nextSubcategoryNameERPKcRj+0x20>
        if (*s) {
 80a23fe:	7803      	ldrb	r3, [r0, #0]
 80a2400:	b103      	cbz	r3, 80a2404 <_ZN12_GLOBAL__N_119nextSubcategoryNameERPKcRj+0x1c>
            ++s;
 80a2402:	3001      	adds	r0, #1
    {
      // concept requirements
      __glibcxx_function_requires(_SGIAssignableConcept<_Tp>)

      _Tp __tmp = _GLIBCXX_MOVE(__a);
      __a = _GLIBCXX_MOVE(__b);
 80a2404:	6823      	ldr	r3, [r4, #0]
      __b = _GLIBCXX_MOVE(__tmp);
 80a2406:	6020      	str	r0, [r4, #0]
        }
        std::swap(s, category);
        return s;
    }
    return nullptr;
 80a2408:	4618      	mov	r0, r3
}
 80a240a:	bd38      	pop	{r3, r4, r5, pc}

080a240c <_ZN5spark16JSONStreamWriterD0Ev>:
 80a240c:	b510      	push	{r4, lr}
 80a240e:	4604      	mov	r4, r0
 80a2410:	210c      	movs	r1, #12
 80a2412:	f001 fae9 	bl	80a39e8 <_ZdlPvj>
 80a2416:	4620      	mov	r0, r4
 80a2418:	bd10      	pop	{r4, pc}

080a241a <_ZN5spark24DefaultLogHandlerFactoryD0Ev>:
 80a241a:	b510      	push	{r4, lr}
 80a241c:	4604      	mov	r4, r0
 80a241e:	2104      	movs	r1, #4
 80a2420:	f001 fae2 	bl	80a39e8 <_ZdlPvj>
 80a2424:	4620      	mov	r0, r4
 80a2426:	bd10      	pop	{r4, pc}

080a2428 <_ZN5spark26DefaultOutputStreamFactoryD0Ev>:

    virtual Print* createStream(const char *type, const JSONValue &params) = 0;
    virtual void destroyStream(Print *stream);
};

class DefaultOutputStreamFactory: public OutputStreamFactory {
 80a2428:	b510      	push	{r4, lr}
 80a242a:	4604      	mov	r4, r0
 80a242c:	2104      	movs	r1, #4
 80a242e:	f001 fadb 	bl	80a39e8 <_ZdlPvj>
 80a2432:	4620      	mov	r0, r4
 80a2434:	bd10      	pop	{r4, pc}

080a2436 <_ZN5spark26DefaultOutputStreamFactory13destroyStreamEP5Print>:
    }
#endif // PLATFORM_ID != 3
    return nullptr;
}

void spark::DefaultOutputStreamFactory::destroyStream(Print *stream) {
 80a2436:	b538      	push	{r3, r4, r5, lr}
 80a2438:	460c      	mov	r4, r1
 80a243a:	4605      	mov	r5, r0
#if PLATFORM_ID != 3
    if (stream == &Serial) {
 80a243c:	f7ff fe2c 	bl	80a2098 <_Z16_fetch_usbserialv>
 80a2440:	4284      	cmp	r4, r0
 80a2442:	d102      	bne.n	80a244a <_ZN5spark26DefaultOutputStreamFactory13destroyStreamEP5Print+0x14>
        // FIXME: Uninitializing Serial detaches a Gen 3 device from the host
#if !HAL_PLATFORM_NRF52840
        Serial.end();
 80a2444:	f7ff fe28 	bl	80a2098 <_Z16_fetch_usbserialv>
 80a2448:	e005      	b.n	80a2456 <_ZN5spark26DefaultOutputStreamFactory13destroyStreamEP5Print+0x20>
#endif
        return;
    }
#if Wiring_USBSerial1
    if (stream == &USBSerial1) {
 80a244a:	f7ff fe61 	bl	80a2110 <_Z17_fetch_usbserial1v>
 80a244e:	4284      	cmp	r4, r0
 80a2450:	d105      	bne.n	80a245e <_ZN5spark26DefaultOutputStreamFactory13destroyStreamEP5Print+0x28>
        USBSerial1.end();
 80a2452:	f7ff fe5d 	bl	80a2110 <_Z17_fetch_usbserial1v>
        Serial1.end();
        return;
    }
#endif // PLATFORM_ID != 3
    OutputStreamFactory::destroyStream(stream);
}
 80a2456:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
#endif
        return;
    }
#if Wiring_USBSerial1
    if (stream == &USBSerial1) {
        USBSerial1.end();
 80a245a:	f7ff be03 	b.w	80a2064 <_ZN9USBSerial3endEv>
        return;
    }
#endif
    if (stream == &Serial1) {
 80a245e:	f001 f87d 	bl	80a355c <_Z22__fetch_global_Serial1v>
 80a2462:	4284      	cmp	r4, r0
 80a2464:	d105      	bne.n	80a2472 <_ZN5spark26DefaultOutputStreamFactory13destroyStreamEP5Print+0x3c>
        Serial1.end();
 80a2466:	f001 f879 	bl	80a355c <_Z22__fetch_global_Serial1v>
        return;
    }
#endif // PLATFORM_ID != 3
    OutputStreamFactory::destroyStream(stream);
}
 80a246a:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
        USBSerial1.end();
        return;
    }
#endif
    if (stream == &Serial1) {
        Serial1.end();
 80a246e:	f001 b86e 	b.w	80a354e <_ZN11USARTSerial3endEv>
        return;
    }
#endif // PLATFORM_ID != 3
    OutputStreamFactory::destroyStream(stream);
 80a2472:	4621      	mov	r1, r4
 80a2474:	4628      	mov	r0, r5
 80a2476:	f7ff ffae 	bl	80a23d6 <_ZN5spark19OutputStreamFactory13destroyStreamEP5Print>
 80a247a:	bd38      	pop	{r3, r4, r5, pc}

080a247c <_ZNK5spark10JSONStringeqEPKc.isra.7>:

inline bool spark::JSONString::isEmpty() const {
    return !n_;
}

inline bool spark::JSONString::operator==(const char *str) const {
 80a247c:	b508      	push	{r3, lr}
    return strcmp(s_, str) == 0;
 80a247e:	f001 fc8b 	bl	80a3d98 <strcmp>
}
 80a2482:	fab0 f080 	clz	r0, r0
 80a2486:	0940      	lsrs	r0, r0, #5
 80a2488:	bd08      	pop	{r3, pc}

080a248a <_ZN5spark10JSONWriter5valueEPKc>:

inline spark::JSONWriter& spark::JSONWriter::name(const String &name) {
    return this->name(name.c_str(), name.length());
}

inline spark::JSONWriter& spark::JSONWriter::value(const char *val) {
 80a248a:	b538      	push	{r3, r4, r5, lr}
 80a248c:	4605      	mov	r5, r0
    return value(val, strlen(val));
 80a248e:	4608      	mov	r0, r1

inline spark::JSONWriter& spark::JSONWriter::name(const String &name) {
    return this->name(name.c_str(), name.length());
}

inline spark::JSONWriter& spark::JSONWriter::value(const char *val) {
 80a2490:	460c      	mov	r4, r1
    return value(val, strlen(val));
 80a2492:	f001 fc8b 	bl	80a3dac <strlen>
 80a2496:	4621      	mov	r1, r4
 80a2498:	4602      	mov	r2, r0
 80a249a:	4628      	mov	r0, r5
}
 80a249c:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
inline spark::JSONWriter& spark::JSONWriter::name(const String &name) {
    return this->name(name.c_str(), name.length());
}

inline spark::JSONWriter& spark::JSONWriter::value(const char *val) {
    return value(val, strlen(val));
 80a24a0:	f7ff bbe1 	b.w	80a1c66 <_ZN5spark10JSONWriter5valueEPKcj>

080a24a4 <_ZN14RecursiveMutex4lockEv>:
            os_mutex_recursive_destroy(handle_);
            handle_ = nullptr;
        }
    }

    void lock() { os_mutex_recursive_lock(handle_); }
 80a24a4:	6800      	ldr	r0, [r0, #0]
 80a24a6:	f7ff b937 	b.w	80a1718 <os_mutex_recursive_lock>

080a24aa <_ZN5spark16StreamLogHandler5writeEPKc>:

inline void spark::StreamLogHandler::write(const char *data, size_t size) {
    stream_->write((const uint8_t*)data, size);
}

inline void spark::StreamLogHandler::write(const char *str) {
 80a24aa:	b570      	push	{r4, r5, r6, lr}
 80a24ac:	4604      	mov	r4, r0
    write(str, strlen(str));
 80a24ae:	4608      	mov	r0, r1

inline void spark::StreamLogHandler::write(const char *data, size_t size) {
    stream_->write((const uint8_t*)data, size);
}

inline void spark::StreamLogHandler::write(const char *str) {
 80a24b0:	460d      	mov	r5, r1
    write(str, strlen(str));
 80a24b2:	f001 fc7b 	bl	80a3dac <strlen>
 80a24b6:	6823      	ldr	r3, [r4, #0]
 80a24b8:	4602      	mov	r2, r0
 80a24ba:	4629      	mov	r1, r5
 80a24bc:	4620      	mov	r0, r4
}
 80a24be:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
inline void spark::StreamLogHandler::write(const char *data, size_t size) {
    stream_->write((const uint8_t*)data, size);
}

inline void spark::StreamLogHandler::write(const char *str) {
    write(str, strlen(str));
 80a24c2:	68db      	ldr	r3, [r3, #12]
 80a24c4:	4718      	bx	r3

080a24c6 <_ZN5spark16StreamLogHandler5writeEc>:
}

inline void spark::StreamLogHandler::write(char c) {
 80a24c6:	b513      	push	{r0, r1, r4, lr}
    write(&c, 1);
 80a24c8:	6802      	ldr	r2, [r0, #0]

inline void spark::StreamLogHandler::write(const char *str) {
    write(str, strlen(str));
}

inline void spark::StreamLogHandler::write(char c) {
 80a24ca:	ab02      	add	r3, sp, #8
 80a24cc:	f803 1d01 	strb.w	r1, [r3, #-1]!
    write(&c, 1);
 80a24d0:	68d4      	ldr	r4, [r2, #12]
 80a24d2:	4619      	mov	r1, r3
 80a24d4:	2201      	movs	r2, #1
 80a24d6:	47a0      	blx	r4
}
 80a24d8:	b002      	add	sp, #8
 80a24da:	bd10      	pop	{r4, pc}

080a24dc <_ZN5spark6detail9LogFilter9nodeIndexERKNS_6VectorINS1_4NodeENS_16DefaultAllocatorEEEPKcjRb>:
        }
    }
    return level;
}

int spark::detail::LogFilter::nodeIndex(const Vector<Node> &nodes, const char *name, size_t size, bool &found) {
 80a24dc:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80a24e0:	6807      	ldr	r7, [r0, #0]
 80a24e2:	468b      	mov	fp, r1
               random_access_iterator_tag)
    {
      // concept requirements
      __glibcxx_function_requires(_RandomAccessIteratorConcept<
				  _RandomAccessIterator>)
      return __last - __first;
 80a24e4:	463c      	mov	r4, r7
 80a24e6:	6845      	ldr	r5, [r0, #4]
 80a24e8:	4691      	mov	r9, r2
 80a24ea:	2214      	movs	r2, #20
 80a24ec:	4355      	muls	r5, r2
 80a24ee:	b085      	sub	sp, #20
 80a24f0:	9301      	str	r3, [sp, #4]
 80a24f2:	10ab      	asrs	r3, r5, #2
 80a24f4:	4d18      	ldr	r5, [pc, #96]	; (80a2558 <_ZN5spark6detail9LogFilter9nodeIndexERKNS_6VectorINS1_4NodeENS_16DefaultAllocatorEEEPKcjRb+0x7c>)
              random_access_iterator_tag)
    {
      // concept requirements
      __glibcxx_function_requires(_RandomAccessIteratorConcept<
				  _RandomAccessIterator>)
      __i += __n;
 80a24f6:	9202      	str	r2, [sp, #8]
               random_access_iterator_tag)
    {
      // concept requirements
      __glibcxx_function_requires(_RandomAccessIteratorConcept<
				  _RandomAccessIterator>)
      return __last - __first;
 80a24f8:	435d      	muls	r5, r3
    return std::distance(nodes.begin(), std::lower_bound(nodes.begin(), nodes.end(), std::make_pair(name, size),
            [&found](const Node &node, const std::pair<const char*, size_t> &value) {
                const int cmp = strncmp(node.name, value.first, std::min<size_t>(node.size, value.second));
                if (cmp == 0) {
                    if (node.size == value.second) { // Lengths are equal
                        found = true; // Allows caller code to avoid extra call to strncmp()
 80a24fa:	2301      	movs	r3, #1
      typedef typename iterator_traits<_ForwardIterator>::difference_type
	_DistanceType;

      _DistanceType __len = std::distance(__first, __last);

      while (__len > 0)
 80a24fc:	2d00      	cmp	r5, #0
 80a24fe:	9303      	str	r3, [sp, #12]
 80a2500:	dd23      	ble.n	80a254a <_ZN5spark6detail9LogFilter9nodeIndexERKNS_6VectorINS1_4NodeENS_16DefaultAllocatorEEEPKcjRb+0x6e>
              random_access_iterator_tag)
    {
      // concept requirements
      __glibcxx_function_requires(_RandomAccessIteratorConcept<
				  _RandomAccessIterator>)
      __i += __n;
 80a2502:	9b02      	ldr	r3, [sp, #8]
	{
	  _DistanceType __half = __len >> 1;
 80a2504:	106e      	asrs	r6, r5, #1
 80a2506:	fb03 f006 	mul.w	r0, r3, r6
 80a250a:	eb04 0800 	add.w	r8, r4, r0

int spark::detail::LogFilter::nodeIndex(const Vector<Node> &nodes, const char *name, size_t size, bool &found) {
    // Using binary search to find existent node or suitable position for new node
    return std::distance(nodes.begin(), std::lower_bound(nodes.begin(), nodes.end(), std::make_pair(name, size),
            [&found](const Node &node, const std::pair<const char*, size_t> &value) {
                const int cmp = strncmp(node.name, value.first, std::min<size_t>(node.size, value.second));
 80a250e:	f8b8 a004 	ldrh.w	sl, [r8, #4]
 80a2512:	464a      	mov	r2, r9
 80a2514:	45d1      	cmp	r9, sl
 80a2516:	bf28      	it	cs
 80a2518:	4652      	movcs	r2, sl
 80a251a:	4659      	mov	r1, fp
 80a251c:	5820      	ldr	r0, [r4, r0]
 80a251e:	f001 fc4d 	bl	80a3dbc <strncmp>
                if (cmp == 0) {
 80a2522:	9b03      	ldr	r3, [sp, #12]
 80a2524:	b948      	cbnz	r0, 80a253a <_ZN5spark6detail9LogFilter9nodeIndexERKNS_6VectorINS1_4NodeENS_16DefaultAllocatorEEEPKcjRb+0x5e>
                    if (node.size == value.second) { // Lengths are equal
 80a2526:	45d1      	cmp	r9, sl
 80a2528:	d103      	bne.n	80a2532 <_ZN5spark6detail9LogFilter9nodeIndexERKNS_6VectorINS1_4NodeENS_16DefaultAllocatorEEEPKcjRb+0x56>
                        found = true; // Allows caller code to avoid extra call to strncmp()
 80a252a:	9a01      	ldr	r2, [sp, #4]
 80a252c:	7013      	strb	r3, [r2, #0]
        }
    }
    return level;
}

int spark::detail::LogFilter::nodeIndex(const Vector<Node> &nodes, const char *name, size_t size, bool &found) {
 80a252e:	4635      	mov	r5, r6
 80a2530:	e7e4      	b.n	80a24fc <_ZN5spark6detail9LogFilter9nodeIndexERKNS_6VectorINS1_4NodeENS_16DefaultAllocatorEEEPKcjRb+0x20>
                if (cmp == 0) {
                    if (node.size == value.second) { // Lengths are equal
                        found = true; // Allows caller code to avoid extra call to strncmp()
                        return false;
                    }
                    return node.size < value.second;
 80a2532:	bf8c      	ite	hi
 80a2534:	2001      	movhi	r0, #1
 80a2536:	2000      	movls	r0, #0
 80a2538:	e000      	b.n	80a253c <_ZN5spark6detail9LogFilter9nodeIndexERKNS_6VectorINS1_4NodeENS_16DefaultAllocatorEEEPKcjRb+0x60>
                }
                return cmp < 0;
 80a253a:	0fc0      	lsrs	r0, r0, #31
	  _ForwardIterator __middle = __first;
	  std::advance(__middle, __half);
	  if (__comp(__middle, __val))
 80a253c:	2800      	cmp	r0, #0
 80a253e:	d0f6      	beq.n	80a252e <_ZN5spark6detail9LogFilter9nodeIndexERKNS_6VectorINS1_4NodeENS_16DefaultAllocatorEEEPKcjRb+0x52>
	    {
	      __first = __middle;
	      ++__first;
	      __len = __len - __half - 1;
 80a2540:	1bae      	subs	r6, r5, r6
	  _ForwardIterator __middle = __first;
	  std::advance(__middle, __half);
	  if (__comp(__middle, __val))
	    {
	      __first = __middle;
	      ++__first;
 80a2542:	f108 0414 	add.w	r4, r8, #20
	      __len = __len - __half - 1;
 80a2546:	3e01      	subs	r6, #1
 80a2548:	e7f1      	b.n	80a252e <_ZN5spark6detail9LogFilter9nodeIndexERKNS_6VectorINS1_4NodeENS_16DefaultAllocatorEEEPKcjRb+0x52>
            }));
 80a254a:	1be4      	subs	r4, r4, r7
}
 80a254c:	4802      	ldr	r0, [pc, #8]	; (80a2558 <_ZN5spark6detail9LogFilter9nodeIndexERKNS_6VectorINS1_4NodeENS_16DefaultAllocatorEEEPKcjRb+0x7c>)
                        return false;
                    }
                    return node.size < value.second;
                }
                return cmp < 0;
            }));
 80a254e:	10a4      	asrs	r4, r4, #2
}
 80a2550:	4360      	muls	r0, r4
 80a2552:	b005      	add	sp, #20
 80a2554:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80a2558:	cccccccd 	.word	0xcccccccd

080a255c <_ZNK5spark6detail9LogFilter5levelEPKc>:
}

spark::detail::LogFilter::~LogFilter() {
}

LogLevel spark::detail::LogFilter::level(const char *category) const {
 80a255c:	b5f0      	push	{r4, r5, r6, r7, lr}
    LogLevel level = level_; // Default level
    if (!nodes_.isEmpty() && category) {
 80a255e:	6903      	ldr	r3, [r0, #16]
}

spark::detail::LogFilter::~LogFilter() {
}

LogLevel spark::detail::LogFilter::level(const char *category) const {
 80a2560:	b085      	sub	sp, #20
 80a2562:	9101      	str	r1, [sp, #4]
    LogLevel level = level_; // Default level
 80a2564:	7e06      	ldrb	r6, [r0, #24]
    if (!nodes_.isEmpty() && category) {
 80a2566:	b313      	cbz	r3, 80a25ae <_ZNK5spark6detail9LogFilter5levelEPKc+0x52>
 80a2568:	b309      	cbz	r1, 80a25ae <_ZNK5spark6detail9LogFilter5levelEPKc+0x52>
        const Vector<Node> *pNodes = &nodes_; // Root nodes
        const char *name = nullptr; // Subcategory name
        size_t size = 0; // Name length
 80a256a:	2300      	movs	r3, #0
        while ((name = nextSubcategoryName(category, size))) {
            bool found = false;
 80a256c:	461d      	mov	r5, r3
LogLevel spark::detail::LogFilter::level(const char *category) const {
    LogLevel level = level_; // Default level
    if (!nodes_.isEmpty() && category) {
        const Vector<Node> *pNodes = &nodes_; // Root nodes
        const char *name = nullptr; // Subcategory name
        size_t size = 0; // Name length
 80a256e:	af04      	add	r7, sp, #16
}

LogLevel spark::detail::LogFilter::level(const char *category) const {
    LogLevel level = level_; // Default level
    if (!nodes_.isEmpty() && category) {
        const Vector<Node> *pNodes = &nodes_; // Root nodes
 80a2570:	f100 040c 	add.w	r4, r0, #12
        const char *name = nullptr; // Subcategory name
        size_t size = 0; // Name length
 80a2574:	f847 3d04 	str.w	r3, [r7, #-4]!
        while ((name = nextSubcategoryName(category, size))) {
 80a2578:	4639      	mov	r1, r7
 80a257a:	a801      	add	r0, sp, #4
 80a257c:	f7ff ff34 	bl	80a23e8 <_ZN12_GLOBAL__N_119nextSubcategoryNameERPKcRj>
 80a2580:	4601      	mov	r1, r0
 80a2582:	b1a0      	cbz	r0, 80a25ae <_ZNK5spark6detail9LogFilter5levelEPKc+0x52>
            bool found = false;
 80a2584:	ab04      	add	r3, sp, #16
 80a2586:	f803 5d05 	strb.w	r5, [r3, #-5]!
            const int index = nodeIndex(*pNodes, name, size, found);
 80a258a:	9a03      	ldr	r2, [sp, #12]
 80a258c:	4620      	mov	r0, r4
 80a258e:	f7ff ffa5 	bl	80a24dc <_ZN5spark6detail9LogFilter9nodeIndexERKNS_6VectorINS1_4NodeENS_16DefaultAllocatorEEEPKcjRb>
            if (!found) {
 80a2592:	f89d 300b 	ldrb.w	r3, [sp, #11]
 80a2596:	b153      	cbz	r3, 80a25ae <_ZNK5spark6detail9LogFilter5levelEPKc+0x52>
    return data_[i];
}

template<typename T, typename AllocatorT>
inline const T& spark::Vector<T, AllocatorT>::at(int i) const {
    return data_[i];
 80a2598:	6823      	ldr	r3, [r4, #0]
 80a259a:	2414      	movs	r4, #20
 80a259c:	fb04 3400 	mla	r4, r4, r0, r3
                break;
            }
            const Node &node = pNodes->at(index);
            if (node.level >= 0) {
 80a25a0:	f9b4 3006 	ldrsh.w	r3, [r4, #6]
                level = (LogLevel)node.level;
            }
            pNodes = &node.nodes;
 80a25a4:	3408      	adds	r4, #8
            const int index = nodeIndex(*pNodes, name, size, found);
            if (!found) {
                break;
            }
            const Node &node = pNodes->at(index);
            if (node.level >= 0) {
 80a25a6:	2b00      	cmp	r3, #0
                level = (LogLevel)node.level;
 80a25a8:	bfa8      	it	ge
 80a25aa:	b2de      	uxtbge	r6, r3
    LogLevel level = level_; // Default level
    if (!nodes_.isEmpty() && category) {
        const Vector<Node> *pNodes = &nodes_; // Root nodes
        const char *name = nullptr; // Subcategory name
        size_t size = 0; // Name length
        while ((name = nextSubcategoryName(category, size))) {
 80a25ac:	e7e4      	b.n	80a2578 <_ZNK5spark6detail9LogFilter5levelEPKc+0x1c>
            }
            pNodes = &node.nodes;
        }
    }
    return level;
}
 80a25ae:	4630      	mov	r0, r6
 80a25b0:	b005      	add	sp, #20
 80a25b2:	bdf0      	pop	{r4, r5, r6, r7, pc}

080a25b4 <_ZN5spark24DefaultLogHandlerFactory8instanceEv>:
        return new(std::nothrow) StreamLogHandler(*stream, level, std::move(filters));
    }
    return nullptr; // Unknown handler type
}

spark::DefaultLogHandlerFactory* spark::DefaultLogHandlerFactory::instance() {
 80a25b4:	b510      	push	{r4, lr}
    static DefaultLogHandlerFactory factory;
 80a25b6:	4c09      	ldr	r4, [pc, #36]	; (80a25dc <_ZN5spark24DefaultLogHandlerFactory8instanceEv+0x28>)
 80a25b8:	6823      	ldr	r3, [r4, #0]
 80a25ba:	07db      	lsls	r3, r3, #31
 80a25bc:	d40b      	bmi.n	80a25d6 <_ZN5spark24DefaultLogHandlerFactory8instanceEv+0x22>
 80a25be:	4620      	mov	r0, r4
 80a25c0:	f7fd fd78 	bl	80a00b4 <__cxa_guard_acquire>
 80a25c4:	b138      	cbz	r0, 80a25d6 <_ZN5spark24DefaultLogHandlerFactory8instanceEv+0x22>
 80a25c6:	4620      	mov	r0, r4
 80a25c8:	f7fd fd79 	bl	80a00be <__cxa_guard_release>
 80a25cc:	4a04      	ldr	r2, [pc, #16]	; (80a25e0 <_ZN5spark24DefaultLogHandlerFactory8instanceEv+0x2c>)
 80a25ce:	4905      	ldr	r1, [pc, #20]	; (80a25e4 <_ZN5spark24DefaultLogHandlerFactory8instanceEv+0x30>)
 80a25d0:	4805      	ldr	r0, [pc, #20]	; (80a25e8 <_ZN5spark24DefaultLogHandlerFactory8instanceEv+0x34>)
 80a25d2:	f001 f9fb 	bl	80a39cc <__aeabi_atexit>
    return &factory;
}
 80a25d6:	4804      	ldr	r0, [pc, #16]	; (80a25e8 <_ZN5spark24DefaultLogHandlerFactory8instanceEv+0x34>)
 80a25d8:	bd10      	pop	{r4, pc}
 80a25da:	bf00      	nop
 80a25dc:	20000488 	.word	0x20000488
 80a25e0:	20000074 	.word	0x20000074
 80a25e4:	080a23e5 	.word	0x080a23e5
 80a25e8:	20000008 	.word	0x20000008

080a25ec <_ZN5spark26DefaultOutputStreamFactory8instanceEv>:
    }
#endif // PLATFORM_ID != 3
    OutputStreamFactory::destroyStream(stream);
}

spark::DefaultOutputStreamFactory* spark::DefaultOutputStreamFactory::instance() {
 80a25ec:	b510      	push	{r4, lr}
    static DefaultOutputStreamFactory factory;
 80a25ee:	4c09      	ldr	r4, [pc, #36]	; (80a2614 <_ZN5spark26DefaultOutputStreamFactory8instanceEv+0x28>)
 80a25f0:	6823      	ldr	r3, [r4, #0]
 80a25f2:	07db      	lsls	r3, r3, #31
 80a25f4:	d40b      	bmi.n	80a260e <_ZN5spark26DefaultOutputStreamFactory8instanceEv+0x22>
 80a25f6:	4620      	mov	r0, r4
 80a25f8:	f7fd fd5c 	bl	80a00b4 <__cxa_guard_acquire>
 80a25fc:	b138      	cbz	r0, 80a260e <_ZN5spark26DefaultOutputStreamFactory8instanceEv+0x22>
 80a25fe:	4620      	mov	r0, r4
 80a2600:	f7fd fd5d 	bl	80a00be <__cxa_guard_release>
 80a2604:	4a04      	ldr	r2, [pc, #16]	; (80a2618 <_ZN5spark26DefaultOutputStreamFactory8instanceEv+0x2c>)
 80a2606:	4905      	ldr	r1, [pc, #20]	; (80a261c <_ZN5spark26DefaultOutputStreamFactory8instanceEv+0x30>)
 80a2608:	4805      	ldr	r0, [pc, #20]	; (80a2620 <_ZN5spark26DefaultOutputStreamFactory8instanceEv+0x34>)
 80a260a:	f001 f9df 	bl	80a39cc <__aeabi_atexit>
    return &factory;
}
 80a260e:	4804      	ldr	r0, [pc, #16]	; (80a2620 <_ZN5spark26DefaultOutputStreamFactory8instanceEv+0x34>)
 80a2610:	bd10      	pop	{r4, pc}
 80a2612:	bf00      	nop
 80a2614:	200004b8 	.word	0x200004b8
 80a2618:	20000074 	.word	0x20000074
 80a261c:	080a23e3 	.word	0x080a23e3
 80a2620:	20000004 	.word	0x20000004

080a2624 <_ZN5spark10LogManagerC1Ev>:
    Print *stream;
};

#endif // Wiring_LogConfig

spark::LogManager::LogManager() {
 80a2624:	b538      	push	{r3, r4, r5, lr}
// spark::Vector
template<typename T, typename AllocatorT>
inline spark::Vector<T, AllocatorT>::Vector() :
        data_(nullptr),
        size_(0),
        capacity_(0) {
 80a2626:	2500      	movs	r5, #0
 80a2628:	4604      	mov	r4, r0
 80a262a:	6005      	str	r5, [r0, #0]
 80a262c:	6045      	str	r5, [r0, #4]
 80a262e:	6085      	str	r5, [r0, #8]
 80a2630:	6105      	str	r5, [r0, #16]
 80a2632:	6145      	str	r5, [r0, #20]
 80a2634:	6185      	str	r5, [r0, #24]
    /**
     * Creates a shared mutex.
     */
    RecursiveMutex(os_mutex_recursive_t handle) : handle_(handle) {}

    RecursiveMutex() : handle_(nullptr)
 80a2636:	f840 5f24 	str.w	r5, [r0, #36]!
    {
        os_mutex_recursive_create(&handle_);
 80a263a:	f7ff f85d 	bl	80a16f8 <os_mutex_recursive_create>
#if Wiring_LogConfig
    handlerFactory_ = DefaultLogHandlerFactory::instance();
 80a263e:	f7ff ffb9 	bl	80a25b4 <_ZN5spark24DefaultLogHandlerFactory8instanceEv>
 80a2642:	61e0      	str	r0, [r4, #28]
    streamFactory_ = DefaultOutputStreamFactory::instance();
 80a2644:	f7ff ffd2 	bl	80a25ec <_ZN5spark26DefaultOutputStreamFactory8instanceEv>
#endif
    outputActive_ = false;
 80a2648:	7325      	strb	r5, [r4, #12]
#endif // Wiring_LogConfig

spark::LogManager::LogManager() {
#if Wiring_LogConfig
    handlerFactory_ = DefaultLogHandlerFactory::instance();
    streamFactory_ = DefaultOutputStreamFactory::instance();
 80a264a:	6220      	str	r0, [r4, #32]
#endif
    outputActive_ = false;
}
 80a264c:	4620      	mov	r0, r4
 80a264e:	bd38      	pop	{r3, r4, r5, pc}

080a2650 <_ZN5spark10LogManager8instanceEv>:
            resetSystemCallbacks();
        }
    }
}

spark::LogManager* spark::LogManager::instance() {
 80a2650:	b510      	push	{r4, lr}
    static LogManager mgr;
 80a2652:	4c0a      	ldr	r4, [pc, #40]	; (80a267c <_ZN5spark10LogManager8instanceEv+0x2c>)
 80a2654:	6823      	ldr	r3, [r4, #0]
 80a2656:	07db      	lsls	r3, r3, #31
 80a2658:	d40e      	bmi.n	80a2678 <_ZN5spark10LogManager8instanceEv+0x28>
 80a265a:	4620      	mov	r0, r4
 80a265c:	f7fd fd2a 	bl	80a00b4 <__cxa_guard_acquire>
 80a2660:	b150      	cbz	r0, 80a2678 <_ZN5spark10LogManager8instanceEv+0x28>
 80a2662:	4807      	ldr	r0, [pc, #28]	; (80a2680 <_ZN5spark10LogManager8instanceEv+0x30>)
 80a2664:	f7ff ffde 	bl	80a2624 <_ZN5spark10LogManagerC1Ev>
 80a2668:	4620      	mov	r0, r4
 80a266a:	f7fd fd28 	bl	80a00be <__cxa_guard_release>
 80a266e:	4a05      	ldr	r2, [pc, #20]	; (80a2684 <_ZN5spark10LogManager8instanceEv+0x34>)
 80a2670:	4905      	ldr	r1, [pc, #20]	; (80a2688 <_ZN5spark10LogManager8instanceEv+0x38>)
 80a2672:	4803      	ldr	r0, [pc, #12]	; (80a2680 <_ZN5spark10LogManager8instanceEv+0x30>)
 80a2674:	f001 f9aa 	bl	80a39cc <__aeabi_atexit>
    return &mgr;
}
 80a2678:	4801      	ldr	r0, [pc, #4]	; (80a2680 <_ZN5spark10LogManager8instanceEv+0x30>)
 80a267a:	bd10      	pop	{r4, pc}
 80a267c:	2000048c 	.word	0x2000048c
 80a2680:	20000490 	.word	0x20000490
 80a2684:	20000074 	.word	0x20000074
 80a2688:	080a2ad9 	.word	0x080a2ad9

080a268c <_ZN5spark10LogManager18setSystemCallbacksEv>:
}

#endif // Wiring_LogConfig

void spark::LogManager::setSystemCallbacks() {
    log_set_callbacks(logMessage, logWrite, logEnabled, nullptr);
 80a268c:	2300      	movs	r3, #0
 80a268e:	4a02      	ldr	r2, [pc, #8]	; (80a2698 <_ZN5spark10LogManager18setSystemCallbacksEv+0xc>)
 80a2690:	4902      	ldr	r1, [pc, #8]	; (80a269c <_ZN5spark10LogManager18setSystemCallbacksEv+0x10>)
 80a2692:	4803      	ldr	r0, [pc, #12]	; (80a26a0 <_ZN5spark10LogManager18setSystemCallbacksEv+0x14>)
 80a2694:	f7ff b8d0 	b.w	80a1838 <log_set_callbacks>
 80a2698:	080a29bd 	.word	0x080a29bd
 80a269c:	080a294d 	.word	0x080a294d
 80a26a0:	080a28d5 	.word	0x080a28d5

080a26a4 <_ZN5spark10LogManager20resetSystemCallbacksEv>:
}

void spark::LogManager::resetSystemCallbacks() {
    log_set_callbacks(nullptr, nullptr, nullptr, nullptr);
 80a26a4:	2300      	movs	r3, #0
 80a26a6:	461a      	mov	r2, r3
 80a26a8:	4619      	mov	r1, r3
 80a26aa:	4618      	mov	r0, r3
 80a26ac:	f7ff b8c4 	b.w	80a1838 <log_set_callbacks>

080a26b0 <_ZN5spark18JSONObjectIteratorC1ERKNS_9JSONValueE>:
        k_(nullptr),
        v_(nullptr),
        n_(0) {
}

inline spark::JSONObjectIterator::JSONObjectIterator(const JSONValue &value) :
 80a26b0:	b573      	push	{r0, r1, r4, r5, r6, lr}
 80a26b2:	4605      	mov	r5, r0
        JSONObjectIterator(value.t_, value.d_) {
 80a26b4:	688e      	ldr	r6, [r1, #8]
      template<typename _Tp1>
	__shared_ptr(const __shared_ptr<_Tp1, _Lp>& __r, _Tp* __p) noexcept
	: _M_ptr(__p), _M_refcount(__r._M_refcount) // never throws
	{ }

      __shared_ptr(const __shared_ptr&) noexcept = default;
 80a26b6:	f851 3b04 	ldr.w	r3, [r1], #4
 80a26ba:	ac02      	add	r4, sp, #8
 80a26bc:	f844 3d08 	str.w	r3, [r4, #-8]!
 80a26c0:	a801      	add	r0, sp, #4
 80a26c2:	f7ff fdb8 	bl	80a2236 <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EEC1ERKS2_>
 80a26c6:	4622      	mov	r2, r4
 80a26c8:	4631      	mov	r1, r6
 80a26ca:	4628      	mov	r0, r5
 80a26cc:	f7ff fb24 	bl	80a1d18 <_ZN5spark18JSONObjectIteratorC1EPK9jsmntok_tSt10shared_ptrINS_6detail8JSONDataEE>
      __shared_ptr& operator=(const __shared_ptr&) noexcept = default;
      ~__shared_ptr() = default;
 80a26d0:	a801      	add	r0, sp, #4
 80a26d2:	f7ff fad7 	bl	80a1c84 <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EED1Ev>
}
 80a26d6:	4628      	mov	r0, r5
 80a26d8:	b002      	add	sp, #8
 80a26da:	bd70      	pop	{r4, r5, r6, pc}

080a26dc <_ZNK5spark18JSONObjectIterator5valueEv>:

inline spark::JSONString spark::JSONObjectIterator::name() const {
    return JSONString(k_, d_);
}

inline spark::JSONValue spark::JSONObjectIterator::value() const {
 80a26dc:	b573      	push	{r0, r1, r4, r5, r6, lr}
 80a26de:	4605      	mov	r5, r0
    return JSONValue(v_, d_);
 80a26e0:	690e      	ldr	r6, [r1, #16]
      template<typename _Tp1>
	__shared_ptr(const __shared_ptr<_Tp1, _Lp>& __r, _Tp* __p) noexcept
	: _M_ptr(__p), _M_refcount(__r._M_refcount) // never throws
	{ }

      __shared_ptr(const __shared_ptr&) noexcept = default;
 80a26e2:	f851 3b04 	ldr.w	r3, [r1], #4
 80a26e6:	ac02      	add	r4, sp, #8
 80a26e8:	f844 3d08 	str.w	r3, [r4, #-8]!
 80a26ec:	a801      	add	r0, sp, #4
 80a26ee:	f7ff fda2 	bl	80a2236 <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EEC1ERKS2_>
 80a26f2:	4622      	mov	r2, r4
 80a26f4:	4631      	mov	r1, r6
 80a26f6:	4628      	mov	r0, r5
 80a26f8:	f7ff fb29 	bl	80a1d4e <_ZN5spark9JSONValueC1EPK9jsmntok_tSt10shared_ptrINS_6detail8JSONDataEE>
      __shared_ptr& operator=(const __shared_ptr&) noexcept = default;
      ~__shared_ptr() = default;
 80a26fc:	a801      	add	r0, sp, #4
 80a26fe:	f7ff fac1 	bl	80a1c84 <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EED1Ev>
}
 80a2702:	4628      	mov	r0, r5
 80a2704:	b002      	add	sp, #8
 80a2706:	bd70      	pop	{r4, r5, r6, pc}

080a2708 <_ZNK5spark18JSONObjectIterator4nameEv>:

inline spark::JSONObjectIterator::JSONObjectIterator(const JSONValue &value) :
        JSONObjectIterator(value.t_, value.d_) {
}

inline spark::JSONString spark::JSONObjectIterator::name() const {
 80a2708:	b573      	push	{r0, r1, r4, r5, r6, lr}
 80a270a:	4605      	mov	r5, r0
    return JSONString(k_, d_);
 80a270c:	68ce      	ldr	r6, [r1, #12]
      template<typename _Tp1>
	__shared_ptr(const __shared_ptr<_Tp1, _Lp>& __r, _Tp* __p) noexcept
	: _M_ptr(__p), _M_refcount(__r._M_refcount) // never throws
	{ }

      __shared_ptr(const __shared_ptr&) noexcept = default;
 80a270e:	f851 3b04 	ldr.w	r3, [r1], #4
 80a2712:	ac02      	add	r4, sp, #8
 80a2714:	f844 3d08 	str.w	r3, [r4, #-8]!
 80a2718:	a801      	add	r0, sp, #4
 80a271a:	f7ff fd8c 	bl	80a2236 <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EEC1ERKS2_>
 80a271e:	4622      	mov	r2, r4
 80a2720:	4631      	mov	r1, r6
 80a2722:	4628      	mov	r0, r5
 80a2724:	f7ff fad0 	bl	80a1cc8 <_ZN5spark10JSONStringC1EPK9jsmntok_tSt10shared_ptrINS_6detail8JSONDataEE>
      __shared_ptr& operator=(const __shared_ptr&) noexcept = default;
      ~__shared_ptr() = default;
 80a2728:	a801      	add	r0, sp, #4
 80a272a:	f7ff faab 	bl	80a1c84 <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EED1Ev>
}
 80a272e:	4628      	mov	r0, r5
 80a2730:	b002      	add	sp, #8
 80a2732:	bd70      	pop	{r4, r5, r6, pc}

080a2734 <_ZN5spark26DefaultOutputStreamFactory9getParamsERKNS_9JSONValueEPi>:
spark::DefaultOutputStreamFactory* spark::DefaultOutputStreamFactory::instance() {
    static DefaultOutputStreamFactory factory;
    return &factory;
}

void spark::DefaultOutputStreamFactory::getParams(const JSONValue &params, int *baudRate) {
 80a2734:	b530      	push	{r4, r5, lr}
 80a2736:	b08b      	sub	sp, #44	; 0x2c
 80a2738:	460d      	mov	r5, r1
    JSONObjectIterator it(params);
 80a273a:	4601      	mov	r1, r0
 80a273c:	a804      	add	r0, sp, #16
 80a273e:	f7ff ffb7 	bl	80a26b0 <_ZN5spark18JSONObjectIteratorC1ERKNS_9JSONValueE>
    while (it.next()) {
 80a2742:	a804      	add	r0, sp, #16
 80a2744:	f7ff f9d1 	bl	80a1aea <_ZN5spark18JSONObjectIterator4nextEv>
 80a2748:	b1e8      	cbz	r0, 80a2786 <_ZN5spark26DefaultOutputStreamFactory9getParamsERKNS_9JSONValueEPi+0x52>
        if (it.name() == "baud" && baudRate) {
 80a274a:	a904      	add	r1, sp, #16
 80a274c:	4668      	mov	r0, sp
 80a274e:	f7ff ffdb 	bl	80a2708 <_ZNK5spark18JSONObjectIterator4nameEv>
 80a2752:	490f      	ldr	r1, [pc, #60]	; (80a2790 <_ZN5spark26DefaultOutputStreamFactory9getParamsERKNS_9JSONValueEPi+0x5c>)
 80a2754:	9802      	ldr	r0, [sp, #8]
 80a2756:	f7ff fe91 	bl	80a247c <_ZNK5spark10JSONStringeqEPKc.isra.7>
 80a275a:	4604      	mov	r4, r0
 80a275c:	b110      	cbz	r0, 80a2764 <_ZN5spark26DefaultOutputStreamFactory9getParamsERKNS_9JSONValueEPi+0x30>
 80a275e:	1c2c      	adds	r4, r5, #0
 80a2760:	bf18      	it	ne
 80a2762:	2401      	movne	r4, #1
 80a2764:	a801      	add	r0, sp, #4
 80a2766:	f7ff fa8d 	bl	80a1c84 <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EED1Ev>
 80a276a:	2c00      	cmp	r4, #0
 80a276c:	d0e9      	beq.n	80a2742 <_ZN5spark26DefaultOutputStreamFactory9getParamsERKNS_9JSONValueEPi+0xe>
            *baudRate = it.value().toInt();
 80a276e:	a904      	add	r1, sp, #16
 80a2770:	4668      	mov	r0, sp
 80a2772:	f7ff ffb3 	bl	80a26dc <_ZNK5spark18JSONObjectIterator5valueEv>
 80a2776:	4668      	mov	r0, sp
 80a2778:	f7ff f997 	bl	80a1aaa <_ZNK5spark9JSONValue5toIntEv>
 80a277c:	6028      	str	r0, [r5, #0]
 80a277e:	a801      	add	r0, sp, #4
 80a2780:	f7ff fa80 	bl	80a1c84 <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EED1Ev>
 80a2784:	e7dd      	b.n	80a2742 <_ZN5spark26DefaultOutputStreamFactory9getParamsERKNS_9JSONValueEPi+0xe>
 80a2786:	a805      	add	r0, sp, #20
 80a2788:	f7ff fa7c 	bl	80a1c84 <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EED1Ev>
        }
    }
}
 80a278c:	b00b      	add	sp, #44	; 0x2c
 80a278e:	bd30      	pop	{r4, r5, pc}
 80a2790:	080a4bb0 	.word	0x080a4bb0

080a2794 <_ZN5spark26DefaultOutputStreamFactory12createStreamEPKcRKNS_9JSONValueE>:
    static DefaultLogHandlerFactory factory;
    return &factory;
}

// spark::DefaultOutputStreamFactory
Print* spark::DefaultOutputStreamFactory::createStream(const char *type, const JSONValue &params) {
 80a2794:	b537      	push	{r0, r1, r2, r4, r5, lr}
 80a2796:	460c      	mov	r4, r1
#if PLATFORM_ID != 3
    if (strcmp(type, "Serial") == 0) {
 80a2798:	491a      	ldr	r1, [pc, #104]	; (80a2804 <_ZN5spark26DefaultOutputStreamFactory12createStreamEPKcRKNS_9JSONValueE+0x70>)
 80a279a:	4620      	mov	r0, r4
    static DefaultLogHandlerFactory factory;
    return &factory;
}

// spark::DefaultOutputStreamFactory
Print* spark::DefaultOutputStreamFactory::createStream(const char *type, const JSONValue &params) {
 80a279c:	4615      	mov	r5, r2
#if PLATFORM_ID != 3
    if (strcmp(type, "Serial") == 0) {
 80a279e:	f001 fafb 	bl	80a3d98 <strcmp>
 80a27a2:	b940      	cbnz	r0, 80a27b6 <_ZN5spark26DefaultOutputStreamFactory12createStreamEPKcRKNS_9JSONValueE+0x22>
        Serial.begin();
 80a27a4:	f7ff fc78 	bl	80a2098 <_Z16_fetch_usbserialv>
 80a27a8:	f44f 5116 	mov.w	r1, #9600	; 0x2580
 80a27ac:	f7ff fc56 	bl	80a205c <_ZN9USBSerial5beginEl>
        return &Serial;
 80a27b0:	f7ff fc72 	bl	80a2098 <_Z16_fetch_usbserialv>
 80a27b4:	e023      	b.n	80a27fe <_ZN5spark26DefaultOutputStreamFactory12createStreamEPKcRKNS_9JSONValueE+0x6a>
    }
#if Wiring_USBSerial1
    if (strcmp(type, "USBSerial1") == 0) {
 80a27b6:	4914      	ldr	r1, [pc, #80]	; (80a2808 <_ZN5spark26DefaultOutputStreamFactory12createStreamEPKcRKNS_9JSONValueE+0x74>)
 80a27b8:	4620      	mov	r0, r4
 80a27ba:	f001 faed 	bl	80a3d98 <strcmp>
 80a27be:	b940      	cbnz	r0, 80a27d2 <_ZN5spark26DefaultOutputStreamFactory12createStreamEPKcRKNS_9JSONValueE+0x3e>
        USBSerial1.begin();
 80a27c0:	f7ff fca6 	bl	80a2110 <_Z17_fetch_usbserial1v>
 80a27c4:	f44f 5116 	mov.w	r1, #9600	; 0x2580
 80a27c8:	f7ff fc48 	bl	80a205c <_ZN9USBSerial5beginEl>
        return &USBSerial1;
 80a27cc:	f7ff fca0 	bl	80a2110 <_Z17_fetch_usbserial1v>
 80a27d0:	e015      	b.n	80a27fe <_ZN5spark26DefaultOutputStreamFactory12createStreamEPKcRKNS_9JSONValueE+0x6a>
    }
#endif
    if (strcmp(type, "Serial1") == 0) {
 80a27d2:	490e      	ldr	r1, [pc, #56]	; (80a280c <_ZN5spark26DefaultOutputStreamFactory12createStreamEPKcRKNS_9JSONValueE+0x78>)
 80a27d4:	4620      	mov	r0, r4
 80a27d6:	f001 fadf 	bl	80a3d98 <strcmp>
 80a27da:	b978      	cbnz	r0, 80a27fc <_ZN5spark26DefaultOutputStreamFactory12createStreamEPKcRKNS_9JSONValueE+0x68>
        int baud = 9600;
 80a27dc:	a902      	add	r1, sp, #8
 80a27de:	f44f 5316 	mov.w	r3, #9600	; 0x2580
 80a27e2:	f841 3d04 	str.w	r3, [r1, #-4]!
        getParams(params, &baud);
 80a27e6:	4628      	mov	r0, r5
 80a27e8:	f7ff ffa4 	bl	80a2734 <_ZN5spark26DefaultOutputStreamFactory9getParamsERKNS_9JSONValueEPi>
        Serial1.begin(baud);
 80a27ec:	f000 feb6 	bl	80a355c <_Z22__fetch_global_Serial1v>
 80a27f0:	9901      	ldr	r1, [sp, #4]
 80a27f2:	f000 fea9 	bl	80a3548 <_ZN11USARTSerial5beginEm>
        return &Serial1;
 80a27f6:	f000 feb1 	bl	80a355c <_Z22__fetch_global_Serial1v>
 80a27fa:	e000      	b.n	80a27fe <_ZN5spark26DefaultOutputStreamFactory12createStreamEPKcRKNS_9JSONValueE+0x6a>
    }
#endif // PLATFORM_ID != 3
    return nullptr;
 80a27fc:	2000      	movs	r0, #0
}
 80a27fe:	b003      	add	sp, #12
 80a2800:	bd30      	pop	{r4, r5, pc}
 80a2802:	bf00      	nop
 80a2804:	080a4bb5 	.word	0x080a4bb5
 80a2808:	080a4bbc 	.word	0x080a4bbc
 80a280c:	080a4bbf 	.word	0x080a4bbf

080a2810 <_ZN5spark6VectorINS_6detail9LogFilter4NodeENS_16DefaultAllocatorEED1Ev>:
inline spark::Vector<T, AllocatorT>::Vector(Vector<T, AllocatorT>&& vector) : Vector() {
    swap(*this, vector);
}

template<typename T, typename AllocatorT>
inline spark::Vector<T, AllocatorT>::~Vector() {
 80a2810:	b570      	push	{r4, r5, r6, lr}
 80a2812:	4605      	mov	r5, r0
    destruct(data_, data_ + size_);
 80a2814:	6804      	ldr	r4, [r0, #0]
 80a2816:	6843      	ldr	r3, [r0, #4]
 80a2818:	2614      	movs	r6, #20
 80a281a:	fb06 4603 	mla	r6, r6, r3, r4
            new(p) T(std::forward<ArgsT>(args)...);
        }
    }

    static void destruct(T* p, const T* end) {
        for (; p != end; ++p) {
 80a281e:	42a6      	cmp	r6, r4
 80a2820:	d005      	beq.n	80a282e <_ZN5spark6VectorINS_6detail9LogFilter4NodeENS_16DefaultAllocatorEED1Ev+0x1e>
    |
    `- aa (error) - b (warn)
*/

// spark::detail::LogFilter
struct spark::detail::LogFilter::Node {
 80a2822:	f104 0008 	add.w	r0, r4, #8
 80a2826:	f7ff fff3 	bl	80a2810 <_ZN5spark6VectorINS_6detail9LogFilter4NodeENS_16DefaultAllocatorEED1Ev>
 80a282a:	3414      	adds	r4, #20
 80a282c:	e7f7      	b.n	80a281e <_ZN5spark6VectorINS_6detail9LogFilter4NodeENS_16DefaultAllocatorEED1Ev+0xe>
inline void* spark::DefaultAllocator::realloc(void* ptr, size_t size) {
    return ::realloc(ptr, size);
}

inline void spark::DefaultAllocator::free(void* ptr) {
    ::free(ptr);
 80a282e:	6828      	ldr	r0, [r5, #0]
 80a2830:	f7ff f88e 	bl	80a1950 <free>

template<typename T, typename AllocatorT>
inline spark::Vector<T, AllocatorT>::~Vector() {
    destruct(data_, data_ + size_);
    AllocatorT::free(data_);
}
 80a2834:	4628      	mov	r0, r5
 80a2836:	bd70      	pop	{r4, r5, r6, pc}

080a2838 <_ZN5spark6VectorI6StringNS_16DefaultAllocatorEED1Ev>:
inline spark::Vector<T, AllocatorT>::Vector(Vector<T, AllocatorT>&& vector) : Vector() {
    swap(*this, vector);
}

template<typename T, typename AllocatorT>
inline spark::Vector<T, AllocatorT>::~Vector() {
 80a2838:	b570      	push	{r4, r5, r6, lr}
 80a283a:	4605      	mov	r5, r0
    destruct(data_, data_ + size_);
 80a283c:	6804      	ldr	r4, [r0, #0]
 80a283e:	6843      	ldr	r3, [r0, #4]
 80a2840:	eb04 1603 	add.w	r6, r4, r3, lsl #4
            new(p) T(std::forward<ArgsT>(args)...);
        }
    }

    static void destruct(T* p, const T* end) {
        for (; p != end; ++p) {
 80a2844:	42a6      	cmp	r6, r4
 80a2846:	d004      	beq.n	80a2852 <_ZN5spark6VectorI6StringNS_16DefaultAllocatorEED1Ev+0x1a>
            p->~T();
 80a2848:	4620      	mov	r0, r4
 80a284a:	f000 ff9d 	bl	80a3788 <_ZN6StringD1Ev>
            new(p) T(std::forward<ArgsT>(args)...);
        }
    }

    static void destruct(T* p, const T* end) {
        for (; p != end; ++p) {
 80a284e:	3410      	adds	r4, #16
 80a2850:	e7f8      	b.n	80a2844 <_ZN5spark6VectorI6StringNS_16DefaultAllocatorEED1Ev+0xc>
inline void* spark::DefaultAllocator::realloc(void* ptr, size_t size) {
    return ::realloc(ptr, size);
}

inline void spark::DefaultAllocator::free(void* ptr) {
    ::free(ptr);
 80a2852:	6828      	ldr	r0, [r5, #0]
 80a2854:	f7ff f87c 	bl	80a1950 <free>

template<typename T, typename AllocatorT>
inline spark::Vector<T, AllocatorT>::~Vector() {
    destruct(data_, data_ + size_);
    AllocatorT::free(data_);
}
 80a2858:	4628      	mov	r0, r5
 80a285a:	bd70      	pop	{r4, r5, r6, pc}

080a285c <_ZN5spark6detail9LogFilterD1Ev>:
    swap(cats_, cats);
    swap(nodes_, nodes);
    level_ = level;
}

spark::detail::LogFilter::~LogFilter() {
 80a285c:	b510      	push	{r4, lr}
 80a285e:	4604      	mov	r4, r0
 80a2860:	300c      	adds	r0, #12
 80a2862:	f7ff ffd5 	bl	80a2810 <_ZN5spark6VectorINS_6detail9LogFilter4NodeENS_16DefaultAllocatorEED1Ev>
 80a2866:	4620      	mov	r0, r4
 80a2868:	f7ff ffe6 	bl	80a2838 <_ZN5spark6VectorI6StringNS_16DefaultAllocatorEED1Ev>
}
 80a286c:	4620      	mov	r0, r4
 80a286e:	bd10      	pop	{r4, pc}

080a2870 <_ZN5spark16StreamLogHandlerD1Ev>:
/*!
    \brief Stream-based log handler.

    Adapter class allowing to use existent stream objects as destination for logging output.
*/
class StreamLogHandler: public LogHandler {
 80a2870:	b510      	push	{r4, lr}
 80a2872:	4604      	mov	r4, r0
    */
    LogHandler(LogLevel level, LogCategoryFilters filters);
    /*!
        \brief Destructor.
    */
    virtual ~LogHandler() = default;
 80a2874:	4b03      	ldr	r3, [pc, #12]	; (80a2884 <_ZN5spark16StreamLogHandlerD1Ev+0x14>)
 80a2876:	f840 3b04 	str.w	r3, [r0], #4
 80a287a:	f7ff ffef 	bl	80a285c <_ZN5spark6detail9LogFilterD1Ev>
/*!
    \brief Stream-based log handler.

    Adapter class allowing to use existent stream objects as destination for logging output.
*/
class StreamLogHandler: public LogHandler {
 80a287e:	4620      	mov	r0, r4
 80a2880:	bd10      	pop	{r4, pc}
 80a2882:	bf00      	nop
 80a2884:	080a3f48 	.word	0x080a3f48

080a2888 <_ZN5spark16StreamLogHandlerD0Ev>:
 80a2888:	b510      	push	{r4, lr}
 80a288a:	4604      	mov	r4, r0
 80a288c:	f7ff fff0 	bl	80a2870 <_ZN5spark16StreamLogHandlerD1Ev>
 80a2890:	4620      	mov	r0, r4
 80a2892:	2124      	movs	r1, #36	; 0x24
 80a2894:	f001 f8a8 	bl	80a39e8 <_ZdlPvj>
 80a2898:	4620      	mov	r0, r4
 80a289a:	bd10      	pop	{r4, pc}

080a289c <_ZN5spark20JSONStreamLogHandlerD1Ev>:

private:
    Print *stream_;
};

class JSONStreamLogHandler: public StreamLogHandler {
 80a289c:	b510      	push	{r4, lr}
 80a289e:	4604      	mov	r4, r0
 80a28a0:	4b02      	ldr	r3, [pc, #8]	; (80a28ac <_ZN5spark20JSONStreamLogHandlerD1Ev+0x10>)
 80a28a2:	6003      	str	r3, [r0, #0]
 80a28a4:	f7ff ffe4 	bl	80a2870 <_ZN5spark16StreamLogHandlerD1Ev>
 80a28a8:	4620      	mov	r0, r4
 80a28aa:	bd10      	pop	{r4, pc}
 80a28ac:	080a4ba0 	.word	0x080a4ba0

080a28b0 <_ZN5spark20JSONStreamLogHandlerD0Ev>:
 80a28b0:	b510      	push	{r4, lr}
 80a28b2:	4604      	mov	r4, r0
 80a28b4:	f7ff fff2 	bl	80a289c <_ZN5spark20JSONStreamLogHandlerD1Ev>
 80a28b8:	4620      	mov	r0, r4
 80a28ba:	2124      	movs	r1, #36	; 0x24
 80a28bc:	f001 f894 	bl	80a39e8 <_ZdlPvj>
 80a28c0:	4620      	mov	r0, r4
 80a28c2:	bd10      	pop	{r4, pc}

080a28c4 <_ZNSt10lock_guardI14RecursiveMutexED1Ev>:
      { _M_device.lock(); }

      lock_guard(mutex_type& __m, adopt_lock_t) : _M_device(__m)
      { } // calling thread owns mutex

      ~lock_guard()
 80a28c4:	b510      	push	{r4, lr}
 80a28c6:	4604      	mov	r4, r0
        }
    }

    void lock() { os_mutex_recursive_lock(handle_); }
    bool trylock() { return os_mutex_recursive_trylock(handle_)==0; }
    void unlock() { os_mutex_recursive_unlock(handle_); }
 80a28c8:	6803      	ldr	r3, [r0, #0]
 80a28ca:	6818      	ldr	r0, [r3, #0]
 80a28cc:	f7fe ff2c 	bl	80a1728 <os_mutex_recursive_unlock>
      { _M_device.unlock(); }
 80a28d0:	4620      	mov	r0, r4
 80a28d2:	bd10      	pop	{r4, pc}

080a28d4 <_ZN5spark10LogManager10logMessageEPKciS2_PK13LogAttributesPv>:

void spark::LogManager::resetSystemCallbacks() {
    log_set_callbacks(nullptr, nullptr, nullptr, nullptr);
}

void spark::LogManager::logMessage(const char *msg, int level, const char *category, const LogAttributes *attr, void *reserved) {
 80a28d4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80a28d8:	469b      	mov	fp, r3
#endif /* nRF52840 */

#if defined(STM32F10X_MD) || defined(STM32F10X_HD) || defined(STM32F2XX) || defined(nRF52840)
static inline bool HAL_IsISR() 
{
	return (SCB->ICSR & SCB_ICSR_VECTACTIVE_Msk) != 0;
 80a28da:	4b1b      	ldr	r3, [pc, #108]	; (80a2948 <_ZN5spark10LogManager10logMessageEPKciS2_PK13LogAttributesPv+0x74>)
 80a28dc:	b085      	sub	sp, #20
 80a28de:	685b      	ldr	r3, [r3, #4]
 80a28e0:	4682      	mov	sl, r0
#ifndef LOG_FROM_ISR
    if (HAL_IsISR()) {
 80a28e2:	f3c3 0308 	ubfx	r3, r3, #0, #9

void spark::LogManager::resetSystemCallbacks() {
    log_set_callbacks(nullptr, nullptr, nullptr, nullptr);
}

void spark::LogManager::logMessage(const char *msg, int level, const char *category, const LogAttributes *attr, void *reserved) {
 80a28e6:	460e      	mov	r6, r1
 80a28e8:	4690      	mov	r8, r2
#ifndef LOG_FROM_ISR
    if (HAL_IsISR()) {
 80a28ea:	bb53      	cbnz	r3, 80a2942 <_ZN5spark10LogManager10logMessageEPKciS2_PK13LogAttributesPv+0x6e>
        return;
    }
#endif
    LogManager *that = instance();
 80a28ec:	f7ff feb0 	bl	80a2650 <_ZN5spark10LogManager8instanceEv>
 80a28f0:	4604      	mov	r4, r0
    LOG_WITH_LOCK(that->mutex_) {
 80a28f2:	3024      	adds	r0, #36	; 0x24
    class lock_guard
    {
    public:
      typedef _Mutex mutex_type;

      explicit lock_guard(mutex_type& __m) : _M_device(__m)
 80a28f4:	9003      	str	r0, [sp, #12]
      { _M_device.lock(); }
 80a28f6:	f7ff fdd5 	bl	80a24a4 <_ZN14RecursiveMutex4lockEv>
        // prevent re-entry
        if (that->isActive()) {
 80a28fa:	7b23      	ldrb	r3, [r4, #12]
 80a28fc:	b9f3      	cbnz	r3, 80a293c <_ZN5spark10LogManager10logMessageEPKciS2_PK13LogAttributesPv+0x68>
inline bool spark::LogManager::isActive() const {
    return outputActive_;
}

inline void spark::LogManager::setActive(bool outputActive) {
    outputActive_ = outputActive;
 80a28fe:	2301      	movs	r3, #1
 80a2900:	7323      	strb	r3, [r4, #12]
 80a2902:	6825      	ldr	r5, [r4, #0]
    return data_;
}

template<typename T, typename AllocatorT>
T* spark::Vector<T, AllocatorT>::end() {
    return data_ + size_;
 80a2904:	6863      	ldr	r3, [r4, #4]
        if (that->isActive()) {
            return;
        }
        that->setActive(true);
        for (LogHandler *handler: that->activeHandlers_) {
            handler->message(msg, (LogLevel)level, category, *attr);
 80a2906:	b2f6      	uxtb	r6, r6
 80a2908:	eb05 0983 	add.w	r9, r5, r3, lsl #2
        // prevent re-entry
        if (that->isActive()) {
            return;
        }
        that->setActive(true);
        for (LogHandler *handler: that->activeHandlers_) {
 80a290c:	454d      	cmp	r5, r9
 80a290e:	d013      	beq.n	80a2938 <_ZN5spark10LogManager10logMessageEPKciS2_PK13LogAttributesPv+0x64>
 80a2910:	f855 7b04 	ldr.w	r7, [r5], #4
inline const char* spark::LogHandler::levelName(LogLevel level) {
    return log_level_name(level, nullptr);
}

inline void spark::LogHandler::message(const char *msg, LogLevel level, const char *category, const LogAttributes &attr) {
    if (level >= filter_.level(category)) {
 80a2914:	4641      	mov	r1, r8
 80a2916:	1d38      	adds	r0, r7, #4
 80a2918:	f7ff fe20 	bl	80a255c <_ZNK5spark6detail9LogFilter5levelEPKc>
 80a291c:	4286      	cmp	r6, r0
 80a291e:	d3f5      	bcc.n	80a290c <_ZN5spark10LogManager10logMessageEPKciS2_PK13LogAttributesPv+0x38>
        logMessage(msg, level, category, attr);
 80a2920:	683b      	ldr	r3, [r7, #0]
 80a2922:	f8cd b000 	str.w	fp, [sp]
 80a2926:	689b      	ldr	r3, [r3, #8]
 80a2928:	4638      	mov	r0, r7
 80a292a:	469e      	mov	lr, r3
 80a292c:	4632      	mov	r2, r6
 80a292e:	4643      	mov	r3, r8
 80a2930:	4651      	mov	r1, sl
 80a2932:	4677      	mov	r7, lr
 80a2934:	47b8      	blx	r7
 80a2936:	e7e9      	b.n	80a290c <_ZN5spark10LogManager10logMessageEPKciS2_PK13LogAttributesPv+0x38>
inline bool spark::LogManager::isActive() const {
    return outputActive_;
}

inline void spark::LogManager::setActive(bool outputActive) {
    outputActive_ = outputActive;
 80a2938:	2300      	movs	r3, #0
 80a293a:	7323      	strb	r3, [r4, #12]
#endif
    LogManager *that = instance();
    LOG_WITH_LOCK(that->mutex_) {
        // prevent re-entry
        if (that->isActive()) {
            return;
 80a293c:	a803      	add	r0, sp, #12
 80a293e:	f7ff ffc1 	bl	80a28c4 <_ZNSt10lock_guardI14RecursiveMutexED1Ev>
        for (LogHandler *handler: that->activeHandlers_) {
            handler->message(msg, (LogLevel)level, category, *attr);
        }
        that->setActive(false);
    }
}
 80a2942:	b005      	add	sp, #20
 80a2944:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80a2948:	e000ed00 	.word	0xe000ed00

080a294c <_ZN5spark10LogManager8logWriteEPKcjiS2_Pv>:

void spark::LogManager::logWrite(const char *data, size_t size, int level, const char *category, void *reserved) {
 80a294c:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80a2950:	4699      	mov	r9, r3
 80a2952:	4b19      	ldr	r3, [pc, #100]	; (80a29b8 <_ZN5spark10LogManager8logWriteEPKcjiS2_Pv+0x6c>)
 80a2954:	4607      	mov	r7, r0
 80a2956:	685b      	ldr	r3, [r3, #4]
 80a2958:	4688      	mov	r8, r1
#ifndef LOG_FROM_ISR
    if (HAL_IsISR()) {
 80a295a:	f3c3 0308 	ubfx	r3, r3, #0, #9
        }
        that->setActive(false);
    }
}

void spark::LogManager::logWrite(const char *data, size_t size, int level, const char *category, void *reserved) {
 80a295e:	4616      	mov	r6, r2
#ifndef LOG_FROM_ISR
    if (HAL_IsISR()) {
 80a2960:	bb33      	cbnz	r3, 80a29b0 <_ZN5spark10LogManager8logWriteEPKcjiS2_Pv+0x64>
        return;
    }
#endif
    LogManager *that = instance();
 80a2962:	f7ff fe75 	bl	80a2650 <_ZN5spark10LogManager8instanceEv>
 80a2966:	4604      	mov	r4, r0
    LOG_WITH_LOCK(that->mutex_) {
 80a2968:	3024      	adds	r0, #36	; 0x24
    class lock_guard
    {
    public:
      typedef _Mutex mutex_type;

      explicit lock_guard(mutex_type& __m) : _M_device(__m)
 80a296a:	9001      	str	r0, [sp, #4]
      { _M_device.lock(); }
 80a296c:	f7ff fd9a 	bl	80a24a4 <_ZN14RecursiveMutex4lockEv>
        // prevent re-entry
        if (that->isActive()) {
 80a2970:	7b23      	ldrb	r3, [r4, #12]
 80a2972:	b9d3      	cbnz	r3, 80a29aa <_ZN5spark10LogManager8logWriteEPKcjiS2_Pv+0x5e>
inline bool spark::LogManager::isActive() const {
    return outputActive_;
}

inline void spark::LogManager::setActive(bool outputActive) {
    outputActive_ = outputActive;
 80a2974:	2301      	movs	r3, #1
 80a2976:	7323      	strb	r3, [r4, #12]
 80a2978:	6825      	ldr	r5, [r4, #0]
 80a297a:	6863      	ldr	r3, [r4, #4]
    }
}

inline void spark::LogHandler::write(const char *data, size_t size, LogLevel level, const char *category) {
    if (level >= filter_.level(category)) {
 80a297c:	fa5f fb86 	uxtb.w	fp, r6
 80a2980:	eb05 0a83 	add.w	sl, r5, r3, lsl #2
        // prevent re-entry
        if (that->isActive()) {
            return;
        }
        that->setActive(true);
        for (LogHandler *handler: that->activeHandlers_) {
 80a2984:	4555      	cmp	r5, sl
 80a2986:	d00e      	beq.n	80a29a6 <_ZN5spark10LogManager8logWriteEPKcjiS2_Pv+0x5a>
 80a2988:	f855 6b04 	ldr.w	r6, [r5], #4
 80a298c:	4649      	mov	r1, r9
 80a298e:	1d30      	adds	r0, r6, #4
 80a2990:	f7ff fde4 	bl	80a255c <_ZNK5spark6detail9LogFilter5levelEPKc>
 80a2994:	4583      	cmp	fp, r0
 80a2996:	d3f5      	bcc.n	80a2984 <_ZN5spark10LogManager8logWriteEPKcjiS2_Pv+0x38>
        write(data, size);
 80a2998:	6833      	ldr	r3, [r6, #0]
 80a299a:	4642      	mov	r2, r8
 80a299c:	68db      	ldr	r3, [r3, #12]
 80a299e:	4639      	mov	r1, r7
 80a29a0:	4630      	mov	r0, r6
 80a29a2:	4798      	blx	r3
 80a29a4:	e7ee      	b.n	80a2984 <_ZN5spark10LogManager8logWriteEPKcjiS2_Pv+0x38>
inline bool spark::LogManager::isActive() const {
    return outputActive_;
}

inline void spark::LogManager::setActive(bool outputActive) {
    outputActive_ = outputActive;
 80a29a6:	2300      	movs	r3, #0
 80a29a8:	7323      	strb	r3, [r4, #12]
#endif
    LogManager *that = instance();
    LOG_WITH_LOCK(that->mutex_) {
        // prevent re-entry
        if (that->isActive()) {
            return;
 80a29aa:	a801      	add	r0, sp, #4
 80a29ac:	f7ff ff8a 	bl	80a28c4 <_ZNSt10lock_guardI14RecursiveMutexED1Ev>
        for (LogHandler *handler: that->activeHandlers_) {
            handler->write(data, size, (LogLevel)level, category);
        }
        that->setActive(false);
    }
}
 80a29b0:	b003      	add	sp, #12
 80a29b2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80a29b6:	bf00      	nop
 80a29b8:	e000ed00 	.word	0xe000ed00

080a29bc <_ZN5spark10LogManager10logEnabledEiPKcPv>:

int spark::LogManager::logEnabled(int level, const char *category, void *reserved) {
 80a29bc:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
 80a29c0:	4b15      	ldr	r3, [pc, #84]	; (80a2a18 <_ZN5spark10LogManager10logEnabledEiPKcPv+0x5c>)
 80a29c2:	4604      	mov	r4, r0
 80a29c4:	685b      	ldr	r3, [r3, #4]
 80a29c6:	4688      	mov	r8, r1
#ifndef LOG_FROM_ISR
    if (HAL_IsISR()) {
 80a29c8:	f3c3 0308 	ubfx	r3, r3, #0, #9
 80a29cc:	b9fb      	cbnz	r3, 80a2a0e <_ZN5spark10LogManager10logEnabledEiPKcPv+0x52>
        return 0;
    }
#endif
    LogManager *that = instance();
 80a29ce:	f7ff fe3f 	bl	80a2650 <_ZN5spark10LogManager8instanceEv>
 80a29d2:	4606      	mov	r6, r0
    int minLevel = LOG_LEVEL_NONE;
    LOG_WITH_LOCK(that->mutex_) {
 80a29d4:	3024      	adds	r0, #36	; 0x24
    class lock_guard
    {
    public:
      typedef _Mutex mutex_type;

      explicit lock_guard(mutex_type& __m) : _M_device(__m)
 80a29d6:	9001      	str	r0, [sp, #4]
      { _M_device.lock(); }
 80a29d8:	f7ff fd64 	bl	80a24a4 <_ZN14RecursiveMutex4lockEv>
 80a29dc:	e896 00a0 	ldmia.w	r6, {r5, r7}
 80a29e0:	2646      	movs	r6, #70	; 0x46
 80a29e2:	eb05 0787 	add.w	r7, r5, r7, lsl #2
        for (LogHandler *handler: that->activeHandlers_) {
 80a29e6:	42af      	cmp	r7, r5
 80a29e8:	d107      	bne.n	80a29fa <_ZN5spark10LogManager10logEnabledEiPKcPv+0x3e>
        return 0;
    }
#endif
    LogManager *that = instance();
    int minLevel = LOG_LEVEL_NONE;
    LOG_WITH_LOCK(that->mutex_) {
 80a29ea:	a801      	add	r0, sp, #4
 80a29ec:	f7ff ff6a 	bl	80a28c4 <_ZNSt10lock_guardI14RecursiveMutexED1Ev>
            if (level < minLevel) {
                minLevel = level;
            }
        }
    }
    return (level >= minLevel);
 80a29f0:	42b4      	cmp	r4, r6
 80a29f2:	bfb4      	ite	lt
 80a29f4:	2000      	movlt	r0, #0
 80a29f6:	2001      	movge	r0, #1
 80a29f8:	e00a      	b.n	80a2a10 <_ZN5spark10LogManager10logEnabledEiPKcPv+0x54>
inline LogLevel spark::LogHandler::level() const {
    return filter_.level();
}

inline LogLevel spark::LogHandler::level(const char *category) const {
    return filter_.level(category);
 80a29fa:	f855 0b04 	ldr.w	r0, [r5], #4
 80a29fe:	4641      	mov	r1, r8
 80a2a00:	3004      	adds	r0, #4
 80a2a02:	f7ff fdab 	bl	80a255c <_ZNK5spark6detail9LogFilter5levelEPKc>
 80a2a06:	4286      	cmp	r6, r0
 80a2a08:	bfa8      	it	ge
 80a2a0a:	4606      	movge	r6, r0
 80a2a0c:	e7eb      	b.n	80a29e6 <_ZN5spark10LogManager10logEnabledEiPKcPv+0x2a>
}

int spark::LogManager::logEnabled(int level, const char *category, void *reserved) {
#ifndef LOG_FROM_ISR
    if (HAL_IsISR()) {
        return 0;
 80a2a0e:	2000      	movs	r0, #0
                minLevel = level;
            }
        }
    }
    return (level >= minLevel);
}
 80a2a10:	b002      	add	sp, #8
 80a2a12:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 80a2a16:	bf00      	nop
 80a2a18:	e000ed00 	.word	0xe000ed00

080a2a1c <_ZN5spark6VectorIPNS_10LogHandlerENS_16DefaultAllocatorEE9removeOneERKS2_>:
    move(p, p + n, data_ + size_);
    size_ -= n;
}

template<typename T, typename AllocatorT>
inline bool spark::Vector<T, AllocatorT>::removeOne(const T &value) {
 80a2a1c:	b570      	push	{r4, r5, r6, lr}
 80a2a1e:	4604      	mov	r4, r0
    T* const p = find(data_, data_ + size_, value);
 80a2a20:	6803      	ldr	r3, [r0, #0]
 80a2a22:	6842      	ldr	r2, [r0, #4]
 80a2a24:	eb03 0282 	add.w	r2, r3, r2, lsl #2
            }
        }
    }

    static T* find(T* p, const T* end, const T& value) {
        for (; p != end; ++p) {
 80a2a28:	429a      	cmp	r2, r3
 80a2a2a:	4618      	mov	r0, r3
 80a2a2c:	d00d      	beq.n	80a2a4a <_ZN5spark6VectorIPNS_10LogHandlerENS_16DefaultAllocatorEE9removeOneERKS2_+0x2e>
            if (*p == value) {
 80a2a2e:	6806      	ldr	r6, [r0, #0]
 80a2a30:	680d      	ldr	r5, [r1, #0]
 80a2a32:	3304      	adds	r3, #4
 80a2a34:	42ae      	cmp	r6, r5
 80a2a36:	d1f7      	bne.n	80a2a28 <_ZN5spark6VectorIPNS_10LogHandlerENS_16DefaultAllocatorEE9removeOneERKS2_+0xc>
    T* const p = find(data_, data_ + size_, value);
    if (!p) {
        return false;
    }
    p->~T();
    move(p, p + 1, data_ + size_);
 80a2a38:	1d01      	adds	r1, r0, #4
        }
    }

    template<PARTICLE_VECTOR_ENABLE_IF_TRIVIALLY_COPYABLE(T)>
    static void move(T* dest, const T* p, const T* end) {
        ::memmove(dest, p, (end - p) * sizeof(T));
 80a2a3a:	1a52      	subs	r2, r2, r1
 80a2a3c:	f001 f949 	bl	80a3cd2 <memmove>
    if (!p) {
        return false;
    }
    p->~T();
    move(p, p + 1, data_ + size_);
    --size_;
 80a2a40:	6863      	ldr	r3, [r4, #4]
    return true;
 80a2a42:	2001      	movs	r0, #1
    if (!p) {
        return false;
    }
    p->~T();
    move(p, p + 1, data_ + size_);
    --size_;
 80a2a44:	3b01      	subs	r3, #1
 80a2a46:	6063      	str	r3, [r4, #4]
    return true;
}
 80a2a48:	bd70      	pop	{r4, r5, r6, pc}

template<typename T, typename AllocatorT>
inline bool spark::Vector<T, AllocatorT>::removeOne(const T &value) {
    T* const p = find(data_, data_ + size_, value);
    if (!p) {
        return false;
 80a2a4a:	2000      	movs	r0, #0
 80a2a4c:	bd70      	pop	{r4, r5, r6, pc}

080a2a4e <_ZN5spark10LogManager13removeHandlerEPNS_10LogHandlerE>:
        }
    }
    return true;
}

void spark::LogManager::removeHandler(LogHandler *handler) {
 80a2a4e:	b51f      	push	{r0, r1, r2, r3, r4, lr}
 80a2a50:	4604      	mov	r4, r0
    LOG_WITH_LOCK(mutex_) {
 80a2a52:	3024      	adds	r0, #36	; 0x24
        }
    }
    return true;
}

void spark::LogManager::removeHandler(LogHandler *handler) {
 80a2a54:	9101      	str	r1, [sp, #4]
    class lock_guard
    {
    public:
      typedef _Mutex mutex_type;

      explicit lock_guard(mutex_type& __m) : _M_device(__m)
 80a2a56:	9003      	str	r0, [sp, #12]
      { _M_device.lock(); }
 80a2a58:	f7ff fd24 	bl	80a24a4 <_ZN14RecursiveMutex4lockEv>
    LOG_WITH_LOCK(mutex_) {
        if (activeHandlers_.removeOne(handler) && activeHandlers_.isEmpty()) {
 80a2a5c:	a901      	add	r1, sp, #4
 80a2a5e:	4620      	mov	r0, r4
 80a2a60:	f7ff ffdc 	bl	80a2a1c <_ZN5spark6VectorIPNS_10LogHandlerENS_16DefaultAllocatorEE9removeOneERKS2_>
 80a2a64:	b920      	cbnz	r0, 80a2a70 <_ZN5spark10LogManager13removeHandlerEPNS_10LogHandlerE+0x22>
    }
    return true;
}

void spark::LogManager::removeHandler(LogHandler *handler) {
    LOG_WITH_LOCK(mutex_) {
 80a2a66:	a803      	add	r0, sp, #12
 80a2a68:	f7ff ff2c 	bl	80a28c4 <_ZNSt10lock_guardI14RecursiveMutexED1Ev>
        if (activeHandlers_.removeOne(handler) && activeHandlers_.isEmpty()) {
            resetSystemCallbacks();
        }
    }
}
 80a2a6c:	b004      	add	sp, #16
 80a2a6e:	bd10      	pop	{r4, pc}
    return true;
}

void spark::LogManager::removeHandler(LogHandler *handler) {
    LOG_WITH_LOCK(mutex_) {
        if (activeHandlers_.removeOne(handler) && activeHandlers_.isEmpty()) {
 80a2a70:	6863      	ldr	r3, [r4, #4]
 80a2a72:	2b00      	cmp	r3, #0
 80a2a74:	d1f7      	bne.n	80a2a66 <_ZN5spark10LogManager13removeHandlerEPNS_10LogHandlerE+0x18>
            resetSystemCallbacks();
 80a2a76:	f7ff fe15 	bl	80a26a4 <_ZN5spark10LogManager20resetSystemCallbacksEv>
 80a2a7a:	e7f4      	b.n	80a2a66 <_ZN5spark10LogManager13removeHandlerEPNS_10LogHandlerE+0x18>

080a2a7c <_ZN5spark10LogManager22destroyFactoryHandlersEv>:
            break;
        }
    }
}

void spark::LogManager::destroyFactoryHandlers() {
 80a2a7c:	b570      	push	{r4, r5, r6, lr}
 80a2a7e:	4604      	mov	r4, r0
 80a2a80:	6905      	ldr	r5, [r0, #16]
    return data_;
}

template<typename T, typename AllocatorT>
T* spark::Vector<T, AllocatorT>::end() {
    return data_ + size_;
 80a2a82:	6943      	ldr	r3, [r0, #20]
 80a2a84:	2618      	movs	r6, #24
 80a2a86:	fb06 5603 	mla	r6, r6, r3, r5
    for (const FactoryHandler &h: factoryHandlers_) {
 80a2a8a:	42ae      	cmp	r6, r5
 80a2a8c:	d015      	beq.n	80a2aba <_ZN5spark10LogManager22destroyFactoryHandlersEv+0x3e>
        activeHandlers_.removeOne(h.handler);
 80a2a8e:	f105 0110 	add.w	r1, r5, #16
 80a2a92:	4620      	mov	r0, r4
 80a2a94:	f7ff ffc2 	bl	80a2a1c <_ZN5spark6VectorIPNS_10LogHandlerENS_16DefaultAllocatorEE9removeOneERKS2_>
        if (activeHandlers_.isEmpty()) {
 80a2a98:	6863      	ldr	r3, [r4, #4]
 80a2a9a:	b90b      	cbnz	r3, 80a2aa0 <_ZN5spark10LogManager22destroyFactoryHandlersEv+0x24>
            resetSystemCallbacks();
 80a2a9c:	f7ff fe02 	bl	80a26a4 <_ZN5spark10LogManager20resetSystemCallbacksEv>
        }
        handlerFactory_->destroyHandler(h.handler);
 80a2aa0:	69e0      	ldr	r0, [r4, #28]
 80a2aa2:	6929      	ldr	r1, [r5, #16]
 80a2aa4:	6803      	ldr	r3, [r0, #0]
 80a2aa6:	68db      	ldr	r3, [r3, #12]
 80a2aa8:	4798      	blx	r3
        if (h.stream) {
 80a2aaa:	6969      	ldr	r1, [r5, #20]
 80a2aac:	b119      	cbz	r1, 80a2ab6 <_ZN5spark10LogManager22destroyFactoryHandlersEv+0x3a>
            streamFactory_->destroyStream(h.stream);
 80a2aae:	6a20      	ldr	r0, [r4, #32]
 80a2ab0:	6803      	ldr	r3, [r0, #0]
 80a2ab2:	68db      	ldr	r3, [r3, #12]
 80a2ab4:	4798      	blx	r3
 80a2ab6:	3518      	adds	r5, #24
        }
    }
}

void spark::LogManager::destroyFactoryHandlers() {
    for (const FactoryHandler &h: factoryHandlers_) {
 80a2ab8:	e7e7      	b.n	80a2a8a <_ZN5spark10LogManager22destroyFactoryHandlersEv+0xe>
    return true;
}

template<typename T, typename AllocatorT>
inline void spark::Vector<T, AllocatorT>::clear() {
    destruct(data_, data_ + size_);
 80a2aba:	6925      	ldr	r5, [r4, #16]
 80a2abc:	6963      	ldr	r3, [r4, #20]
 80a2abe:	2618      	movs	r6, #24
 80a2ac0:	fb06 5603 	mla	r6, r6, r3, r5
            new(p) T(std::forward<ArgsT>(args)...);
        }
    }

    static void destruct(T* p, const T* end) {
        for (; p != end; ++p) {
 80a2ac4:	42b5      	cmp	r5, r6
 80a2ac6:	d004      	beq.n	80a2ad2 <_ZN5spark10LogManager22destroyFactoryHandlersEv+0x56>
        }
    }
}

// spark::LogManager
struct spark::LogManager::FactoryHandler {
 80a2ac8:	4628      	mov	r0, r5
 80a2aca:	f000 fe5d 	bl	80a3788 <_ZN6StringD1Ev>
 80a2ace:	3518      	adds	r5, #24
 80a2ad0:	e7f8      	b.n	80a2ac4 <_ZN5spark10LogManager22destroyFactoryHandlersEv+0x48>
}

template<typename T, typename AllocatorT>
inline void spark::Vector<T, AllocatorT>::clear() {
    destruct(data_, data_ + size_);
    size_ = 0;
 80a2ad2:	2300      	movs	r3, #0
 80a2ad4:	6163      	str	r3, [r4, #20]
 80a2ad6:	bd70      	pop	{r4, r5, r6, pc}

080a2ad8 <_ZN5spark10LogManagerD1Ev>:
    streamFactory_ = DefaultOutputStreamFactory::instance();
#endif
    outputActive_ = false;
}

spark::LogManager::~LogManager() {
 80a2ad8:	b573      	push	{r0, r1, r4, r5, r6, lr}
 80a2ada:	4604      	mov	r4, r0
    class lock_guard
    {
    public:
      typedef _Mutex mutex_type;

      explicit lock_guard(mutex_type& __m) : _M_device(__m)
 80a2adc:	ad02      	add	r5, sp, #8
    resetSystemCallbacks();
 80a2ade:	f7ff fde1 	bl	80a26a4 <_ZN5spark10LogManager20resetSystemCallbacksEv>
#if Wiring_LogConfig
    LOG_WITH_LOCK(mutex_) {
 80a2ae2:	f104 0024 	add.w	r0, r4, #36	; 0x24
 80a2ae6:	f845 0d04 	str.w	r0, [r5, #-4]!
      { _M_device.lock(); }
 80a2aea:	f7ff fcdb 	bl	80a24a4 <_ZN14RecursiveMutex4lockEv>
         destroyFactoryHandlers();
 80a2aee:	4620      	mov	r0, r4
 80a2af0:	f7ff ffc4 	bl	80a2a7c <_ZN5spark10LogManager22destroyFactoryHandlersEv>
}

spark::LogManager::~LogManager() {
    resetSystemCallbacks();
#if Wiring_LogConfig
    LOG_WITH_LOCK(mutex_) {
 80a2af4:	4628      	mov	r0, r5
 80a2af6:	f7ff fee5 	bl	80a28c4 <_ZNSt10lock_guardI14RecursiveMutexED1Ev>
        dispose();
    }

    void dispose()
    {
        if (handle_) {
 80a2afa:	6a60      	ldr	r0, [r4, #36]	; 0x24
 80a2afc:	b108      	cbz	r0, 80a2b02 <_ZN5spark10LogManagerD1Ev+0x2a>
            os_mutex_recursive_destroy(handle_);
 80a2afe:	f7fe fe03 	bl	80a1708 <os_mutex_recursive_destroy>
    swap(*this, vector);
}

template<typename T, typename AllocatorT>
inline spark::Vector<T, AllocatorT>::~Vector() {
    destruct(data_, data_ + size_);
 80a2b02:	6925      	ldr	r5, [r4, #16]
 80a2b04:	6963      	ldr	r3, [r4, #20]
 80a2b06:	2618      	movs	r6, #24
 80a2b08:	fb06 5603 	mla	r6, r6, r3, r5
            new(p) T(std::forward<ArgsT>(args)...);
        }
    }

    static void destruct(T* p, const T* end) {
        for (; p != end; ++p) {
 80a2b0c:	42b5      	cmp	r5, r6
 80a2b0e:	d004      	beq.n	80a2b1a <_ZN5spark10LogManagerD1Ev+0x42>
        }
    }
}

// spark::LogManager
struct spark::LogManager::FactoryHandler {
 80a2b10:	4628      	mov	r0, r5
 80a2b12:	f000 fe39 	bl	80a3788 <_ZN6StringD1Ev>
 80a2b16:	3518      	adds	r5, #24
 80a2b18:	e7f8      	b.n	80a2b0c <_ZN5spark10LogManagerD1Ev+0x34>
inline void* spark::DefaultAllocator::realloc(void* ptr, size_t size) {
    return ::realloc(ptr, size);
}

inline void spark::DefaultAllocator::free(void* ptr) {
    ::free(ptr);
 80a2b1a:	6920      	ldr	r0, [r4, #16]
 80a2b1c:	f7fe ff18 	bl	80a1950 <free>
 80a2b20:	6820      	ldr	r0, [r4, #0]
 80a2b22:	f7fe ff15 	bl	80a1950 <free>
#if Wiring_LogConfig
    LOG_WITH_LOCK(mutex_) {
         destroyFactoryHandlers();
    }
#endif
}
 80a2b26:	4620      	mov	r0, r4
 80a2b28:	b002      	add	sp, #8
 80a2b2a:	bd70      	pop	{r4, r5, r6, pc}

080a2b2c <_ZN5spark4swapINS_17LogCategoryFilterENS_16DefaultAllocatorEEEvRNS_6VectorIT_T0_EES7_>:
#endif
    {
      // concept requirements
      __glibcxx_function_requires(_SGIAssignableConcept<_Tp>)

      _Tp __tmp = _GLIBCXX_MOVE(__a);
 80a2b2c:	6803      	ldr	r3, [r0, #0]
      __a = _GLIBCXX_MOVE(__b);
 80a2b2e:	680a      	ldr	r2, [r1, #0]
 80a2b30:	6002      	str	r2, [r0, #0]
      __b = _GLIBCXX_MOVE(__tmp);
 80a2b32:	600b      	str	r3, [r1, #0]
#endif
    {
      // concept requirements
      __glibcxx_function_requires(_SGIAssignableConcept<_Tp>)

      _Tp __tmp = _GLIBCXX_MOVE(__a);
 80a2b34:	6843      	ldr	r3, [r0, #4]
      __a = _GLIBCXX_MOVE(__b);
 80a2b36:	684a      	ldr	r2, [r1, #4]
 80a2b38:	6042      	str	r2, [r0, #4]
      __b = _GLIBCXX_MOVE(__tmp);
 80a2b3a:	604b      	str	r3, [r1, #4]
#endif
    {
      // concept requirements
      __glibcxx_function_requires(_SGIAssignableConcept<_Tp>)

      _Tp __tmp = _GLIBCXX_MOVE(__a);
 80a2b3c:	6883      	ldr	r3, [r0, #8]
      __a = _GLIBCXX_MOVE(__b);
 80a2b3e:	688a      	ldr	r2, [r1, #8]
 80a2b40:	6082      	str	r2, [r0, #8]
      __b = _GLIBCXX_MOVE(__tmp);
 80a2b42:	608b      	str	r3, [r1, #8]
 80a2b44:	4770      	bx	lr

080a2b46 <_ZN5spark6VectorINS_17LogCategoryFilterENS_16DefaultAllocatorEEC1EOS3_>:
        size_ = vector.size_;
    }
}

template<typename T, typename AllocatorT>
inline spark::Vector<T, AllocatorT>::Vector(Vector<T, AllocatorT>&& vector) : Vector() {
 80a2b46:	b510      	push	{r4, lr}
 80a2b48:	4604      	mov	r4, r0
// spark::Vector
template<typename T, typename AllocatorT>
inline spark::Vector<T, AllocatorT>::Vector() :
        data_(nullptr),
        size_(0),
        capacity_(0) {
 80a2b4a:	2300      	movs	r3, #0
 80a2b4c:	6003      	str	r3, [r0, #0]
 80a2b4e:	6043      	str	r3, [r0, #4]
 80a2b50:	6083      	str	r3, [r0, #8]
    }
}

template<typename T, typename AllocatorT>
inline spark::Vector<T, AllocatorT>::Vector(Vector<T, AllocatorT>&& vector) : Vector() {
    swap(*this, vector);
 80a2b52:	f7ff ffeb 	bl	80a2b2c <_ZN5spark4swapINS_17LogCategoryFilterENS_16DefaultAllocatorEEEvRNS_6VectorIT_T0_EES7_>
}
 80a2b56:	4620      	mov	r0, r4
 80a2b58:	bd10      	pop	{r4, pc}

080a2b5a <_ZN5spark6VectorINS_6detail9LogFilter4NodeENS_16DefaultAllocatorEE4moveIS3_Li0EEEvPS3_S7_S7_>:
        ::memmove(dest, p, (end - p) * sizeof(T));
    }

    template<PARTICLE_VECTOR_ENABLE_IF_NOT_TRIVIALLY_COPYABLE(T)>
    static void move(T* dest, T* p, T* end) {
        if (dest > p && dest < end) {
 80a2b5a:	4288      	cmp	r0, r1
    static void move(T* dest, const T* p, const T* end) {
        ::memmove(dest, p, (end - p) * sizeof(T));
    }

    template<PARTICLE_VECTOR_ENABLE_IF_NOT_TRIVIALLY_COPYABLE(T)>
    static void move(T* dest, T* p, T* end) {
 80a2b5c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80a2b5e:	4604      	mov	r4, r0
 80a2b60:	4616      	mov	r6, r2
        if (dest > p && dest < end) {
 80a2b62:	d925      	bls.n	80a2bb0 <_ZN5spark6VectorINS_6detail9LogFilter4NodeENS_16DefaultAllocatorEE4moveIS3_Li0EEEvPS3_S7_S7_+0x56>
 80a2b64:	4290      	cmp	r0, r2
 80a2b66:	d224      	bcs.n	80a2bb2 <_ZN5spark6VectorINS_6detail9LogFilter4NodeENS_16DefaultAllocatorEE4moveIS3_Li0EEEvPS3_S7_S7_+0x58>
            // Move elements in reverse order
            --p;
            --end;
            dest += end - p - 1;
 80a2b68:	1a55      	subs	r5, r2, r1
 80a2b6a:	3d14      	subs	r5, #20
 80a2b6c:	442c      	add	r4, r5
 80a2b6e:	f1a1 0714 	sub.w	r7, r1, #20
 80a2b72:	f1a2 050c 	sub.w	r5, r2, #12
// spark::Vector
template<typename T, typename AllocatorT>
inline spark::Vector<T, AllocatorT>::Vector() :
        data_(nullptr),
        size_(0),
        capacity_(0) {
 80a2b76:	2600      	movs	r6, #0
        if (dest > p && dest < end) {
            // Move elements in reverse order
            --p;
            --end;
            dest += end - p - 1;
            for (; end != p; --end, --dest) {
 80a2b78:	f1a5 0308 	sub.w	r3, r5, #8
 80a2b7c:	429f      	cmp	r7, r3
 80a2b7e:	d037      	beq.n	80a2bf0 <_ZN5spark6VectorINS_6detail9LogFilter4NodeENS_16DefaultAllocatorEE4moveIS3_Li0EEEvPS3_S7_S7_+0x96>
                new(dest) T(std::move(*end));
 80a2b80:	b184      	cbz	r4, 80a2ba4 <_ZN5spark6VectorINS_6detail9LogFilter4NodeENS_16DefaultAllocatorEE4moveIS3_Li0EEEvPS3_S7_S7_+0x4a>
    |
    `- aa (error) - b (warn)
*/

// spark::detail::LogFilter
struct spark::detail::LogFilter::Node {
 80a2b82:	f855 3c08 	ldr.w	r3, [r5, #-8]
    }
}

template<typename T, typename AllocatorT>
inline spark::Vector<T, AllocatorT>::Vector(Vector<T, AllocatorT>&& vector) : Vector() {
    swap(*this, vector);
 80a2b86:	4629      	mov	r1, r5
 80a2b88:	6023      	str	r3, [r4, #0]
 80a2b8a:	f835 3c04 	ldrh.w	r3, [r5, #-4]
 80a2b8e:	f104 0008 	add.w	r0, r4, #8
 80a2b92:	80a3      	strh	r3, [r4, #4]
 80a2b94:	f935 3c02 	ldrsh.w	r3, [r5, #-2]
// spark::Vector
template<typename T, typename AllocatorT>
inline spark::Vector<T, AllocatorT>::Vector() :
        data_(nullptr),
        size_(0),
        capacity_(0) {
 80a2b98:	60a6      	str	r6, [r4, #8]
 80a2b9a:	80e3      	strh	r3, [r4, #6]
 80a2b9c:	60e6      	str	r6, [r4, #12]
 80a2b9e:	6126      	str	r6, [r4, #16]
    }
}

template<typename T, typename AllocatorT>
inline spark::Vector<T, AllocatorT>::Vector(Vector<T, AllocatorT>&& vector) : Vector() {
    swap(*this, vector);
 80a2ba0:	f7ff ffc4 	bl	80a2b2c <_ZN5spark4swapINS_17LogCategoryFilterENS_16DefaultAllocatorEEEvRNS_6VectorIT_T0_EES7_>
 80a2ba4:	4628      	mov	r0, r5
 80a2ba6:	f7ff fe33 	bl	80a2810 <_ZN5spark6VectorINS_6detail9LogFilter4NodeENS_16DefaultAllocatorEED1Ev>
        if (dest > p && dest < end) {
            // Move elements in reverse order
            --p;
            --end;
            dest += end - p - 1;
            for (; end != p; --end, --dest) {
 80a2baa:	3c14      	subs	r4, #20
 80a2bac:	3d14      	subs	r5, #20
 80a2bae:	e7e3      	b.n	80a2b78 <_ZN5spark6VectorINS_6detail9LogFilter4NodeENS_16DefaultAllocatorEE4moveIS3_Li0EEEvPS3_S7_S7_+0x1e>
                new(dest) T(std::move(*end));
                end->~T();
            }
        } else if (dest != p) {
 80a2bb0:	d01e      	beq.n	80a2bf0 <_ZN5spark6VectorINS_6detail9LogFilter4NodeENS_16DefaultAllocatorEE4moveIS3_Li0EEEvPS3_S7_S7_+0x96>
 80a2bb2:	f101 0508 	add.w	r5, r1, #8
// spark::Vector
template<typename T, typename AllocatorT>
inline spark::Vector<T, AllocatorT>::Vector() :
        data_(nullptr),
        size_(0),
        capacity_(0) {
 80a2bb6:	2700      	movs	r7, #0
            for (; end != p; --end, --dest) {
                new(dest) T(std::move(*end));
                end->~T();
            }
        } else if (dest != p) {
            for (; p != end; ++p, ++dest) {
 80a2bb8:	f1a5 0308 	sub.w	r3, r5, #8
 80a2bbc:	429e      	cmp	r6, r3
 80a2bbe:	d017      	beq.n	80a2bf0 <_ZN5spark6VectorINS_6detail9LogFilter4NodeENS_16DefaultAllocatorEE4moveIS3_Li0EEEvPS3_S7_S7_+0x96>
                new(dest) T(std::move(*p));
 80a2bc0:	b184      	cbz	r4, 80a2be4 <_ZN5spark6VectorINS_6detail9LogFilter4NodeENS_16DefaultAllocatorEE4moveIS3_Li0EEEvPS3_S7_S7_+0x8a>
 80a2bc2:	f855 3c08 	ldr.w	r3, [r5, #-8]
    }
}

template<typename T, typename AllocatorT>
inline spark::Vector<T, AllocatorT>::Vector(Vector<T, AllocatorT>&& vector) : Vector() {
    swap(*this, vector);
 80a2bc6:	4629      	mov	r1, r5
 80a2bc8:	6023      	str	r3, [r4, #0]
 80a2bca:	f835 3c04 	ldrh.w	r3, [r5, #-4]
 80a2bce:	f104 0008 	add.w	r0, r4, #8
 80a2bd2:	80a3      	strh	r3, [r4, #4]
 80a2bd4:	f935 3c02 	ldrsh.w	r3, [r5, #-2]
// spark::Vector
template<typename T, typename AllocatorT>
inline spark::Vector<T, AllocatorT>::Vector() :
        data_(nullptr),
        size_(0),
        capacity_(0) {
 80a2bd8:	60a7      	str	r7, [r4, #8]
 80a2bda:	80e3      	strh	r3, [r4, #6]
 80a2bdc:	60e7      	str	r7, [r4, #12]
 80a2bde:	6127      	str	r7, [r4, #16]
    }
}

template<typename T, typename AllocatorT>
inline spark::Vector<T, AllocatorT>::Vector(Vector<T, AllocatorT>&& vector) : Vector() {
    swap(*this, vector);
 80a2be0:	f7ff ffa4 	bl	80a2b2c <_ZN5spark4swapINS_17LogCategoryFilterENS_16DefaultAllocatorEEEvRNS_6VectorIT_T0_EES7_>
 80a2be4:	4628      	mov	r0, r5
 80a2be6:	f7ff fe13 	bl	80a2810 <_ZN5spark6VectorINS_6detail9LogFilter4NodeENS_16DefaultAllocatorEED1Ev>
            for (; end != p; --end, --dest) {
                new(dest) T(std::move(*end));
                end->~T();
            }
        } else if (dest != p) {
            for (; p != end; ++p, ++dest) {
 80a2bea:	3414      	adds	r4, #20
 80a2bec:	3514      	adds	r5, #20
 80a2bee:	e7e3      	b.n	80a2bb8 <_ZN5spark6VectorINS_6detail9LogFilter4NodeENS_16DefaultAllocatorEE4moveIS3_Li0EEEvPS3_S7_S7_+0x5e>
 80a2bf0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

080a2bf2 <_ZN5spark6VectorIPNS_10LogHandlerENS_16DefaultAllocatorEE6insertEiS2_>:
inline bool spark::Vector<T, AllocatorT>::prepend(const Vector<T, AllocatorT> &vector) {
    return insert(0, vector);
}

template<typename T, typename AllocatorT>
inline bool spark::Vector<T, AllocatorT>::insert(int i, T value) {
 80a2bf2:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    if (size_ + 1 > capacity_ && !realloc(size_ + 1)) {
 80a2bf4:	6845      	ldr	r5, [r0, #4]
 80a2bf6:	6883      	ldr	r3, [r0, #8]
inline bool spark::Vector<T, AllocatorT>::prepend(const Vector<T, AllocatorT> &vector) {
    return insert(0, vector);
}

template<typename T, typename AllocatorT>
inline bool spark::Vector<T, AllocatorT>::insert(int i, T value) {
 80a2bf8:	4604      	mov	r4, r0
    if (size_ + 1 > capacity_ && !realloc(size_ + 1)) {
 80a2bfa:	429d      	cmp	r5, r3
inline bool spark::Vector<T, AllocatorT>::prepend(const Vector<T, AllocatorT> &vector) {
    return insert(0, vector);
}

template<typename T, typename AllocatorT>
inline bool spark::Vector<T, AllocatorT>::insert(int i, T value) {
 80a2bfc:	460e      	mov	r6, r1
 80a2bfe:	4617      	mov	r7, r2
    if (size_ + 1 > capacity_ && !realloc(size_ + 1)) {
 80a2c00:	db0e      	blt.n	80a2c20 <_ZN5spark6VectorIPNS_10LogHandlerENS_16DefaultAllocatorEE6insertEiS2_+0x2e>
 80a2c02:	3501      	adds	r5, #1
    int size_, capacity_;

    template<PARTICLE_VECTOR_ENABLE_IF_TRIVIALLY_COPYABLE(T)>
    bool realloc(int n) {
        T* d = nullptr;
        if (n > 0) {
 80a2c04:	2d00      	cmp	r5, #0
 80a2c06:	dd05      	ble.n	80a2c14 <_ZN5spark6VectorIPNS_10LogHandlerENS_16DefaultAllocatorEE6insertEiS2_+0x22>
inline void* spark::DefaultAllocator::malloc(size_t size) {
    return ::malloc(size);
}

inline void* spark::DefaultAllocator::realloc(void* ptr, size_t size) {
    return ::realloc(ptr, size);
 80a2c08:	00a9      	lsls	r1, r5, #2
 80a2c0a:	6800      	ldr	r0, [r0, #0]
 80a2c0c:	f7fe fea8 	bl	80a1960 <realloc>
    template<PARTICLE_VECTOR_ENABLE_IF_TRIVIALLY_COPYABLE(T)>
    bool realloc(int n) {
        T* d = nullptr;
        if (n > 0) {
            d = (T*)AllocatorT::realloc(data_, n * sizeof(T));
            if (!d) {
 80a2c10:	b920      	cbnz	r0, 80a2c1c <_ZN5spark6VectorIPNS_10LogHandlerENS_16DefaultAllocatorEE6insertEiS2_+0x2a>
 80a2c12:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
inline void* spark::DefaultAllocator::realloc(void* ptr, size_t size) {
    return ::realloc(ptr, size);
}

inline void spark::DefaultAllocator::free(void* ptr) {
    ::free(ptr);
 80a2c14:	6800      	ldr	r0, [r0, #0]
 80a2c16:	f7fe fe9b 	bl	80a1950 <free>
    T* data_;
    int size_, capacity_;

    template<PARTICLE_VECTOR_ENABLE_IF_TRIVIALLY_COPYABLE(T)>
    bool realloc(int n) {
        T* d = nullptr;
 80a2c1a:	2000      	movs	r0, #0
                return false;
            }
        } else {
            AllocatorT::free(data_);
        }
        data_ = d;
 80a2c1c:	6020      	str	r0, [r4, #0]
        capacity_ = n;
 80a2c1e:	60a5      	str	r5, [r4, #8]
template<typename T, typename AllocatorT>
inline bool spark::Vector<T, AllocatorT>::insert(int i, T value) {
    if (size_ + 1 > capacity_ && !realloc(size_ + 1)) {
        return false;
    }
    T* const p = data_ + i;
 80a2c20:	6825      	ldr	r5, [r4, #0]
        }
    }

    template<PARTICLE_VECTOR_ENABLE_IF_TRIVIALLY_COPYABLE(T)>
    static void move(T* dest, const T* p, const T* end) {
        ::memmove(dest, p, (end - p) * sizeof(T));
 80a2c22:	6862      	ldr	r2, [r4, #4]
template<typename T, typename AllocatorT>
inline bool spark::Vector<T, AllocatorT>::insert(int i, T value) {
    if (size_ + 1 > capacity_ && !realloc(size_ + 1)) {
        return false;
    }
    T* const p = data_ + i;
 80a2c24:	eb05 0186 	add.w	r1, r5, r6, lsl #2
        }
    }

    template<PARTICLE_VECTOR_ENABLE_IF_TRIVIALLY_COPYABLE(T)>
    static void move(T* dest, const T* p, const T* end) {
        ::memmove(dest, p, (end - p) * sizeof(T));
 80a2c28:	eb05 0282 	add.w	r2, r5, r2, lsl #2
 80a2c2c:	1a52      	subs	r2, r2, r1
 80a2c2e:	1d08      	adds	r0, r1, #4
 80a2c30:	f001 f84f 	bl	80a3cd2 <memmove>
    if (size_ + 1 > capacity_ && !realloc(size_ + 1)) {
        return false;
    }
    T* const p = data_ + i;
    move(p + 1, p, data_ + size_);
    new(p) T(std::move(value));
 80a2c34:	f845 7026 	str.w	r7, [r5, r6, lsl #2]
    ++size_;
 80a2c38:	6863      	ldr	r3, [r4, #4]
 80a2c3a:	2001      	movs	r0, #1
 80a2c3c:	3301      	adds	r3, #1
 80a2c3e:	6063      	str	r3, [r4, #4]
    return true;
}
 80a2c40:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

080a2c42 <_ZN5spark10LogManager10addHandlerEPNS_10LogHandlerE>:
         destroyFactoryHandlers();
    }
#endif
}

bool spark::LogManager::addHandler(LogHandler *handler) {
 80a2c42:	b537      	push	{r0, r1, r2, r4, r5, lr}
 80a2c44:	4604      	mov	r4, r0
    LOG_WITH_LOCK(mutex_) {
 80a2c46:	3024      	adds	r0, #36	; 0x24
         destroyFactoryHandlers();
    }
#endif
}

bool spark::LogManager::addHandler(LogHandler *handler) {
 80a2c48:	460d      	mov	r5, r1
    class lock_guard
    {
    public:
      typedef _Mutex mutex_type;

      explicit lock_guard(mutex_type& __m) : _M_device(__m)
 80a2c4a:	9001      	str	r0, [sp, #4]
      { _M_device.lock(); }
 80a2c4c:	f7ff fc2a 	bl	80a24a4 <_ZN14RecursiveMutex4lockEv>
    return p - data_;
}

template<typename T, typename AllocatorT>
inline bool spark::Vector<T, AllocatorT>::contains(const T &value) const {
    return find(data_, data_ + size_, value);
 80a2c50:	6823      	ldr	r3, [r4, #0]
 80a2c52:	6861      	ldr	r1, [r4, #4]
 80a2c54:	eb03 0081 	add.w	r0, r3, r1, lsl #2
            }
        }
    }

    static T* find(T* p, const T* end, const T& value) {
        for (; p != end; ++p) {
 80a2c58:	4283      	cmp	r3, r0
 80a2c5a:	461a      	mov	r2, r3
 80a2c5c:	d008      	beq.n	80a2c70 <_ZN5spark10LogManager10addHandlerEPNS_10LogHandlerE+0x2e>
            if (*p == value) {
 80a2c5e:	6812      	ldr	r2, [r2, #0]
 80a2c60:	3304      	adds	r3, #4
 80a2c62:	42aa      	cmp	r2, r5
 80a2c64:	d1f8      	bne.n	80a2c58 <_ZN5spark10LogManager10addHandlerEPNS_10LogHandlerE+0x16>
    LOG_WITH_LOCK(mutex_) {
        if (activeHandlers_.contains(handler) || !activeHandlers_.append(handler)) {
            return false;
 80a2c66:	a801      	add	r0, sp, #4
 80a2c68:	f7ff fe2c 	bl	80a28c4 <_ZNSt10lock_guardI14RecursiveMutexED1Ev>
 80a2c6c:	2500      	movs	r5, #0
 80a2c6e:	e00e      	b.n	80a2c8e <_ZN5spark10LogManager10addHandlerEPNS_10LogHandlerE+0x4c>
    AllocatorT::free(data_);
}

template<typename T, typename AllocatorT>
inline bool spark::Vector<T, AllocatorT>::append(T value) {
    return insert(size_, std::move(value));
 80a2c70:	462a      	mov	r2, r5
 80a2c72:	4620      	mov	r0, r4
 80a2c74:	f7ff ffbd 	bl	80a2bf2 <_ZN5spark6VectorIPNS_10LogHandlerENS_16DefaultAllocatorEE6insertEiS2_>
#endif
}

bool spark::LogManager::addHandler(LogHandler *handler) {
    LOG_WITH_LOCK(mutex_) {
        if (activeHandlers_.contains(handler) || !activeHandlers_.append(handler)) {
 80a2c78:	4605      	mov	r5, r0
 80a2c7a:	2800      	cmp	r0, #0
 80a2c7c:	d0f3      	beq.n	80a2c66 <_ZN5spark10LogManager10addHandlerEPNS_10LogHandlerE+0x24>
            return false;
        }
        if (activeHandlers_.size() == 1) {
 80a2c7e:	6863      	ldr	r3, [r4, #4]
 80a2c80:	2b01      	cmp	r3, #1
 80a2c82:	d101      	bne.n	80a2c88 <_ZN5spark10LogManager10addHandlerEPNS_10LogHandlerE+0x46>
            setSystemCallbacks();
 80a2c84:	f7ff fd02 	bl	80a268c <_ZN5spark10LogManager18setSystemCallbacksEv>
    }
#endif
}

bool spark::LogManager::addHandler(LogHandler *handler) {
    LOG_WITH_LOCK(mutex_) {
 80a2c88:	a801      	add	r0, sp, #4
 80a2c8a:	f7ff fe1b 	bl	80a28c4 <_ZNSt10lock_guardI14RecursiveMutexED1Ev>
        if (activeHandlers_.size() == 1) {
            setSystemCallbacks();
        }
    }
    return true;
}
 80a2c8e:	4628      	mov	r0, r5
 80a2c90:	b003      	add	sp, #12
 80a2c92:	bd30      	pop	{r4, r5, pc}

080a2c94 <_ZN5spark6VectorI6StringNS_16DefaultAllocatorEE4moveIS1_Li0EEEvPS1_S5_S5_>:
        ::memmove(dest, p, (end - p) * sizeof(T));
    }

    template<PARTICLE_VECTOR_ENABLE_IF_NOT_TRIVIALLY_COPYABLE(T)>
    static void move(T* dest, T* p, T* end) {
        if (dest > p && dest < end) {
 80a2c94:	4288      	cmp	r0, r1
    static void move(T* dest, const T* p, const T* end) {
        ::memmove(dest, p, (end - p) * sizeof(T));
    }

    template<PARTICLE_VECTOR_ENABLE_IF_NOT_TRIVIALLY_COPYABLE(T)>
    static void move(T* dest, T* p, T* end) {
 80a2c96:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80a2c98:	4606      	mov	r6, r0
 80a2c9a:	460c      	mov	r4, r1
 80a2c9c:	4615      	mov	r5, r2
        if (dest > p && dest < end) {
 80a2c9e:	d914      	bls.n	80a2cca <_ZN5spark6VectorI6StringNS_16DefaultAllocatorEE4moveIS1_Li0EEEvPS1_S5_S5_+0x36>
 80a2ca0:	4290      	cmp	r0, r2
 80a2ca2:	d213      	bcs.n	80a2ccc <_ZN5spark6VectorI6StringNS_16DefaultAllocatorEE4moveIS1_Li0EEEvPS1_S5_S5_+0x38>
            // Move elements in reverse order
            --p;
            --end;
 80a2ca4:	f1a2 0510 	sub.w	r5, r2, #16
            dest += end - p - 1;
 80a2ca8:	1a6c      	subs	r4, r5, r1
 80a2caa:	f1a1 0710 	sub.w	r7, r1, #16
 80a2cae:	4404      	add	r4, r0
            for (; end != p; --end, --dest) {
 80a2cb0:	42af      	cmp	r7, r5
 80a2cb2:	d018      	beq.n	80a2ce6 <_ZN5spark6VectorI6StringNS_16DefaultAllocatorEE4moveIS1_Li0EEEvPS1_S5_S5_+0x52>
                new(dest) T(std::move(*end));
 80a2cb4:	b11c      	cbz	r4, 80a2cbe <_ZN5spark6VectorI6StringNS_16DefaultAllocatorEE4moveIS1_Li0EEEvPS1_S5_S5_+0x2a>
 80a2cb6:	4629      	mov	r1, r5
 80a2cb8:	4620      	mov	r0, r4
 80a2cba:	f000 fd55 	bl	80a3768 <_ZN6StringC1EOS_>
                end->~T();
 80a2cbe:	4628      	mov	r0, r5
 80a2cc0:	f000 fd62 	bl	80a3788 <_ZN6StringD1Ev>
        if (dest > p && dest < end) {
            // Move elements in reverse order
            --p;
            --end;
            dest += end - p - 1;
            for (; end != p; --end, --dest) {
 80a2cc4:	3d10      	subs	r5, #16
 80a2cc6:	3c10      	subs	r4, #16
 80a2cc8:	e7f2      	b.n	80a2cb0 <_ZN5spark6VectorI6StringNS_16DefaultAllocatorEE4moveIS1_Li0EEEvPS1_S5_S5_+0x1c>
                new(dest) T(std::move(*end));
                end->~T();
            }
        } else if (dest != p) {
 80a2cca:	d00c      	beq.n	80a2ce6 <_ZN5spark6VectorI6StringNS_16DefaultAllocatorEE4moveIS1_Li0EEEvPS1_S5_S5_+0x52>
            for (; p != end; ++p, ++dest) {
 80a2ccc:	42ac      	cmp	r4, r5
 80a2cce:	d00a      	beq.n	80a2ce6 <_ZN5spark6VectorI6StringNS_16DefaultAllocatorEE4moveIS1_Li0EEEvPS1_S5_S5_+0x52>
                new(dest) T(std::move(*p));
 80a2cd0:	b11e      	cbz	r6, 80a2cda <_ZN5spark6VectorI6StringNS_16DefaultAllocatorEE4moveIS1_Li0EEEvPS1_S5_S5_+0x46>
 80a2cd2:	4621      	mov	r1, r4
 80a2cd4:	4630      	mov	r0, r6
 80a2cd6:	f000 fd47 	bl	80a3768 <_ZN6StringC1EOS_>
                p->~T();
 80a2cda:	4620      	mov	r0, r4
 80a2cdc:	f000 fd54 	bl	80a3788 <_ZN6StringD1Ev>
            for (; end != p; --end, --dest) {
                new(dest) T(std::move(*end));
                end->~T();
            }
        } else if (dest != p) {
            for (; p != end; ++p, ++dest) {
 80a2ce0:	3410      	adds	r4, #16
 80a2ce2:	3610      	adds	r6, #16
 80a2ce4:	e7f2      	b.n	80a2ccc <_ZN5spark6VectorI6StringNS_16DefaultAllocatorEE4moveIS1_Li0EEEvPS1_S5_S5_+0x38>
 80a2ce6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

080a2ce8 <_ZN5spark6VectorI6StringNS_16DefaultAllocatorEE7reallocIS1_Li0EEEbi>:
        capacity_ = n;
        return true;
    }

    template<PARTICLE_VECTOR_ENABLE_IF_NOT_TRIVIALLY_COPYABLE(T)>
    bool realloc(int n) {
 80a2ce8:	b570      	push	{r4, r5, r6, lr}
        T* d = nullptr;
        if (n > 0) {
 80a2cea:	1e0e      	subs	r6, r1, #0
        capacity_ = n;
        return true;
    }

    template<PARTICLE_VECTOR_ENABLE_IF_NOT_TRIVIALLY_COPYABLE(T)>
    bool realloc(int n) {
 80a2cec:	4605      	mov	r5, r0
        T* d = nullptr;
        if (n > 0) {
 80a2cee:	dd0b      	ble.n	80a2d08 <_ZN5spark6VectorI6StringNS_16DefaultAllocatorEE7reallocIS1_Li0EEEbi+0x20>

} // particle

// spark::DefaultAllocator
inline void* spark::DefaultAllocator::malloc(size_t size) {
    return ::malloc(size);
 80a2cf0:	0130      	lsls	r0, r6, #4
 80a2cf2:	f7fe fe25 	bl	80a1940 <malloc>
    template<PARTICLE_VECTOR_ENABLE_IF_NOT_TRIVIALLY_COPYABLE(T)>
    bool realloc(int n) {
        T* d = nullptr;
        if (n > 0) {
            d = (T*)AllocatorT::malloc(n * sizeof(T));
            if (!d) {
 80a2cf6:	4604      	mov	r4, r0
 80a2cf8:	b170      	cbz	r0, 80a2d18 <_ZN5spark6VectorI6StringNS_16DefaultAllocatorEE7reallocIS1_Li0EEEbi+0x30>
                return false;
            }
            move(d, data_, data_ + size_);
 80a2cfa:	e895 0006 	ldmia.w	r5, {r1, r2}
 80a2cfe:	eb01 1202 	add.w	r2, r1, r2, lsl #4
 80a2d02:	f7ff ffc7 	bl	80a2c94 <_ZN5spark6VectorI6StringNS_16DefaultAllocatorEE4moveIS1_Li0EEEvPS1_S5_S5_>
 80a2d06:	e000      	b.n	80a2d0a <_ZN5spark6VectorI6StringNS_16DefaultAllocatorEE7reallocIS1_Li0EEEbi+0x22>
        return true;
    }

    template<PARTICLE_VECTOR_ENABLE_IF_NOT_TRIVIALLY_COPYABLE(T)>
    bool realloc(int n) {
        T* d = nullptr;
 80a2d08:	2400      	movs	r4, #0
inline void* spark::DefaultAllocator::realloc(void* ptr, size_t size) {
    return ::realloc(ptr, size);
}

inline void spark::DefaultAllocator::free(void* ptr) {
    ::free(ptr);
 80a2d0a:	6828      	ldr	r0, [r5, #0]
 80a2d0c:	f7fe fe20 	bl	80a1950 <free>
                return false;
            }
            move(d, data_, data_ + size_);
        }
        AllocatorT::free(data_);
        data_ = d;
 80a2d10:	602c      	str	r4, [r5, #0]
        capacity_ = n;
 80a2d12:	60ae      	str	r6, [r5, #8]
        return true;
 80a2d14:	2001      	movs	r0, #1
 80a2d16:	bd70      	pop	{r4, r5, r6, pc}
    }
 80a2d18:	bd70      	pop	{r4, r5, r6, pc}

080a2d1a <_ZN5spark6detail9LogFilterC1E8LogLevelNS_6VectorINS_17LogCategoryFilterENS_16DefaultAllocatorEEE>:

spark::detail::LogFilter::LogFilter(LogLevel level) :
        level_(level) {
}

spark::detail::LogFilter::LogFilter(LogLevel level, LogCategoryFilters filters) :
 80a2d1a:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80a2d1e:	4692      	mov	sl, r2
// spark::Vector
template<typename T, typename AllocatorT>
inline spark::Vector<T, AllocatorT>::Vector() :
        data_(nullptr),
        size_(0),
        capacity_(0) {
 80a2d20:	2300      	movs	r3, #0
        level_(LOG_LEVEL_NONE) { // Fallback level that will be used in case of construction errors
 80a2d22:	2246      	movs	r2, #70	; 0x46

spark::detail::LogFilter::LogFilter(LogLevel level) :
        level_(level) {
}

spark::detail::LogFilter::LogFilter(LogLevel level, LogCategoryFilters filters) :
 80a2d24:	b095      	sub	sp, #84	; 0x54
 80a2d26:	6003      	str	r3, [r0, #0]
 80a2d28:	6043      	str	r3, [r0, #4]
 80a2d2a:	6083      	str	r3, [r0, #8]
 80a2d2c:	60c3      	str	r3, [r0, #12]
 80a2d2e:	6103      	str	r3, [r0, #16]
 80a2d30:	6143      	str	r3, [r0, #20]
        level_(LOG_LEVEL_NONE) { // Fallback level that will be used in case of construction errors
 80a2d32:	7602      	strb	r2, [r0, #24]

spark::detail::LogFilter::LogFilter(LogLevel level) :
        level_(level) {
}

spark::detail::LogFilter::LogFilter(LogLevel level, LogCategoryFilters filters) :
 80a2d34:	9102      	str	r1, [sp, #8]
 80a2d36:	f8da 1004 	ldr.w	r1, [sl, #4]
 80a2d3a:	4605      	mov	r5, r0
    return size_ == 0;
}

template<typename T, typename AllocatorT>
inline bool spark::Vector<T, AllocatorT>::reserve(int n) {
    if (n > capacity_ && !realloc(n)) {
 80a2d3c:	4299      	cmp	r1, r3
// spark::Vector
template<typename T, typename AllocatorT>
inline spark::Vector<T, AllocatorT>::Vector() :
        data_(nullptr),
        size_(0),
        capacity_(0) {
 80a2d3e:	9308      	str	r3, [sp, #32]
 80a2d40:	9309      	str	r3, [sp, #36]	; 0x24
 80a2d42:	930a      	str	r3, [sp, #40]	; 0x28
    return size_ == 0;
}

template<typename T, typename AllocatorT>
inline bool spark::Vector<T, AllocatorT>::reserve(int n) {
    if (n > capacity_ && !realloc(n)) {
 80a2d44:	f340 809d 	ble.w	80a2e82 <_ZN5spark6detail9LogFilterC1E8LogLevelNS_6VectorINS_17LogCategoryFilterENS_16DefaultAllocatorEEE+0x168>
 80a2d48:	a808      	add	r0, sp, #32
 80a2d4a:	f7ff ffcd 	bl	80a2ce8 <_ZN5spark6VectorI6StringNS_16DefaultAllocatorEE7reallocIS1_Li0EEEbi>
 80a2d4e:	2800      	cmp	r0, #0
 80a2d50:	f040 8097 	bne.w	80a2e82 <_ZN5spark6detail9LogFilterC1E8LogLevelNS_6VectorINS_17LogCategoryFilterENS_16DefaultAllocatorEEE+0x168>
 80a2d54:	e08e      	b.n	80a2e74 <_ZN5spark6detail9LogFilterC1E8LogLevelNS_6VectorINS_17LogCategoryFilterENS_16DefaultAllocatorEEE+0x15a>
    Vector<String> cats;
    if (!cats.reserve(filters.size())) {
        return;
    }
    for (LogCategoryFilter &filter: filters) {
        cats.append(std::move(filter.cat_));
 80a2d56:	4621      	mov	r1, r4
 80a2d58:	a80b      	add	r0, sp, #44	; 0x2c
 80a2d5a:	f000 fd05 	bl	80a3768 <_ZN6StringC1EOS_>
    AllocatorT::free(data_);
}

template<typename T, typename AllocatorT>
inline bool spark::Vector<T, AllocatorT>::append(T value) {
    return insert(size_, std::move(value));
 80a2d5e:	a90b      	add	r1, sp, #44	; 0x2c
 80a2d60:	a80f      	add	r0, sp, #60	; 0x3c
 80a2d62:	9e09      	ldr	r6, [sp, #36]	; 0x24
 80a2d64:	f000 fd00 	bl	80a3768 <_ZN6StringC1EOS_>
    return insert(0, vector);
}

template<typename T, typename AllocatorT>
inline bool spark::Vector<T, AllocatorT>::insert(int i, T value) {
    if (size_ + 1 > capacity_ && !realloc(size_ + 1)) {
 80a2d68:	9909      	ldr	r1, [sp, #36]	; 0x24
 80a2d6a:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 80a2d6c:	4299      	cmp	r1, r3
 80a2d6e:	f2c0 80ce 	blt.w	80a2f0e <_ZN5spark6detail9LogFilterC1E8LogLevelNS_6VectorINS_17LogCategoryFilterENS_16DefaultAllocatorEEE+0x1f4>
 80a2d72:	3101      	adds	r1, #1
 80a2d74:	a808      	add	r0, sp, #32
 80a2d76:	f7ff ffb7 	bl	80a2ce8 <_ZN5spark6VectorI6StringNS_16DefaultAllocatorEE7reallocIS1_Li0EEEbi>
 80a2d7a:	2800      	cmp	r0, #0
 80a2d7c:	f040 80c7 	bne.w	80a2f0e <_ZN5spark6detail9LogFilterC1E8LogLevelNS_6VectorINS_17LogCategoryFilterENS_16DefaultAllocatorEEE+0x1f4>
    AllocatorT::free(data_);
}

template<typename T, typename AllocatorT>
inline bool spark::Vector<T, AllocatorT>::append(T value) {
    return insert(size_, std::move(value));
 80a2d80:	a80f      	add	r0, sp, #60	; 0x3c
 80a2d82:	f000 fd01 	bl	80a3788 <_ZN6StringD1Ev>
 80a2d86:	a80b      	add	r0, sp, #44	; 0x2c
 80a2d88:	f000 fcfe 	bl	80a3788 <_ZN6StringD1Ev>
 80a2d8c:	3414      	adds	r4, #20
    // Store category names
    Vector<String> cats;
    if (!cats.reserve(filters.size())) {
        return;
    }
    for (LogCategoryFilter &filter: filters) {
 80a2d8e:	42a7      	cmp	r7, r4
 80a2d90:	d1e1      	bne.n	80a2d56 <_ZN5spark6detail9LogFilterC1E8LogLevelNS_6VectorINS_17LogCategoryFilterENS_16DefaultAllocatorEEE+0x3c>
// spark::Vector
template<typename T, typename AllocatorT>
inline spark::Vector<T, AllocatorT>::Vector() :
        data_(nullptr),
        size_(0),
        capacity_(0) {
 80a2d92:	2600      	movs	r6, #0
        if (!category) {
            continue; // Invalid usage or string allocation error
        }
        Vector<Node> *pNodes = &nodes; // Root nodes
        const char *name = nullptr; // Subcategory name
        size_t size = 0; // Name length
 80a2d94:	46b1      	mov	r9, r6
 80a2d96:	960b      	str	r6, [sp, #44]	; 0x2c
 80a2d98:	960c      	str	r6, [sp, #48]	; 0x30
 80a2d9a:	960d      	str	r6, [sp, #52]	; 0x34
    for (LogCategoryFilter &filter: filters) {
        cats.append(std::move(filter.cat_));
    }
    // Process category filters
    Vector<Node> nodes;
    for (int i = 0; i < cats.size(); ++i) {
 80a2d9c:	9b09      	ldr	r3, [sp, #36]	; 0x24
 80a2d9e:	429e      	cmp	r6, r3
 80a2da0:	f280 80a8 	bge.w	80a2ef4 <_ZN5spark6detail9LogFilterC1E8LogLevelNS_6VectorINS_17LogCategoryFilterENS_16DefaultAllocatorEEE+0x1da>
 80a2da4:	9a08      	ldr	r2, [sp, #32]
 80a2da6:	0133      	lsls	r3, r6, #4
 80a2da8:	58d3      	ldr	r3, [r2, r3]
        const char *category = cats.at(i).c_str();
 80a2daa:	9306      	str	r3, [sp, #24]
        if (!category) {
 80a2dac:	2b00      	cmp	r3, #0
 80a2dae:	f000 809f 	beq.w	80a2ef0 <_ZN5spark6detail9LogFilterC1E8LogLevelNS_6VectorINS_17LogCategoryFilterENS_16DefaultAllocatorEEE+0x1d6>
 80a2db2:	2314      	movs	r3, #20
 80a2db4:	4373      	muls	r3, r6
            continue; // Invalid usage or string allocation error
        }
        Vector<Node> *pNodes = &nodes; // Root nodes
        const char *name = nullptr; // Subcategory name
        size_t size = 0; // Name length
 80a2db6:	f8cd 901c 	str.w	r9, [sp, #28]
 80a2dba:	9301      	str	r3, [sp, #4]
    for (int i = 0; i < cats.size(); ++i) {
        const char *category = cats.at(i).c_str();
        if (!category) {
            continue; // Invalid usage or string allocation error
        }
        Vector<Node> *pNodes = &nodes; // Root nodes
 80a2dbc:	ac0b      	add	r4, sp, #44	; 0x2c
        const char *name = nullptr; // Subcategory name
        size_t size = 0; // Name length
        while ((name = nextSubcategoryName(category, size))) {
 80a2dbe:	a907      	add	r1, sp, #28
 80a2dc0:	a806      	add	r0, sp, #24
 80a2dc2:	f7ff fb11 	bl	80a23e8 <_ZN12_GLOBAL__N_119nextSubcategoryNameERPKcRj>
 80a2dc6:	4607      	mov	r7, r0
 80a2dc8:	2800      	cmp	r0, #0
 80a2dca:	f000 8091 	beq.w	80a2ef0 <_ZN5spark6detail9LogFilterC1E8LogLevelNS_6VectorINS_17LogCategoryFilterENS_16DefaultAllocatorEEE+0x1d6>
            bool found = false;
 80a2dce:	ab14      	add	r3, sp, #80	; 0x50
            const int index = nodeIndex(*pNodes, name, size, found);
 80a2dd0:	4601      	mov	r1, r0
        }
        Vector<Node> *pNodes = &nodes; // Root nodes
        const char *name = nullptr; // Subcategory name
        size_t size = 0; // Name length
        while ((name = nextSubcategoryName(category, size))) {
            bool found = false;
 80a2dd2:	f803 9d39 	strb.w	r9, [r3, #-57]!
            const int index = nodeIndex(*pNodes, name, size, found);
 80a2dd6:	9a07      	ldr	r2, [sp, #28]
 80a2dd8:	4620      	mov	r0, r4
 80a2dda:	f7ff fb7f 	bl	80a24dc <_ZN5spark6detail9LogFilter9nodeIndexERKNS_6VectorINS1_4NodeENS_16DefaultAllocatorEEEPKcjRb>
            if (!found && !pNodes->insert(index, Node(name, size))) { // Add node
 80a2dde:	f89d 8017 	ldrb.w	r8, [sp, #23]
        Vector<Node> *pNodes = &nodes; // Root nodes
        const char *name = nullptr; // Subcategory name
        size_t size = 0; // Name length
        while ((name = nextSubcategoryName(category, size))) {
            bool found = false;
            const int index = nodeIndex(*pNodes, name, size, found);
 80a2de2:	9000      	str	r0, [sp, #0]
            if (!found && !pNodes->insert(index, Node(name, size))) { // Add node
 80a2de4:	f1b8 0f00 	cmp.w	r8, #0
 80a2de8:	d153      	bne.n	80a2e92 <_ZN5spark6detail9LogFilterC1E8LogLevelNS_6VectorINS_17LogCategoryFilterENS_16DefaultAllocatorEEE+0x178>
 80a2dea:	f8bd 301c 	ldrh.w	r3, [sp, #28]
    Vector<Node> nodes; // Children nodes

    Node(const char *name, uint16_t size) :
            name(name),
            size(size),
            level(-1) {
 80a2dee:	970f      	str	r7, [sp, #60]	; 0x3c
 80a2df0:	f8ad 3040 	strh.w	r3, [sp, #64]	; 0x40
 80a2df4:	f64f 73ff 	movw	r3, #65535	; 0xffff
 80a2df8:	f8cd 8044 	str.w	r8, [sp, #68]	; 0x44
 80a2dfc:	f8ad 3042 	strh.w	r3, [sp, #66]	; 0x42
 80a2e00:	f8cd 8048 	str.w	r8, [sp, #72]	; 0x48
 80a2e04:	f8cd 804c 	str.w	r8, [sp, #76]	; 0x4c
    return insert(0, vector);
}

template<typename T, typename AllocatorT>
inline bool spark::Vector<T, AllocatorT>::insert(int i, T value) {
    if (size_ + 1 > capacity_ && !realloc(size_ + 1)) {
 80a2e08:	6867      	ldr	r7, [r4, #4]
 80a2e0a:	68a3      	ldr	r3, [r4, #8]
 80a2e0c:	429f      	cmp	r7, r3
 80a2e0e:	da4f      	bge.n	80a2eb0 <_ZN5spark6detail9LogFilterC1E8LogLevelNS_6VectorINS_17LogCategoryFilterENS_16DefaultAllocatorEEE+0x196>
        return false;
    }
    T* const p = data_ + i;
 80a2e10:	9b00      	ldr	r3, [sp, #0]
 80a2e12:	2214      	movs	r2, #20
 80a2e14:	4353      	muls	r3, r2
 80a2e16:	f8d4 b000 	ldr.w	fp, [r4]
    move(p + 1, p, data_ + size_);
 80a2e1a:	6861      	ldr	r1, [r4, #4]
template<typename T, typename AllocatorT>
inline bool spark::Vector<T, AllocatorT>::insert(int i, T value) {
    if (size_ + 1 > capacity_ && !realloc(size_ + 1)) {
        return false;
    }
    T* const p = data_ + i;
 80a2e1c:	eb0b 0703 	add.w	r7, fp, r3
    move(p + 1, p, data_ + size_);
 80a2e20:	fb02 b201 	mla	r2, r2, r1, fp
 80a2e24:	f107 0014 	add.w	r0, r7, #20
 80a2e28:	4639      	mov	r1, r7
template<typename T, typename AllocatorT>
inline bool spark::Vector<T, AllocatorT>::insert(int i, T value) {
    if (size_ + 1 > capacity_ && !realloc(size_ + 1)) {
        return false;
    }
    T* const p = data_ + i;
 80a2e2a:	9303      	str	r3, [sp, #12]
    move(p + 1, p, data_ + size_);
 80a2e2c:	f7ff fe95 	bl	80a2b5a <_ZN5spark6VectorINS_6detail9LogFilter4NodeENS_16DefaultAllocatorEE4moveIS3_Li0EEEvPS3_S7_S7_>
    new(p) T(std::move(value));
 80a2e30:	b1a7      	cbz	r7, 80a2e5c <_ZN5spark6detail9LogFilterC1E8LogLevelNS_6VectorINS_17LogCategoryFilterENS_16DefaultAllocatorEEE+0x142>
    |
    `- aa (error) - b (warn)
*/

// spark::detail::LogFilter
struct spark::detail::LogFilter::Node {
 80a2e32:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
 80a2e34:	9b03      	ldr	r3, [sp, #12]
    }
}

template<typename T, typename AllocatorT>
inline spark::Vector<T, AllocatorT>::Vector(Vector<T, AllocatorT>&& vector) : Vector() {
    swap(*this, vector);
 80a2e36:	a911      	add	r1, sp, #68	; 0x44
 80a2e38:	f84b 2003 	str.w	r2, [fp, r3]
 80a2e3c:	f8bd 3040 	ldrh.w	r3, [sp, #64]	; 0x40
 80a2e40:	f107 0008 	add.w	r0, r7, #8
 80a2e44:	80bb      	strh	r3, [r7, #4]
 80a2e46:	f9bd 3042 	ldrsh.w	r3, [sp, #66]	; 0x42
// spark::Vector
template<typename T, typename AllocatorT>
inline spark::Vector<T, AllocatorT>::Vector() :
        data_(nullptr),
        size_(0),
        capacity_(0) {
 80a2e4a:	f8c7 9008 	str.w	r9, [r7, #8]
 80a2e4e:	80fb      	strh	r3, [r7, #6]
 80a2e50:	f8c7 900c 	str.w	r9, [r7, #12]
 80a2e54:	f8c7 9010 	str.w	r9, [r7, #16]
    }
}

template<typename T, typename AllocatorT>
inline spark::Vector<T, AllocatorT>::Vector(Vector<T, AllocatorT>&& vector) : Vector() {
    swap(*this, vector);
 80a2e58:	f7ff fe68 	bl	80a2b2c <_ZN5spark4swapINS_17LogCategoryFilterENS_16DefaultAllocatorEEEvRNS_6VectorIT_T0_EES7_>
        return false;
    }
    T* const p = data_ + i;
    move(p + 1, p, data_ + size_);
    new(p) T(std::move(value));
    ++size_;
 80a2e5c:	6863      	ldr	r3, [r4, #4]
 80a2e5e:	3301      	adds	r3, #1
 80a2e60:	6063      	str	r3, [r4, #4]
 80a2e62:	a811      	add	r0, sp, #68	; 0x44
 80a2e64:	f7ff fcd4 	bl	80a2810 <_ZN5spark6VectorINS_6detail9LogFilter4NodeENS_16DefaultAllocatorEED1Ev>
        const char *name = nullptr; // Subcategory name
        size_t size = 0; // Name length
        while ((name = nextSubcategoryName(category, size))) {
            bool found = false;
            const int index = nodeIndex(*pNodes, name, size, found);
            if (!found && !pNodes->insert(index, Node(name, size))) { // Add node
 80a2e68:	f1b8 0f00 	cmp.w	r8, #0
 80a2e6c:	d011      	beq.n	80a2e92 <_ZN5spark6detail9LogFilterC1E8LogLevelNS_6VectorINS_17LogCategoryFilterENS_16DefaultAllocatorEEE+0x178>
    }
    for (LogCategoryFilter &filter: filters) {
        cats.append(std::move(filter.cat_));
    }
    // Process category filters
    Vector<Node> nodes;
 80a2e6e:	a80b      	add	r0, sp, #44	; 0x2c
 80a2e70:	f7ff fcce 	bl	80a2810 <_ZN5spark6VectorINS_6detail9LogFilter4NodeENS_16DefaultAllocatorEED1Ev>
 80a2e74:	a808      	add	r0, sp, #32
 80a2e76:	f7ff fcdf 	bl	80a2838 <_ZN5spark6VectorI6StringNS_16DefaultAllocatorEED1Ev>
    }
    using std::swap;
    swap(cats_, cats);
    swap(nodes_, nodes);
    level_ = level;
}
 80a2e7a:	4628      	mov	r0, r5
 80a2e7c:	b015      	add	sp, #84	; 0x54
 80a2e7e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80a2e82:	f8da 4000 	ldr.w	r4, [sl]
    return data_;
}

template<typename T, typename AllocatorT>
T* spark::Vector<T, AllocatorT>::end() {
    return data_ + size_;
 80a2e86:	f8da 3004 	ldr.w	r3, [sl, #4]
 80a2e8a:	2714      	movs	r7, #20
 80a2e8c:	fb07 4703 	mla	r7, r7, r3, r4
 80a2e90:	e77d      	b.n	80a2d8e <_ZN5spark6detail9LogFilterC1E8LogLevelNS_6VectorINS_17LogCategoryFilterENS_16DefaultAllocatorEEE+0x74>
    return data_[size_ - 1];
}

template<typename T, typename AllocatorT>
inline T& spark::Vector<T, AllocatorT>::at(int i) {
    return data_[i];
 80a2e92:	6823      	ldr	r3, [r4, #0]
 80a2e94:	9a00      	ldr	r2, [sp, #0]
 80a2e96:	2414      	movs	r4, #20
 80a2e98:	fb04 3402 	mla	r4, r4, r2, r3
            const int index = nodeIndex(*pNodes, name, size, found);
            if (!found && !pNodes->insert(index, Node(name, size))) { // Add node
                return;
            }
            Node &node = pNodes->at(index);
            if (!*category) { // Check if it's last subcategory
 80a2e9c:	9b06      	ldr	r3, [sp, #24]
 80a2e9e:	781b      	ldrb	r3, [r3, #0]
 80a2ea0:	bb23      	cbnz	r3, 80a2eec <_ZN5spark6detail9LogFilterC1E8LogLevelNS_6VectorINS_17LogCategoryFilterENS_16DefaultAllocatorEEE+0x1d2>
                node.level = filters.at(i).level_;
 80a2ea2:	f8da 3000 	ldr.w	r3, [sl]
 80a2ea6:	9a01      	ldr	r2, [sp, #4]
 80a2ea8:	4413      	add	r3, r2
 80a2eaa:	7c1b      	ldrb	r3, [r3, #16]
 80a2eac:	80e3      	strh	r3, [r4, #6]
 80a2eae:	e01d      	b.n	80a2eec <_ZN5spark6detail9LogFilterC1E8LogLevelNS_6VectorINS_17LogCategoryFilterENS_16DefaultAllocatorEEE+0x1d2>
    return insert(0, vector);
}

template<typename T, typename AllocatorT>
inline bool spark::Vector<T, AllocatorT>::insert(int i, T value) {
    if (size_ + 1 > capacity_ && !realloc(size_ + 1)) {
 80a2eb0:	3701      	adds	r7, #1
    }

    template<PARTICLE_VECTOR_ENABLE_IF_NOT_TRIVIALLY_COPYABLE(T)>
    bool realloc(int n) {
        T* d = nullptr;
        if (n > 0) {
 80a2eb2:	2f00      	cmp	r7, #0
 80a2eb4:	dd0f      	ble.n	80a2ed6 <_ZN5spark6detail9LogFilterC1E8LogLevelNS_6VectorINS_17LogCategoryFilterENS_16DefaultAllocatorEEE+0x1bc>

} // particle

// spark::DefaultAllocator
inline void* spark::DefaultAllocator::malloc(size_t size) {
    return ::malloc(size);
 80a2eb6:	2314      	movs	r3, #20
 80a2eb8:	fb03 f007 	mul.w	r0, r3, r7
 80a2ebc:	9303      	str	r3, [sp, #12]
 80a2ebe:	f7fe fd3f 	bl	80a1940 <malloc>
    template<PARTICLE_VECTOR_ENABLE_IF_NOT_TRIVIALLY_COPYABLE(T)>
    bool realloc(int n) {
        T* d = nullptr;
        if (n > 0) {
            d = (T*)AllocatorT::malloc(n * sizeof(T));
            if (!d) {
 80a2ec2:	4683      	mov	fp, r0
 80a2ec4:	b178      	cbz	r0, 80a2ee6 <_ZN5spark6detail9LogFilterC1E8LogLevelNS_6VectorINS_17LogCategoryFilterENS_16DefaultAllocatorEEE+0x1cc>
                return false;
            }
            move(d, data_, data_ + size_);
 80a2ec6:	e894 0006 	ldmia.w	r4, {r1, r2}
 80a2eca:	9b03      	ldr	r3, [sp, #12]
 80a2ecc:	fb03 1202 	mla	r2, r3, r2, r1
 80a2ed0:	f7ff fe43 	bl	80a2b5a <_ZN5spark6VectorINS_6detail9LogFilter4NodeENS_16DefaultAllocatorEE4moveIS3_Li0EEEvPS3_S7_S7_>
 80a2ed4:	e000      	b.n	80a2ed8 <_ZN5spark6detail9LogFilterC1E8LogLevelNS_6VectorINS_17LogCategoryFilterENS_16DefaultAllocatorEEE+0x1be>
        return true;
    }

    template<PARTICLE_VECTOR_ENABLE_IF_NOT_TRIVIALLY_COPYABLE(T)>
    bool realloc(int n) {
        T* d = nullptr;
 80a2ed6:	46c3      	mov	fp, r8
inline void* spark::DefaultAllocator::realloc(void* ptr, size_t size) {
    return ::realloc(ptr, size);
}

inline void spark::DefaultAllocator::free(void* ptr) {
    ::free(ptr);
 80a2ed8:	6820      	ldr	r0, [r4, #0]
 80a2eda:	f7fe fd39 	bl	80a1950 <free>
                return false;
            }
            move(d, data_, data_ + size_);
        }
        AllocatorT::free(data_);
        data_ = d;
 80a2ede:	f8c4 b000 	str.w	fp, [r4]
        capacity_ = n;
 80a2ee2:	60a7      	str	r7, [r4, #8]
 80a2ee4:	e794      	b.n	80a2e10 <_ZN5spark6detail9LogFilterC1E8LogLevelNS_6VectorINS_17LogCategoryFilterENS_16DefaultAllocatorEEE+0xf6>
        const char *name = nullptr; // Subcategory name
        size_t size = 0; // Name length
        while ((name = nextSubcategoryName(category, size))) {
            bool found = false;
            const int index = nodeIndex(*pNodes, name, size, found);
            if (!found && !pNodes->insert(index, Node(name, size))) { // Add node
 80a2ee6:	f04f 0801 	mov.w	r8, #1
 80a2eea:	e7ba      	b.n	80a2e62 <_ZN5spark6detail9LogFilterC1E8LogLevelNS_6VectorINS_17LogCategoryFilterENS_16DefaultAllocatorEEE+0x148>
            }
            Node &node = pNodes->at(index);
            if (!*category) { // Check if it's last subcategory
                node.level = filters.at(i).level_;
            }
            pNodes = &node.nodes;
 80a2eec:	3408      	adds	r4, #8
            continue; // Invalid usage or string allocation error
        }
        Vector<Node> *pNodes = &nodes; // Root nodes
        const char *name = nullptr; // Subcategory name
        size_t size = 0; // Name length
        while ((name = nextSubcategoryName(category, size))) {
 80a2eee:	e766      	b.n	80a2dbe <_ZN5spark6detail9LogFilterC1E8LogLevelNS_6VectorINS_17LogCategoryFilterENS_16DefaultAllocatorEEE+0xa4>
    for (LogCategoryFilter &filter: filters) {
        cats.append(std::move(filter.cat_));
    }
    // Process category filters
    Vector<Node> nodes;
    for (int i = 0; i < cats.size(); ++i) {
 80a2ef0:	3601      	adds	r6, #1
 80a2ef2:	e753      	b.n	80a2d9c <_ZN5spark6detail9LogFilterC1E8LogLevelNS_6VectorINS_17LogCategoryFilterENS_16DefaultAllocatorEEE+0x82>
            }
            pNodes = &node.nodes;
        }
    }
    using std::swap;
    swap(cats_, cats);
 80a2ef4:	a908      	add	r1, sp, #32
 80a2ef6:	4628      	mov	r0, r5
 80a2ef8:	f7ff fe18 	bl	80a2b2c <_ZN5spark4swapINS_17LogCategoryFilterENS_16DefaultAllocatorEEEvRNS_6VectorIT_T0_EES7_>
    swap(nodes_, nodes);
 80a2efc:	a90b      	add	r1, sp, #44	; 0x2c
 80a2efe:	f105 000c 	add.w	r0, r5, #12
 80a2f02:	f7ff fe13 	bl	80a2b2c <_ZN5spark4swapINS_17LogCategoryFilterENS_16DefaultAllocatorEEEvRNS_6VectorIT_T0_EES7_>
    level_ = level;
 80a2f06:	f89d 3008 	ldrb.w	r3, [sp, #8]
 80a2f0a:	762b      	strb	r3, [r5, #24]
 80a2f0c:	e7af      	b.n	80a2e6e <_ZN5spark6detail9LogFilterC1E8LogLevelNS_6VectorINS_17LogCategoryFilterENS_16DefaultAllocatorEEE+0x154>
template<typename T, typename AllocatorT>
inline bool spark::Vector<T, AllocatorT>::insert(int i, T value) {
    if (size_ + 1 > capacity_ && !realloc(size_ + 1)) {
        return false;
    }
    T* const p = data_ + i;
 80a2f0e:	9b08      	ldr	r3, [sp, #32]
    move(p + 1, p, data_ + size_);
 80a2f10:	9a09      	ldr	r2, [sp, #36]	; 0x24
template<typename T, typename AllocatorT>
inline bool spark::Vector<T, AllocatorT>::insert(int i, T value) {
    if (size_ + 1 > capacity_ && !realloc(size_ + 1)) {
        return false;
    }
    T* const p = data_ + i;
 80a2f12:	eb03 1606 	add.w	r6, r3, r6, lsl #4
    move(p + 1, p, data_ + size_);
 80a2f16:	eb03 1202 	add.w	r2, r3, r2, lsl #4
 80a2f1a:	4631      	mov	r1, r6
 80a2f1c:	f106 0010 	add.w	r0, r6, #16
 80a2f20:	f7ff feb8 	bl	80a2c94 <_ZN5spark6VectorI6StringNS_16DefaultAllocatorEE4moveIS1_Li0EEEvPS1_S5_S5_>
    new(p) T(std::move(value));
 80a2f24:	b11e      	cbz	r6, 80a2f2e <_ZN5spark6detail9LogFilterC1E8LogLevelNS_6VectorINS_17LogCategoryFilterENS_16DefaultAllocatorEEE+0x214>
 80a2f26:	a90f      	add	r1, sp, #60	; 0x3c
 80a2f28:	4630      	mov	r0, r6
 80a2f2a:	f000 fc1d 	bl	80a3768 <_ZN6StringC1EOS_>
    ++size_;
 80a2f2e:	9b09      	ldr	r3, [sp, #36]	; 0x24
 80a2f30:	3301      	adds	r3, #1
 80a2f32:	9309      	str	r3, [sp, #36]	; 0x24
 80a2f34:	e724      	b.n	80a2d80 <_ZN5spark6detail9LogFilterC1E8LogLevelNS_6VectorINS_17LogCategoryFilterENS_16DefaultAllocatorEEE+0x66>
	...

080a2f38 <_ZN5spark10LogHandlerC1E8LogLevelNS_6VectorINS_17LogCategoryFilterENS_16DefaultAllocatorEEE>:
// spark::LogHandler
inline spark::LogHandler::LogHandler(LogLevel level) :
        filter_(level) {
}

inline spark::LogHandler::LogHandler(LogLevel level, LogCategoryFilters filters) :
 80a2f38:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
        filter_(level, filters) {
 80a2f3a:	4604      	mov	r4, r0
// spark::LogHandler
inline spark::LogHandler::LogHandler(LogLevel level) :
        filter_(level) {
}

inline spark::LogHandler::LogHandler(LogLevel level, LogCategoryFilters filters) :
 80a2f3c:	460e      	mov	r6, r1
 80a2f3e:	4605      	mov	r5, r0
        filter_(level, filters) {
 80a2f40:	4b08      	ldr	r3, [pc, #32]	; (80a2f64 <_ZN5spark10LogHandlerC1E8LogLevelNS_6VectorINS_17LogCategoryFilterENS_16DefaultAllocatorEEE+0x2c>)
 80a2f42:	4611      	mov	r1, r2
 80a2f44:	f844 3b04 	str.w	r3, [r4], #4
 80a2f48:	a801      	add	r0, sp, #4
 80a2f4a:	f7fd f963 	bl	80a0214 <_ZN5spark6VectorINS_17LogCategoryFilterENS_16DefaultAllocatorEEC1ERKS3_>
 80a2f4e:	aa01      	add	r2, sp, #4
 80a2f50:	4631      	mov	r1, r6
 80a2f52:	4620      	mov	r0, r4
 80a2f54:	f7ff fee1 	bl	80a2d1a <_ZN5spark6detail9LogFilterC1E8LogLevelNS_6VectorINS_17LogCategoryFilterENS_16DefaultAllocatorEEE>
 80a2f58:	a801      	add	r0, sp, #4
 80a2f5a:	f7fd f91a 	bl	80a0192 <_ZN5spark6VectorINS_17LogCategoryFilterENS_16DefaultAllocatorEED1Ev>
}
 80a2f5e:	4628      	mov	r0, r5
 80a2f60:	b004      	add	sp, #16
 80a2f62:	bd70      	pop	{r4, r5, r6, pc}
 80a2f64:	080a3f48 	.word	0x080a3f48

080a2f68 <_ZN5spark24DefaultLogHandlerFactory13createHandlerEPKc8LogLevelNS_6VectorINS_17LogCategoryFilterENS_16DefaultAllocatorEEEP5PrintRKNS_9JSONValueE>:

#if Wiring_LogConfig

// spark::DefaultLogHandlerFactory
LogHandler* spark::DefaultLogHandlerFactory::createHandler(const char *type, LogLevel level, LogCategoryFilters filters,
            Print *stream, const JSONValue &params) {
 80a2f68:	b5f0      	push	{r4, r5, r6, r7, lr}
 80a2f6a:	460f      	mov	r7, r1
 80a2f6c:	b08b      	sub	sp, #44	; 0x2c
    if (strcmp(type, "JSONStreamLogHandler") == 0) {
 80a2f6e:	492b      	ldr	r1, [pc, #172]	; (80a301c <_ZN5spark24DefaultLogHandlerFactory13createHandlerEPKc8LogLevelNS_6VectorINS_17LogCategoryFilterENS_16DefaultAllocatorEEEP5PrintRKNS_9JSONValueE+0xb4>)
 80a2f70:	4638      	mov	r0, r7

#if Wiring_LogConfig

// spark::DefaultLogHandlerFactory
LogHandler* spark::DefaultLogHandlerFactory::createHandler(const char *type, LogLevel level, LogCategoryFilters filters,
            Print *stream, const JSONValue &params) {
 80a2f72:	4616      	mov	r6, r2
 80a2f74:	461d      	mov	r5, r3
 80a2f76:	9c10      	ldr	r4, [sp, #64]	; 0x40
    if (strcmp(type, "JSONStreamLogHandler") == 0) {
 80a2f78:	f000 ff0e 	bl	80a3d98 <strcmp>
 80a2f7c:	bb28      	cbnz	r0, 80a2fca <_ZN5spark24DefaultLogHandlerFactory13createHandlerEPKc8LogLevelNS_6VectorINS_17LogCategoryFilterENS_16DefaultAllocatorEEEP5PrintRKNS_9JSONValueE+0x62>
        if (!stream) {
 80a2f7e:	2c00      	cmp	r4, #0
 80a2f80:	d049      	beq.n	80a3016 <_ZN5spark24DefaultLogHandlerFactory13createHandlerEPKc8LogLevelNS_6VectorINS_17LogCategoryFilterENS_16DefaultAllocatorEEEP5PrintRKNS_9JSONValueE+0xae>
            return nullptr; // Output stream is not specified
        }
        return new(std::nothrow) JSONStreamLogHandler(*stream, level, std::move(filters));
 80a2f82:	4629      	mov	r1, r5
 80a2f84:	a801      	add	r0, sp, #4
 80a2f86:	f7ff fdde 	bl	80a2b46 <_ZN5spark6VectorINS_17LogCategoryFilterENS_16DefaultAllocatorEEC1EOS3_>
 80a2f8a:	4925      	ldr	r1, [pc, #148]	; (80a3020 <_ZN5spark24DefaultLogHandlerFactory13createHandlerEPKc8LogLevelNS_6VectorINS_17LogCategoryFilterENS_16DefaultAllocatorEEEP5PrintRKNS_9JSONValueE+0xb8>)
 80a2f8c:	2024      	movs	r0, #36	; 0x24
 80a2f8e:	f000 fd2f 	bl	80a39f0 <_ZnwjRKSt9nothrow_t>
 80a2f92:	4605      	mov	r5, r0
 80a2f94:	b1b8      	cbz	r0, 80a2fc6 <_ZN5spark24DefaultLogHandlerFactory13createHandlerEPKc8LogLevelNS_6VectorINS_17LogCategoryFilterENS_16DefaultAllocatorEEEP5PrintRKNS_9JSONValueE+0x5e>
    Print *stream_;
};

class JSONStreamLogHandler: public StreamLogHandler {
public:
    using StreamLogHandler::StreamLogHandler;
 80a2f96:	a901      	add	r1, sp, #4
 80a2f98:	a804      	add	r0, sp, #16
 80a2f9a:	f7ff fdd4 	bl	80a2b46 <_ZN5spark6VectorINS_17LogCategoryFilterENS_16DefaultAllocatorEEC1EOS3_>
}

// spark::StreamLogHandler
inline spark::StreamLogHandler::StreamLogHandler(Print &stream, LogLevel level, LogCategoryFilters filters) :
        LogHandler(level, filters),
        stream_(&stream) {
 80a2f9e:	a904      	add	r1, sp, #16
 80a2fa0:	a807      	add	r0, sp, #28
 80a2fa2:	f7fd f937 	bl	80a0214 <_ZN5spark6VectorINS_17LogCategoryFilterENS_16DefaultAllocatorEEC1ERKS3_>
 80a2fa6:	aa07      	add	r2, sp, #28
 80a2fa8:	4631      	mov	r1, r6
 80a2faa:	4628      	mov	r0, r5
 80a2fac:	f7ff ffc4 	bl	80a2f38 <_ZN5spark10LogHandlerC1E8LogLevelNS_6VectorINS_17LogCategoryFilterENS_16DefaultAllocatorEEE>
 80a2fb0:	a807      	add	r0, sp, #28
 80a2fb2:	f7fd f8ee 	bl	80a0192 <_ZN5spark6VectorINS_17LogCategoryFilterENS_16DefaultAllocatorEED1Ev>
 80a2fb6:	4b1b      	ldr	r3, [pc, #108]	; (80a3024 <_ZN5spark24DefaultLogHandlerFactory13createHandlerEPKc8LogLevelNS_6VectorINS_17LogCategoryFilterENS_16DefaultAllocatorEEEP5PrintRKNS_9JSONValueE+0xbc>)
 80a2fb8:	622c      	str	r4, [r5, #32]
 80a2fba:	602b      	str	r3, [r5, #0]
    Print *stream_;
};

class JSONStreamLogHandler: public StreamLogHandler {
public:
    using StreamLogHandler::StreamLogHandler;
 80a2fbc:	a804      	add	r0, sp, #16
 80a2fbe:	f7fd f8e8 	bl	80a0192 <_ZN5spark6VectorINS_17LogCategoryFilterENS_16DefaultAllocatorEED1Ev>
 80a2fc2:	4b19      	ldr	r3, [pc, #100]	; (80a3028 <_ZN5spark24DefaultLogHandlerFactory13createHandlerEPKc8LogLevelNS_6VectorINS_17LogCategoryFilterENS_16DefaultAllocatorEEEP5PrintRKNS_9JSONValueE+0xc0>)
 80a2fc4:	602b      	str	r3, [r5, #0]
 80a2fc6:	a801      	add	r0, sp, #4
 80a2fc8:	e01f      	b.n	80a300a <_ZN5spark24DefaultLogHandlerFactory13createHandlerEPKc8LogLevelNS_6VectorINS_17LogCategoryFilterENS_16DefaultAllocatorEEEP5PrintRKNS_9JSONValueE+0xa2>
    } else if (strcmp(type, "StreamLogHandler") == 0) {
 80a2fca:	4918      	ldr	r1, [pc, #96]	; (80a302c <_ZN5spark24DefaultLogHandlerFactory13createHandlerEPKc8LogLevelNS_6VectorINS_17LogCategoryFilterENS_16DefaultAllocatorEEEP5PrintRKNS_9JSONValueE+0xc4>)
 80a2fcc:	4638      	mov	r0, r7
 80a2fce:	f000 fee3 	bl	80a3d98 <strcmp>
 80a2fd2:	b9f0      	cbnz	r0, 80a3012 <_ZN5spark24DefaultLogHandlerFactory13createHandlerEPKc8LogLevelNS_6VectorINS_17LogCategoryFilterENS_16DefaultAllocatorEEEP5PrintRKNS_9JSONValueE+0xaa>
        if (!stream) {
 80a2fd4:	b1fc      	cbz	r4, 80a3016 <_ZN5spark24DefaultLogHandlerFactory13createHandlerEPKc8LogLevelNS_6VectorINS_17LogCategoryFilterENS_16DefaultAllocatorEEEP5PrintRKNS_9JSONValueE+0xae>
            return nullptr;
        }
        return new(std::nothrow) StreamLogHandler(*stream, level, std::move(filters));
 80a2fd6:	4629      	mov	r1, r5
 80a2fd8:	a804      	add	r0, sp, #16
 80a2fda:	f7ff fdb4 	bl	80a2b46 <_ZN5spark6VectorINS_17LogCategoryFilterENS_16DefaultAllocatorEEC1EOS3_>
 80a2fde:	4910      	ldr	r1, [pc, #64]	; (80a3020 <_ZN5spark24DefaultLogHandlerFactory13createHandlerEPKc8LogLevelNS_6VectorINS_17LogCategoryFilterENS_16DefaultAllocatorEEEP5PrintRKNS_9JSONValueE+0xb8>)
 80a2fe0:	2024      	movs	r0, #36	; 0x24
 80a2fe2:	f000 fd05 	bl	80a39f0 <_ZnwjRKSt9nothrow_t>
 80a2fe6:	4605      	mov	r5, r0
 80a2fe8:	b170      	cbz	r0, 80a3008 <_ZN5spark24DefaultLogHandlerFactory13createHandlerEPKc8LogLevelNS_6VectorINS_17LogCategoryFilterENS_16DefaultAllocatorEEEP5PrintRKNS_9JSONValueE+0xa0>
}

// spark::StreamLogHandler
inline spark::StreamLogHandler::StreamLogHandler(Print &stream, LogLevel level, LogCategoryFilters filters) :
        LogHandler(level, filters),
        stream_(&stream) {
 80a2fea:	a904      	add	r1, sp, #16
 80a2fec:	a807      	add	r0, sp, #28
 80a2fee:	f7fd f911 	bl	80a0214 <_ZN5spark6VectorINS_17LogCategoryFilterENS_16DefaultAllocatorEEC1ERKS3_>
 80a2ff2:	aa07      	add	r2, sp, #28
 80a2ff4:	4631      	mov	r1, r6
 80a2ff6:	4628      	mov	r0, r5
 80a2ff8:	f7ff ff9e 	bl	80a2f38 <_ZN5spark10LogHandlerC1E8LogLevelNS_6VectorINS_17LogCategoryFilterENS_16DefaultAllocatorEEE>
 80a2ffc:	a807      	add	r0, sp, #28
 80a2ffe:	f7fd f8c8 	bl	80a0192 <_ZN5spark6VectorINS_17LogCategoryFilterENS_16DefaultAllocatorEED1Ev>
 80a3002:	4b08      	ldr	r3, [pc, #32]	; (80a3024 <_ZN5spark24DefaultLogHandlerFactory13createHandlerEPKc8LogLevelNS_6VectorINS_17LogCategoryFilterENS_16DefaultAllocatorEEEP5PrintRKNS_9JSONValueE+0xbc>)
 80a3004:	622c      	str	r4, [r5, #32]
 80a3006:	602b      	str	r3, [r5, #0]
 80a3008:	a804      	add	r0, sp, #16
 80a300a:	f7fd f8c2 	bl	80a0192 <_ZN5spark6VectorINS_17LogCategoryFilterENS_16DefaultAllocatorEED1Ev>
 80a300e:	4628      	mov	r0, r5
 80a3010:	e002      	b.n	80a3018 <_ZN5spark24DefaultLogHandlerFactory13createHandlerEPKc8LogLevelNS_6VectorINS_17LogCategoryFilterENS_16DefaultAllocatorEEEP5PrintRKNS_9JSONValueE+0xb0>
// spark::DefaultLogHandlerFactory
LogHandler* spark::DefaultLogHandlerFactory::createHandler(const char *type, LogLevel level, LogCategoryFilters filters,
            Print *stream, const JSONValue &params) {
    if (strcmp(type, "JSONStreamLogHandler") == 0) {
        if (!stream) {
            return nullptr; // Output stream is not specified
 80a3012:	2000      	movs	r0, #0
 80a3014:	e000      	b.n	80a3018 <_ZN5spark24DefaultLogHandlerFactory13createHandlerEPKc8LogLevelNS_6VectorINS_17LogCategoryFilterENS_16DefaultAllocatorEEEP5PrintRKNS_9JSONValueE+0xb0>
 80a3016:	4620      	mov	r0, r4
            return nullptr;
        }
        return new(std::nothrow) StreamLogHandler(*stream, level, std::move(filters));
    }
    return nullptr; // Unknown handler type
}
 80a3018:	b00b      	add	sp, #44	; 0x2c
 80a301a:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80a301c:	080a4c11 	.word	0x080a4c11
 80a3020:	080a4d10 	.word	0x080a4d10
 80a3024:	080a4c98 	.word	0x080a4c98
 80a3028:	080a4ba0 	.word	0x080a4ba0
 80a302c:	080a4c15 	.word	0x080a4c15

080a3030 <_GLOBAL__sub_I__ZN5spark3LogE>:
    // This handler doesn't support direct logging
}

// spark::Logger
inline spark::Logger::Logger(const char *name) :
        name_(name) {
 80a3030:	4a01      	ldr	r2, [pc, #4]	; (80a3038 <_GLOBAL__sub_I__ZN5spark3LogE+0x8>)
 80a3032:	4b02      	ldr	r3, [pc, #8]	; (80a303c <_GLOBAL__sub_I__ZN5spark3LogE+0xc>)
 80a3034:	601a      	str	r2, [r3, #0]
 80a3036:	4770      	bx	lr
 80a3038:	080a4c26 	.word	0x080a4c26
 80a303c:	200004bc 	.word	0x200004bc

080a3040 <_ZN5spark16StreamLogHandler10logMessageEPKc8LogLevelS2_RK13LogAttributes>:
                return cmp < 0;
            }));
}

// spark::StreamLogHandler
void spark::StreamLogHandler::logMessage(const char *msg, LogLevel level, const char *category, const LogAttributes &attr) {
 80a3040:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 80a3044:	9d08      	ldr	r5, [sp, #32]
    // TODO: Move this check to a base class (see also JSONStreamLogHandler::logMessage())
#if PLATFORM_ID != PLATFORM_GCC
    if (stream_ == &Serial && Network.listening()) {
 80a3046:	f8d0 9020 	ldr.w	r9, [r0, #32]
                return cmp < 0;
            }));
}

// spark::StreamLogHandler
void spark::StreamLogHandler::logMessage(const char *msg, LogLevel level, const char *category, const LogAttributes &attr) {
 80a304a:	4604      	mov	r4, r0
 80a304c:	460e      	mov	r6, r1
 80a304e:	4617      	mov	r7, r2
 80a3050:	4698      	mov	r8, r3
    // TODO: Move this check to a base class (see also JSONStreamLogHandler::logMessage())
#if PLATFORM_ID != PLATFORM_GCC
    if (stream_ == &Serial && Network.listening()) {
 80a3052:	f7ff f821 	bl	80a2098 <_Z16_fetch_usbserialv>
 80a3056:	4581      	cmp	r9, r0
 80a3058:	d105      	bne.n	80a3066 <_ZN5spark16StreamLogHandler10logMessageEPKc8LogLevelS2_RK13LogAttributes+0x26>
 80a305a:	485a      	ldr	r0, [pc, #360]	; (80a31c4 <_ZN5spark16StreamLogHandler10logMessageEPKc8LogLevelS2_RK13LogAttributes+0x184>)
 80a305c:	f7fe feb6 	bl	80a1dcc <_ZN5spark12NetworkClass9listeningEv>
 80a3060:	2800      	cmp	r0, #0
 80a3062:	f040 80ac 	bne.w	80a31be <_ZN5spark16StreamLogHandler10logMessageEPKc8LogLevelS2_RK13LogAttributes+0x17e>
        return; // Do not mix logging and serial console output
    }
#endif
    const char *s = nullptr;
    // Timestamp
    if (attr.has_time) {
 80a3066:	792b      	ldrb	r3, [r5, #4]
 80a3068:	071b      	lsls	r3, r3, #28
 80a306a:	d505      	bpl.n	80a3078 <_ZN5spark16StreamLogHandler10logMessageEPKc8LogLevelS2_RK13LogAttributes+0x38>
    size_t println(const __FlashStringHelper*);

    template <typename... Args>
    inline size_t printf(const char* format, Args... args)
    {
        return this->printf_impl(false, format, args...);
 80a306c:	696b      	ldr	r3, [r5, #20]
 80a306e:	4a56      	ldr	r2, [pc, #344]	; (80a31c8 <_ZN5spark16StreamLogHandler10logMessageEPKc8LogLevelS2_RK13LogAttributes+0x188>)
 80a3070:	2100      	movs	r1, #0
 80a3072:	6a20      	ldr	r0, [r4, #32]
 80a3074:	f000 f9d2 	bl	80a341c <_ZN5Print11printf_implEbPKcz>
        printf("%010u ", (unsigned)attr.time);
    }
    // Category
    if (category) {
 80a3078:	f1b8 0f00 	cmp.w	r8, #0
 80a307c:	d00d      	beq.n	80a309a <_ZN5spark16StreamLogHandler10logMessageEPKc8LogLevelS2_RK13LogAttributes+0x5a>
        write('[');
 80a307e:	215b      	movs	r1, #91	; 0x5b
 80a3080:	4620      	mov	r0, r4
 80a3082:	f7ff fa20 	bl	80a24c6 <_ZN5spark16StreamLogHandler5writeEc>
        write(category);
 80a3086:	4641      	mov	r1, r8
 80a3088:	4620      	mov	r0, r4
 80a308a:	f7ff fa0e 	bl	80a24aa <_ZN5spark16StreamLogHandler5writeEPKc>
        write("] ", 2);
 80a308e:	6823      	ldr	r3, [r4, #0]
 80a3090:	2202      	movs	r2, #2
 80a3092:	68db      	ldr	r3, [r3, #12]
 80a3094:	494d      	ldr	r1, [pc, #308]	; (80a31cc <_ZN5spark16StreamLogHandler10logMessageEPKc8LogLevelS2_RK13LogAttributes+0x18c>)
 80a3096:	4620      	mov	r0, r4
 80a3098:	4798      	blx	r3
    }
    // Source file
    if (attr.has_file) {
 80a309a:	792b      	ldrb	r3, [r5, #4]
 80a309c:	07d9      	lsls	r1, r3, #31
 80a309e:	d525      	bpl.n	80a30ec <_ZN5spark16StreamLogHandler10logMessageEPKc8LogLevelS2_RK13LogAttributes+0xac>
        s = extractFileName(attr.file); // Strip directory path
 80a30a0:	f8d5 8008 	ldr.w	r8, [r5, #8]
    }
    return nullptr;
}

const char* extractFileName(const char *s) {
    const char *s1 = strrchr(s, '/');
 80a30a4:	212f      	movs	r1, #47	; 0x2f
 80a30a6:	4640      	mov	r0, r8
 80a30a8:	f000 fe9d 	bl	80a3de6 <strrchr>
    if (s1) {
 80a30ac:	b108      	cbz	r0, 80a30b2 <_ZN5spark16StreamLogHandler10logMessageEPKc8LogLevelS2_RK13LogAttributes+0x72>
        return s1 + 1;
 80a30ae:	f100 0801 	add.w	r8, r0, #1
        write("] ", 2);
    }
    // Source file
    if (attr.has_file) {
        s = extractFileName(attr.file); // Strip directory path
        write(s); // File name
 80a30b2:	4641      	mov	r1, r8
 80a30b4:	4620      	mov	r0, r4
 80a30b6:	f7ff f9f8 	bl	80a24aa <_ZN5spark16StreamLogHandler5writeEPKc>
        if (attr.has_line) {
 80a30ba:	792b      	ldrb	r3, [r5, #4]
 80a30bc:	079a      	lsls	r2, r3, #30
 80a30be:	d509      	bpl.n	80a30d4 <_ZN5spark16StreamLogHandler10logMessageEPKc8LogLevelS2_RK13LogAttributes+0x94>
            write(':');
 80a30c0:	213a      	movs	r1, #58	; 0x3a
 80a30c2:	4620      	mov	r0, r4
 80a30c4:	f7ff f9ff 	bl	80a24c6 <_ZN5spark16StreamLogHandler5writeEc>
 80a30c8:	68eb      	ldr	r3, [r5, #12]
 80a30ca:	4a41      	ldr	r2, [pc, #260]	; (80a31d0 <_ZN5spark16StreamLogHandler10logMessageEPKc8LogLevelS2_RK13LogAttributes+0x190>)
 80a30cc:	2100      	movs	r1, #0
 80a30ce:	6a20      	ldr	r0, [r4, #32]
 80a30d0:	f000 f9a4 	bl	80a341c <_ZN5Print11printf_implEbPKcz>
            printf("%d", (int)attr.line); // Line number
        }
        if (attr.has_function) {
 80a30d4:	792b      	ldrb	r3, [r5, #4]
            write(", ", 2);
 80a30d6:	2202      	movs	r2, #2
        write(s); // File name
        if (attr.has_line) {
            write(':');
            printf("%d", (int)attr.line); // Line number
        }
        if (attr.has_function) {
 80a30d8:	f013 0f04 	tst.w	r3, #4
 80a30dc:	6823      	ldr	r3, [r4, #0]
            write(", ", 2);
 80a30de:	bf18      	it	ne
 80a30e0:	493c      	ldrne	r1, [pc, #240]	; (80a31d4 <_ZN5spark16StreamLogHandler10logMessageEPKc8LogLevelS2_RK13LogAttributes+0x194>)
 80a30e2:	68db      	ldr	r3, [r3, #12]
        } else {
            write(": ", 2);
 80a30e4:	bf08      	it	eq
 80a30e6:	493c      	ldreq	r1, [pc, #240]	; (80a31d8 <_ZN5spark16StreamLogHandler10logMessageEPKc8LogLevelS2_RK13LogAttributes+0x198>)
 80a30e8:	4620      	mov	r0, r4
 80a30ea:	4798      	blx	r3
        }
    }
    // Function name
    if (attr.has_function) {
 80a30ec:	792b      	ldrb	r3, [r5, #4]
 80a30ee:	075b      	lsls	r3, r3, #29
 80a30f0:	d518      	bpl.n	80a3124 <_ZN5spark16StreamLogHandler10logMessageEPKc8LogLevelS2_RK13LogAttributes+0xe4>
        size_t n = 0;
        s = extractFuncName(attr.function, &n); // Strip argument and return types
 80a30f2:	6929      	ldr	r1, [r5, #16]
 80a30f4:	460a      	mov	r2, r1
    return s;
}

const char* extractFuncName(const char *s, size_t *size) {
    const char *s1 = s;
    for (; *s; ++s) {
 80a30f6:	4613      	mov	r3, r2
 80a30f8:	f813 0b01 	ldrb.w	r0, [r3], #1
 80a30fc:	b138      	cbz	r0, 80a310e <_ZN5spark16StreamLogHandler10logMessageEPKc8LogLevelS2_RK13LogAttributes+0xce>
        if (*s == ' ') {
 80a30fe:	2820      	cmp	r0, #32
 80a3100:	d101      	bne.n	80a3106 <_ZN5spark16StreamLogHandler10logMessageEPKc8LogLevelS2_RK13LogAttributes+0xc6>
            s1 = s + 1; // Skip return type
 80a3102:	4619      	mov	r1, r3
 80a3104:	e001      	b.n	80a310a <_ZN5spark16StreamLogHandler10logMessageEPKc8LogLevelS2_RK13LogAttributes+0xca>
        } else if (*s == '(') {
 80a3106:	2828      	cmp	r0, #40	; 0x28
 80a3108:	d001      	beq.n	80a310e <_ZN5spark16StreamLogHandler10logMessageEPKc8LogLevelS2_RK13LogAttributes+0xce>
                return cmp < 0;
            }));
}

// spark::StreamLogHandler
void spark::StreamLogHandler::logMessage(const char *msg, LogLevel level, const char *category, const LogAttributes &attr) {
 80a310a:	461a      	mov	r2, r3
 80a310c:	e7f3      	b.n	80a30f6 <_ZN5spark16StreamLogHandler10logMessageEPKc8LogLevelS2_RK13LogAttributes+0xb6>
    }
    // Function name
    if (attr.has_function) {
        size_t n = 0;
        s = extractFuncName(attr.function, &n); // Strip argument and return types
        write(s, n);
 80a310e:	6823      	ldr	r3, [r4, #0]
 80a3110:	1a52      	subs	r2, r2, r1
 80a3112:	68db      	ldr	r3, [r3, #12]
 80a3114:	4620      	mov	r0, r4
 80a3116:	4798      	blx	r3
        write("(): ", 4);
 80a3118:	6823      	ldr	r3, [r4, #0]
 80a311a:	2204      	movs	r2, #4
 80a311c:	68db      	ldr	r3, [r3, #12]
 80a311e:	492f      	ldr	r1, [pc, #188]	; (80a31dc <_ZN5spark16StreamLogHandler10logMessageEPKc8LogLevelS2_RK13LogAttributes+0x19c>)
 80a3120:	4620      	mov	r0, r4
 80a3122:	4798      	blx	r3
inline LogLevel spark::LogHandler::level(const char *category) const {
    return filter_.level(category);
}

inline const char* spark::LogHandler::levelName(LogLevel level) {
    return log_level_name(level, nullptr);
 80a3124:	2100      	movs	r1, #0
 80a3126:	4638      	mov	r0, r7
 80a3128:	f7fe fb7e 	bl	80a1828 <log_level_name>
    }
    // Level
    s = levelName(level);
    write(s);
 80a312c:	4601      	mov	r1, r0
 80a312e:	4620      	mov	r0, r4
 80a3130:	f7ff f9bb 	bl	80a24aa <_ZN5spark16StreamLogHandler5writeEPKc>
    write(": ", 2);
 80a3134:	6823      	ldr	r3, [r4, #0]
 80a3136:	2202      	movs	r2, #2
 80a3138:	68db      	ldr	r3, [r3, #12]
 80a313a:	4927      	ldr	r1, [pc, #156]	; (80a31d8 <_ZN5spark16StreamLogHandler10logMessageEPKc8LogLevelS2_RK13LogAttributes+0x198>)
 80a313c:	4620      	mov	r0, r4
 80a313e:	4798      	blx	r3
    // Message
    if (msg) {
 80a3140:	b11e      	cbz	r6, 80a314a <_ZN5spark16StreamLogHandler10logMessageEPKc8LogLevelS2_RK13LogAttributes+0x10a>
        write(msg);
 80a3142:	4631      	mov	r1, r6
 80a3144:	4620      	mov	r0, r4
 80a3146:	f7ff f9b0 	bl	80a24aa <_ZN5spark16StreamLogHandler5writeEPKc>
    }
    // Additional attributes
    if (attr.has_code || attr.has_details) {
 80a314a:	792b      	ldrb	r3, [r5, #4]
 80a314c:	f013 0f30 	tst.w	r3, #48	; 0x30
 80a3150:	d02d      	beq.n	80a31ae <_ZN5spark16StreamLogHandler10logMessageEPKc8LogLevelS2_RK13LogAttributes+0x16e>
        write(" [", 2);
 80a3152:	6823      	ldr	r3, [r4, #0]
 80a3154:	4620      	mov	r0, r4
 80a3156:	68db      	ldr	r3, [r3, #12]
 80a3158:	2202      	movs	r2, #2
 80a315a:	4921      	ldr	r1, [pc, #132]	; (80a31e0 <_ZN5spark16StreamLogHandler10logMessageEPKc8LogLevelS2_RK13LogAttributes+0x1a0>)
 80a315c:	4798      	blx	r3
        // Code
        if (attr.has_code) {
 80a315e:	792b      	ldrb	r3, [r5, #4]
 80a3160:	06d8      	lsls	r0, r3, #27
 80a3162:	d50b      	bpl.n	80a317c <_ZN5spark16StreamLogHandler10logMessageEPKc8LogLevelS2_RK13LogAttributes+0x13c>
            write("code = ", 7);
 80a3164:	6823      	ldr	r3, [r4, #0]
 80a3166:	2207      	movs	r2, #7
 80a3168:	68db      	ldr	r3, [r3, #12]
 80a316a:	491e      	ldr	r1, [pc, #120]	; (80a31e4 <_ZN5spark16StreamLogHandler10logMessageEPKc8LogLevelS2_RK13LogAttributes+0x1a4>)
 80a316c:	4620      	mov	r0, r4
 80a316e:	4798      	blx	r3
 80a3170:	69ab      	ldr	r3, [r5, #24]
 80a3172:	4a1d      	ldr	r2, [pc, #116]	; (80a31e8 <_ZN5spark16StreamLogHandler10logMessageEPKc8LogLevelS2_RK13LogAttributes+0x1a8>)
 80a3174:	2100      	movs	r1, #0
 80a3176:	6a20      	ldr	r0, [r4, #32]
 80a3178:	f000 f950 	bl	80a341c <_ZN5Print11printf_implEbPKcz>
            printf("%" PRIiPTR, (intptr_t)attr.code);
        }
        // Details
        if (attr.has_details) {
 80a317c:	792b      	ldrb	r3, [r5, #4]
 80a317e:	0699      	lsls	r1, r3, #26
 80a3180:	d511      	bpl.n	80a31a6 <_ZN5spark16StreamLogHandler10logMessageEPKc8LogLevelS2_RK13LogAttributes+0x166>
            if (attr.has_code) {
 80a3182:	06da      	lsls	r2, r3, #27
 80a3184:	d505      	bpl.n	80a3192 <_ZN5spark16StreamLogHandler10logMessageEPKc8LogLevelS2_RK13LogAttributes+0x152>
                write(", ", 2);
 80a3186:	6823      	ldr	r3, [r4, #0]
 80a3188:	2202      	movs	r2, #2
 80a318a:	68db      	ldr	r3, [r3, #12]
 80a318c:	4911      	ldr	r1, [pc, #68]	; (80a31d4 <_ZN5spark16StreamLogHandler10logMessageEPKc8LogLevelS2_RK13LogAttributes+0x194>)
 80a318e:	4620      	mov	r0, r4
 80a3190:	4798      	blx	r3
            }
            write("details = ", 10);
 80a3192:	6823      	ldr	r3, [r4, #0]
 80a3194:	4915      	ldr	r1, [pc, #84]	; (80a31ec <_ZN5spark16StreamLogHandler10logMessageEPKc8LogLevelS2_RK13LogAttributes+0x1ac>)
 80a3196:	4620      	mov	r0, r4
 80a3198:	68db      	ldr	r3, [r3, #12]
 80a319a:	220a      	movs	r2, #10
 80a319c:	4798      	blx	r3
            write(attr.details);
 80a319e:	69e9      	ldr	r1, [r5, #28]
 80a31a0:	4620      	mov	r0, r4
 80a31a2:	f7ff f982 	bl	80a24aa <_ZN5spark16StreamLogHandler5writeEPKc>
        }
        write(']');
 80a31a6:	215d      	movs	r1, #93	; 0x5d
 80a31a8:	4620      	mov	r0, r4
 80a31aa:	f7ff f98c 	bl	80a24c6 <_ZN5spark16StreamLogHandler5writeEc>
    }
    write("\r\n", 2);
 80a31ae:	6823      	ldr	r3, [r4, #0]
 80a31b0:	4620      	mov	r0, r4
}
 80a31b2:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
            write("details = ", 10);
            write(attr.details);
        }
        write(']');
    }
    write("\r\n", 2);
 80a31b6:	68db      	ldr	r3, [r3, #12]
 80a31b8:	2202      	movs	r2, #2
 80a31ba:	490d      	ldr	r1, [pc, #52]	; (80a31f0 <_ZN5spark16StreamLogHandler10logMessageEPKc8LogLevelS2_RK13LogAttributes+0x1b0>)
 80a31bc:	4718      	bx	r3
 80a31be:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 80a31c2:	bf00      	nop
 80a31c4:	20000120 	.word	0x20000120
 80a31c8:	080a4c2a 	.word	0x080a4c2a
 80a31cc:	080a4c31 	.word	0x080a4c31
 80a31d0:	080a4a63 	.word	0x080a4a63
 80a31d4:	080a4c34 	.word	0x080a4c34
 80a31d8:	080a4c39 	.word	0x080a4c39
 80a31dc:	080a4c37 	.word	0x080a4c37
 80a31e0:	080a4c3c 	.word	0x080a4c3c
 80a31e4:	080a4c3f 	.word	0x080a4c3f
 80a31e8:	080a4c47 	.word	0x080a4c47
 80a31ec:	080a4c4a 	.word	0x080a4c4a
 80a31f0:	080a4c55 	.word	0x080a4c55

080a31f4 <_ZN5spark20JSONStreamLogHandler10logMessageEPKc8LogLevelS2_RK13LogAttributes>:
}

// spark::JSONStreamLogHandler
void spark::JSONStreamLogHandler::logMessage(const char *msg, LogLevel level, const char *category, const LogAttributes &attr) {
 80a31f4:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 80a31f8:	b085      	sub	sp, #20
 80a31fa:	f8d0 8020 	ldr.w	r8, [r0, #32]
 80a31fe:	4606      	mov	r6, r0
 80a3200:	460f      	mov	r7, r1
 80a3202:	4691      	mov	r9, r2
 80a3204:	461d      	mov	r5, r3
 80a3206:	9c0c      	ldr	r4, [sp, #48]	; 0x30
    // TODO: Move this check to a base class (see also StreamLogHandler::logMessage())
#if PLATFORM_ID != PLATFORM_GCC
    if (this->stream() == &Serial && Network.listening()) {
 80a3208:	f7fe ff46 	bl	80a2098 <_Z16_fetch_usbserialv>
 80a320c:	4580      	cmp	r8, r0
 80a320e:	d105      	bne.n	80a321c <_ZN5spark20JSONStreamLogHandler10logMessageEPKc8LogLevelS2_RK13LogAttributes+0x28>
 80a3210:	484a      	ldr	r0, [pc, #296]	; (80a333c <_ZN5spark20JSONStreamLogHandler10logMessageEPKc8LogLevelS2_RK13LogAttributes+0x148>)
 80a3212:	f7fe fddb 	bl	80a1dcc <_ZN5spark12NetworkClass9listeningEv>
 80a3216:	2800      	cmp	r0, #0
 80a3218:	f040 808c 	bne.w	80a3334 <_ZN5spark20JSONStreamLogHandler10logMessageEPKc8LogLevelS2_RK13LogAttributes+0x140>
 80a321c:	6a33      	ldr	r3, [r6, #32]
    write(&c, 1);
}

// spark::JSONStreamWriter
inline spark::JSONStreamWriter::JSONStreamWriter(Print &stream) :
        strm_(stream) {
 80a321e:	4a48      	ldr	r2, [pc, #288]	; (80a3340 <_ZN5spark20JSONStreamLogHandler10logMessageEPKc8LogLevelS2_RK13LogAttributes+0x14c>)
    return n_;
}

// spark::JSONWriter
inline spark::JSONWriter::JSONWriter() :
        state_(BEGIN) {
 80a3220:	f04f 0800 	mov.w	r8, #0
        return; // Do not mix logging and serial console output
    }
#endif
    JSONStreamWriter json(*this->stream());
    json.beginObject();
 80a3224:	a801      	add	r0, sp, #4
    write(&c, 1);
}

// spark::JSONStreamWriter
inline spark::JSONStreamWriter::JSONStreamWriter(Print &stream) :
        strm_(stream) {
 80a3226:	9201      	str	r2, [sp, #4]
 80a3228:	9303      	str	r3, [sp, #12]
    return n_;
}

// spark::JSONWriter
inline spark::JSONWriter::JSONWriter() :
        state_(BEGIN) {
 80a322a:	f88d 8008 	strb.w	r8, [sp, #8]
 80a322e:	f7fe fc86 	bl	80a1b3e <_ZN5spark10JSONWriter11beginObjectEv>
 80a3232:	4641      	mov	r1, r8
 80a3234:	4648      	mov	r0, r9
 80a3236:	f7fe faf7 	bl	80a1828 <log_level_name>
 80a323a:	4680      	mov	r8, r0
    // Level
    const char *s = levelName(level);
    json.name("l", 1).value(s);
 80a323c:	4941      	ldr	r1, [pc, #260]	; (80a3344 <_ZN5spark20JSONStreamLogHandler10logMessageEPKc8LogLevelS2_RK13LogAttributes+0x150>)
 80a323e:	2201      	movs	r2, #1
 80a3240:	a801      	add	r0, sp, #4
 80a3242:	f7fe fd01 	bl	80a1c48 <_ZN5spark10JSONWriter4nameEPKcj>
 80a3246:	4641      	mov	r1, r8
 80a3248:	f7ff f91f 	bl	80a248a <_ZN5spark10JSONWriter5valueEPKc>
    // Message
    if (msg) {
 80a324c:	b13f      	cbz	r7, 80a325e <_ZN5spark20JSONStreamLogHandler10logMessageEPKc8LogLevelS2_RK13LogAttributes+0x6a>
        json.name("m", 1).value(msg);
 80a324e:	493e      	ldr	r1, [pc, #248]	; (80a3348 <_ZN5spark20JSONStreamLogHandler10logMessageEPKc8LogLevelS2_RK13LogAttributes+0x154>)
 80a3250:	2201      	movs	r2, #1
 80a3252:	a801      	add	r0, sp, #4
 80a3254:	f7fe fcf8 	bl	80a1c48 <_ZN5spark10JSONWriter4nameEPKcj>
 80a3258:	4639      	mov	r1, r7
 80a325a:	f7ff f916 	bl	80a248a <_ZN5spark10JSONWriter5valueEPKc>
    }
    // Category
    if (category) {
 80a325e:	b13d      	cbz	r5, 80a3270 <_ZN5spark20JSONStreamLogHandler10logMessageEPKc8LogLevelS2_RK13LogAttributes+0x7c>
        json.name("c", 1).value(category);
 80a3260:	493a      	ldr	r1, [pc, #232]	; (80a334c <_ZN5spark20JSONStreamLogHandler10logMessageEPKc8LogLevelS2_RK13LogAttributes+0x158>)
 80a3262:	2201      	movs	r2, #1
 80a3264:	a801      	add	r0, sp, #4
 80a3266:	f7fe fcef 	bl	80a1c48 <_ZN5spark10JSONWriter4nameEPKcj>
 80a326a:	4629      	mov	r1, r5
 80a326c:	f7ff f90d 	bl	80a248a <_ZN5spark10JSONWriter5valueEPKc>
    }
    // File name
    if (attr.has_file) {
 80a3270:	7923      	ldrb	r3, [r4, #4]
 80a3272:	07df      	lsls	r7, r3, #31
 80a3274:	d50e      	bpl.n	80a3294 <_ZN5spark20JSONStreamLogHandler10logMessageEPKc8LogLevelS2_RK13LogAttributes+0xa0>
        s = extractFileName(attr.file); // Strip directory path
 80a3276:	68a5      	ldr	r5, [r4, #8]
    }
    return nullptr;
}

const char* extractFileName(const char *s) {
    const char *s1 = strrchr(s, '/');
 80a3278:	212f      	movs	r1, #47	; 0x2f
 80a327a:	4628      	mov	r0, r5
 80a327c:	f000 fdb3 	bl	80a3de6 <strrchr>
    if (s1) {
 80a3280:	b100      	cbz	r0, 80a3284 <_ZN5spark20JSONStreamLogHandler10logMessageEPKc8LogLevelS2_RK13LogAttributes+0x90>
        return s1 + 1;
 80a3282:	1c45      	adds	r5, r0, #1
        json.name("c", 1).value(category);
    }
    // File name
    if (attr.has_file) {
        s = extractFileName(attr.file); // Strip directory path
        json.name("f", 1).value(s);
 80a3284:	4932      	ldr	r1, [pc, #200]	; (80a3350 <_ZN5spark20JSONStreamLogHandler10logMessageEPKc8LogLevelS2_RK13LogAttributes+0x15c>)
 80a3286:	2201      	movs	r2, #1
 80a3288:	a801      	add	r0, sp, #4
 80a328a:	f7fe fcdd 	bl	80a1c48 <_ZN5spark10JSONWriter4nameEPKcj>
 80a328e:	4629      	mov	r1, r5
 80a3290:	f7ff f8fb 	bl	80a248a <_ZN5spark10JSONWriter5valueEPKc>
    }
    // Line number
    if (attr.has_line) {
 80a3294:	7923      	ldrb	r3, [r4, #4]
 80a3296:	079d      	lsls	r5, r3, #30
 80a3298:	d507      	bpl.n	80a32aa <_ZN5spark20JSONStreamLogHandler10logMessageEPKc8LogLevelS2_RK13LogAttributes+0xb6>
        json.name("ln", 2).value(attr.line);
 80a329a:	492e      	ldr	r1, [pc, #184]	; (80a3354 <_ZN5spark20JSONStreamLogHandler10logMessageEPKc8LogLevelS2_RK13LogAttributes+0x160>)
 80a329c:	2202      	movs	r2, #2
 80a329e:	a801      	add	r0, sp, #4
 80a32a0:	f7fe fcd2 	bl	80a1c48 <_ZN5spark10JSONWriter4nameEPKcj>
 80a32a4:	68e1      	ldr	r1, [r4, #12]
 80a32a6:	f7fe fc57 	bl	80a1b58 <_ZN5spark10JSONWriter5valueEi>
    }
    // Function name
    if (attr.has_function) {
 80a32aa:	7923      	ldrb	r3, [r4, #4]
 80a32ac:	0758      	lsls	r0, r3, #29
 80a32ae:	d516      	bpl.n	80a32de <_ZN5spark20JSONStreamLogHandler10logMessageEPKc8LogLevelS2_RK13LogAttributes+0xea>
        size_t n = 0;
        s = extractFuncName(attr.function, &n); // Strip argument and return types
 80a32b0:	6925      	ldr	r5, [r4, #16]
 80a32b2:	462f      	mov	r7, r5
    return s;
}

const char* extractFuncName(const char *s, size_t *size) {
    const char *s1 = s;
    for (; *s; ++s) {
 80a32b4:	463b      	mov	r3, r7
 80a32b6:	f813 2b01 	ldrb.w	r2, [r3], #1
 80a32ba:	b13a      	cbz	r2, 80a32cc <_ZN5spark20JSONStreamLogHandler10logMessageEPKc8LogLevelS2_RK13LogAttributes+0xd8>
        if (*s == ' ') {
 80a32bc:	2a20      	cmp	r2, #32
 80a32be:	d101      	bne.n	80a32c4 <_ZN5spark20JSONStreamLogHandler10logMessageEPKc8LogLevelS2_RK13LogAttributes+0xd0>
            s1 = s + 1; // Skip return type
 80a32c0:	461d      	mov	r5, r3
 80a32c2:	e001      	b.n	80a32c8 <_ZN5spark20JSONStreamLogHandler10logMessageEPKc8LogLevelS2_RK13LogAttributes+0xd4>
        } else if (*s == '(') {
 80a32c4:	2a28      	cmp	r2, #40	; 0x28
 80a32c6:	d001      	beq.n	80a32cc <_ZN5spark20JSONStreamLogHandler10logMessageEPKc8LogLevelS2_RK13LogAttributes+0xd8>
    }
    write("\r\n", 2);
}

// spark::JSONStreamLogHandler
void spark::JSONStreamLogHandler::logMessage(const char *msg, LogLevel level, const char *category, const LogAttributes &attr) {
 80a32c8:	461f      	mov	r7, r3
 80a32ca:	e7f3      	b.n	80a32b4 <_ZN5spark20JSONStreamLogHandler10logMessageEPKc8LogLevelS2_RK13LogAttributes+0xc0>
    }
    // Function name
    if (attr.has_function) {
        size_t n = 0;
        s = extractFuncName(attr.function, &n); // Strip argument and return types
        json.name("fn", 2).value(s, n);
 80a32cc:	2202      	movs	r2, #2
 80a32ce:	4922      	ldr	r1, [pc, #136]	; (80a3358 <_ZN5spark20JSONStreamLogHandler10logMessageEPKc8LogLevelS2_RK13LogAttributes+0x164>)
 80a32d0:	a801      	add	r0, sp, #4
 80a32d2:	f7fe fcb9 	bl	80a1c48 <_ZN5spark10JSONWriter4nameEPKcj>
 80a32d6:	1b7a      	subs	r2, r7, r5
 80a32d8:	4629      	mov	r1, r5
 80a32da:	f7fe fcc4 	bl	80a1c66 <_ZN5spark10JSONWriter5valueEPKcj>
    }
    // Timestamp
    if (attr.has_time) {
 80a32de:	7923      	ldrb	r3, [r4, #4]
 80a32e0:	0719      	lsls	r1, r3, #28
 80a32e2:	d507      	bpl.n	80a32f4 <_ZN5spark20JSONStreamLogHandler10logMessageEPKc8LogLevelS2_RK13LogAttributes+0x100>
        json.name("t", 1).value((unsigned)attr.time);
 80a32e4:	491d      	ldr	r1, [pc, #116]	; (80a335c <_ZN5spark20JSONStreamLogHandler10logMessageEPKc8LogLevelS2_RK13LogAttributes+0x168>)
 80a32e6:	2201      	movs	r2, #1
 80a32e8:	a801      	add	r0, sp, #4
 80a32ea:	f7fe fcad 	bl	80a1c48 <_ZN5spark10JSONWriter4nameEPKcj>
 80a32ee:	6961      	ldr	r1, [r4, #20]
 80a32f0:	f7fe fc44 	bl	80a1b7c <_ZN5spark10JSONWriter5valueEj>
    }
    // Code (additional attribute)
    if (attr.has_code) {
 80a32f4:	7923      	ldrb	r3, [r4, #4]
 80a32f6:	06da      	lsls	r2, r3, #27
 80a32f8:	d508      	bpl.n	80a330c <_ZN5spark20JSONStreamLogHandler10logMessageEPKc8LogLevelS2_RK13LogAttributes+0x118>
        json.name("code", 4).value((int)attr.code);
 80a32fa:	2204      	movs	r2, #4
 80a32fc:	4918      	ldr	r1, [pc, #96]	; (80a3360 <_ZN5spark20JSONStreamLogHandler10logMessageEPKc8LogLevelS2_RK13LogAttributes+0x16c>)
 80a32fe:	eb0d 0002 	add.w	r0, sp, r2
 80a3302:	f7fe fca1 	bl	80a1c48 <_ZN5spark10JSONWriter4nameEPKcj>
 80a3306:	69a1      	ldr	r1, [r4, #24]
 80a3308:	f7fe fc26 	bl	80a1b58 <_ZN5spark10JSONWriter5valueEi>
    }
    // Details (additional attribute)
    if (attr.has_details) {
 80a330c:	7923      	ldrb	r3, [r4, #4]
 80a330e:	069b      	lsls	r3, r3, #26
 80a3310:	d507      	bpl.n	80a3322 <_ZN5spark20JSONStreamLogHandler10logMessageEPKc8LogLevelS2_RK13LogAttributes+0x12e>
        json.name("detail", 6).value(attr.details);
 80a3312:	4914      	ldr	r1, [pc, #80]	; (80a3364 <_ZN5spark20JSONStreamLogHandler10logMessageEPKc8LogLevelS2_RK13LogAttributes+0x170>)
 80a3314:	2206      	movs	r2, #6
 80a3316:	a801      	add	r0, sp, #4
 80a3318:	f7fe fc96 	bl	80a1c48 <_ZN5spark10JSONWriter4nameEPKcj>
 80a331c:	69e1      	ldr	r1, [r4, #28]
 80a331e:	f7ff f8b4 	bl	80a248a <_ZN5spark10JSONWriter5valueEPKc>
    }
    json.endObject();
 80a3322:	a801      	add	r0, sp, #4
 80a3324:	f7fe fbf5 	bl	80a1b12 <_ZN5spark10JSONWriter9endObjectEv>
 80a3328:	6a30      	ldr	r0, [r6, #32]
    this->stream()->write((const uint8_t*)"\r\n", 2);
 80a332a:	2202      	movs	r2, #2
 80a332c:	6803      	ldr	r3, [r0, #0]
 80a332e:	490e      	ldr	r1, [pc, #56]	; (80a3368 <_ZN5spark20JSONStreamLogHandler10logMessageEPKc8LogLevelS2_RK13LogAttributes+0x174>)
 80a3330:	68db      	ldr	r3, [r3, #12]
 80a3332:	4798      	blx	r3
}
 80a3334:	b005      	add	sp, #20
 80a3336:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 80a333a:	bf00      	nop
 80a333c:	20000120 	.word	0x20000120
 80a3340:	080a4b88 	.word	0x080a4b88
 80a3344:	080a4bba 	.word	0x080a4bba
 80a3348:	080a4bd0 	.word	0x080a4bd0
 80a334c:	080a4c89 	.word	0x080a4c89
 80a3350:	080a4a6d 	.word	0x080a4a6d
 80a3354:	080a4c58 	.word	0x080a4c58
 80a3358:	080a4c5b 	.word	0x080a4c5b
 80a335c:	080a4be5 	.word	0x080a4be5
 80a3360:	080a4c5e 	.word	0x080a4c5e
 80a3364:	080a4c63 	.word	0x080a4c63
 80a3368:	080a4c55 	.word	0x080a4c55

080a336c <_ZN5Print5writeEPKhj>:

// Public Methods //////////////////////////////////////////////////////////////

/* default implementation: may be overridden */
size_t Print::write(const uint8_t *buffer, size_t size)
{
 80a336c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80a336e:	4606      	mov	r6, r0
 80a3370:	460d      	mov	r5, r1
 80a3372:	188f      	adds	r7, r1, r2
  size_t n = 0;
 80a3374:	2400      	movs	r4, #0
  while (size--) {
 80a3376:	42bd      	cmp	r5, r7
 80a3378:	d00c      	beq.n	80a3394 <_ZN5Print5writeEPKhj+0x28>
     int chunk = write(*buffer++);
 80a337a:	6833      	ldr	r3, [r6, #0]
 80a337c:	f815 1b01 	ldrb.w	r1, [r5], #1
 80a3380:	689b      	ldr	r3, [r3, #8]
 80a3382:	4630      	mov	r0, r6
 80a3384:	4798      	blx	r3
     if (chunk>=0)
 80a3386:	2800      	cmp	r0, #0
 80a3388:	db01      	blt.n	80a338e <_ZN5Print5writeEPKhj+0x22>
         n += chunk;
 80a338a:	4404      	add	r4, r0

/* default implementation: may be overridden */
size_t Print::write(const uint8_t *buffer, size_t size)
{
  size_t n = 0;
  while (size--) {
 80a338c:	e7f3      	b.n	80a3376 <_ZN5Print5writeEPKhj+0xa>
     int chunk = write(*buffer++);
 80a338e:	2c00      	cmp	r4, #0
 80a3390:	bf08      	it	eq
 80a3392:	4604      	moveq	r4, r0
             n = chunk;
         break;
     }
  }
  return n;
}
 80a3394:	4620      	mov	r0, r4
 80a3396:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

080a3398 <_ZN5Print5writeEPKc>:

    int getWriteError() { return write_error; }
    void clearWriteError() { setWriteError(0); }

    virtual size_t write(uint8_t) = 0;
    size_t write(const char *str) {
 80a3398:	b570      	push	{r4, r5, r6, lr}
 80a339a:	4605      	mov	r5, r0
      if (str == NULL) return 0;
 80a339c:	460c      	mov	r4, r1
      return write((const uint8_t *)str, strlen(str));
    }
 80a339e:	4608      	mov	r0, r1
    int getWriteError() { return write_error; }
    void clearWriteError() { setWriteError(0); }

    virtual size_t write(uint8_t) = 0;
    size_t write(const char *str) {
      if (str == NULL) return 0;
 80a33a0:	b149      	cbz	r1, 80a33b6 <_ZN5Print5writeEPKc+0x1e>
      return write((const uint8_t *)str, strlen(str));
 80a33a2:	f000 fd03 	bl	80a3dac <strlen>
 80a33a6:	682b      	ldr	r3, [r5, #0]
 80a33a8:	4602      	mov	r2, r0
 80a33aa:	4621      	mov	r1, r4
 80a33ac:	4628      	mov	r0, r5
    }
 80a33ae:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    void clearWriteError() { setWriteError(0); }

    virtual size_t write(uint8_t) = 0;
    size_t write(const char *str) {
      if (str == NULL) return 0;
      return write((const uint8_t *)str, strlen(str));
 80a33b2:	68db      	ldr	r3, [r3, #12]
 80a33b4:	4718      	bx	r3
    }
 80a33b6:	bd70      	pop	{r4, r5, r6, pc}

080a33b8 <_ZN5Print5printEPKc>:
 80a33b8:	b508      	push	{r3, lr}
 80a33ba:	f7ff ffed 	bl	80a3398 <_ZN5Print5writeEPKc>
 80a33be:	bd08      	pop	{r3, pc}

080a33c0 <_ZN5Print5printEc>:
  return write(str);
}

size_t Print::print(char c)
{
  return write(c);
 80a33c0:	6803      	ldr	r3, [r0, #0]
 80a33c2:	689b      	ldr	r3, [r3, #8]
 80a33c4:	4718      	bx	r3

080a33c6 <_ZN5Print7printlnEv>:
{
  return print(reinterpret_cast<const char*>(str));
}

size_t Print::println(void)
{
 80a33c6:	b538      	push	{r3, r4, r5, lr}
  size_t n = print('\r');
 80a33c8:	210d      	movs	r1, #13
{
  return print(reinterpret_cast<const char*>(str));
}

size_t Print::println(void)
{
 80a33ca:	4605      	mov	r5, r0
  size_t n = print('\r');
 80a33cc:	f7ff fff8 	bl	80a33c0 <_ZN5Print5printEc>
  n += print('\n');
 80a33d0:	210a      	movs	r1, #10
  return print(reinterpret_cast<const char*>(str));
}

size_t Print::println(void)
{
  size_t n = print('\r');
 80a33d2:	4604      	mov	r4, r0
  n += print('\n');
 80a33d4:	4628      	mov	r0, r5
 80a33d6:	f7ff fff3 	bl	80a33c0 <_ZN5Print5printEc>
  return n;
}
 80a33da:	4420      	add	r0, r4
 80a33dc:	bd38      	pop	{r3, r4, r5, pc}

080a33de <_ZN5Print11printNumberEmh>:
  char *str = &buf[sizeof(buf) - 1];

  *str = '\0';

  // prevent crash if called with base == 1
  if (base < 2) base = 10;
 80a33de:	2a01      	cmp	r2, #1
 80a33e0:	bf98      	it	ls
 80a33e2:	220a      	movls	r2, #10
  return println(reinterpret_cast<const char*>(str));
}

// Private Methods /////////////////////////////////////////////////////////////

size_t Print::printNumber(unsigned long n, uint8_t base) {
 80a33e4:	b530      	push	{r4, r5, lr}
 80a33e6:	460b      	mov	r3, r1
 80a33e8:	b08b      	sub	sp, #44	; 0x2c
  char buf[8 * sizeof(n) + 1]; // Assumes 8-bit chars plus zero byte.
  char *str = &buf[sizeof(buf) - 1];

  *str = '\0';
 80a33ea:	2100      	movs	r1, #0
 80a33ec:	f88d 1024 	strb.w	r1, [sp, #36]	; 0x24
 80a33f0:	f10d 0423 	add.w	r4, sp, #35	; 0x23
  // prevent crash if called with base == 1
  if (base < 2) base = 10;

  do {
   decltype(n) m = n;
   n /= base;
 80a33f4:	fbb3 f5f2 	udiv	r5, r3, r2
   char c = m - base * n;
 80a33f8:	fb05 3312 	mls	r3, r5, r2, r3
 80a33fc:	b2db      	uxtb	r3, r3
   *--str = c < 10 ? c + '0' : c + 'A' - 10;
 80a33fe:	2b09      	cmp	r3, #9
 80a3400:	bf94      	ite	ls
 80a3402:	3330      	addls	r3, #48	; 0x30
 80a3404:	3337      	addhi	r3, #55	; 0x37
 80a3406:	b2db      	uxtb	r3, r3
 80a3408:	4621      	mov	r1, r4
 80a340a:	f804 3901 	strb.w	r3, [r4], #-1
 80a340e:	462b      	mov	r3, r5
  *str = '\0';

  // prevent crash if called with base == 1
  if (base < 2) base = 10;

  do {
 80a3410:	2d00      	cmp	r5, #0
 80a3412:	d1ef      	bne.n	80a33f4 <_ZN5Print11printNumberEmh+0x16>
   n /= base;
   char c = m - base * n;
   *--str = c < 10 ? c + '0' : c + 'A' - 10;
  } while(n);

  return write(str);
 80a3414:	f7ff ffc0 	bl	80a3398 <_ZN5Print5writeEPKc>
}
 80a3418:	b00b      	add	sp, #44	; 0x2c
 80a341a:	bd30      	pop	{r4, r5, pc}

080a341c <_ZN5Print11printf_implEbPKcz>:

  return n;
}

size_t Print::printf_impl(bool newline, const char* format, ...)
{
 80a341c:	b40c      	push	{r2, r3}
 80a341e:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 80a3422:	b087      	sub	sp, #28
 80a3424:	af00      	add	r7, sp, #0
 80a3426:	f107 0438 	add.w	r4, r7, #56	; 0x38
 80a342a:	f854 9b04 	ldr.w	r9, [r4], #4
 80a342e:	4605      	mov	r5, r0
 80a3430:	460e      	mov	r6, r1
    const int bufsize = 20;
    char test[bufsize];
    va_list marker;
    va_start(marker, format);
    size_t n = vsnprintf(test, bufsize, format, marker);
 80a3432:	4623      	mov	r3, r4
 80a3434:	464a      	mov	r2, r9
 80a3436:	2114      	movs	r1, #20
 80a3438:	1d38      	adds	r0, r7, #4
size_t Print::printf_impl(bool newline, const char* format, ...)
{
    const int bufsize = 20;
    char test[bufsize];
    va_list marker;
    va_start(marker, format);
 80a343a:	603c      	str	r4, [r7, #0]
    size_t n = vsnprintf(test, bufsize, format, marker);
 80a343c:	f7fe fa98 	bl	80a1970 <vsnprintf>
    va_end(marker);

    if (n<bufsize)
 80a3440:	2813      	cmp	r0, #19
 80a3442:	d805      	bhi.n	80a3450 <_ZN5Print11printf_implEbPKcz+0x34>
  return n;
}

size_t Print::print(const char str[])
{
  return write(str);
 80a3444:	1d39      	adds	r1, r7, #4
 80a3446:	4628      	mov	r0, r5
 80a3448:	f7ff ffa6 	bl	80a3398 <_ZN5Print5writeEPKc>
 80a344c:	4604      	mov	r4, r0
 80a344e:	e013      	b.n	80a3478 <_ZN5Print11printf_implEbPKcz+0x5c>
    {
        n = print(test);
    }
    else
    {
        char bigger[n+1];
 80a3450:	f100 0308 	add.w	r3, r0, #8
 80a3454:	f023 0307 	bic.w	r3, r3, #7
        va_start(marker, format);
        n = vsnprintf(bigger, n+1, format, marker);
        va_end(marker);
        n = print(bigger);
 80a3458:	46e8      	mov	r8, sp
    {
        n = print(test);
    }
    else
    {
        char bigger[n+1];
 80a345a:	ebad 0d03 	sub.w	sp, sp, r3
        va_start(marker, format);
        n = vsnprintf(bigger, n+1, format, marker);
 80a345e:	1c41      	adds	r1, r0, #1
 80a3460:	4623      	mov	r3, r4
 80a3462:	464a      	mov	r2, r9
 80a3464:	4668      	mov	r0, sp
        n = print(test);
    }
    else
    {
        char bigger[n+1];
        va_start(marker, format);
 80a3466:	603c      	str	r4, [r7, #0]
        n = vsnprintf(bigger, n+1, format, marker);
 80a3468:	f7fe fa82 	bl	80a1970 <vsnprintf>
  return n;
}

size_t Print::print(const char str[])
{
  return write(str);
 80a346c:	4669      	mov	r1, sp
 80a346e:	4628      	mov	r0, r5
 80a3470:	f7ff ff92 	bl	80a3398 <_ZN5Print5writeEPKc>
 80a3474:	4604      	mov	r4, r0
 80a3476:	46c5      	mov	sp, r8
        va_start(marker, format);
        n = vsnprintf(bigger, n+1, format, marker);
        va_end(marker);
        n = print(bigger);
    }
    if (newline)
 80a3478:	b11e      	cbz	r6, 80a3482 <_ZN5Print11printf_implEbPKcz+0x66>
        n += println();
 80a347a:	4628      	mov	r0, r5
 80a347c:	f7ff ffa3 	bl	80a33c6 <_ZN5Print7printlnEv>
 80a3480:	4404      	add	r4, r0
    return n;
}
 80a3482:	4620      	mov	r0, r4
 80a3484:	371c      	adds	r7, #28
 80a3486:	46bd      	mov	sp, r7
 80a3488:	e8bd 43f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, lr}
 80a348c:	b002      	add	sp, #8
 80a348e:	4770      	bx	lr

080a3490 <_ZN11USARTSerialD1Ev>:
private:
  HAL_USART_Serial _serial;
  bool _blocking;
public:
  USARTSerial(HAL_USART_Serial serial, Ring_Buffer *rx_buffer, Ring_Buffer *tx_buffer);
  virtual ~USARTSerial() {};
 80a3490:	4770      	bx	lr

080a3492 <_ZN11USARTSerial14blockOnOverrunEb>:
    HAL_USART_Half_Duplex(_serial, Enable);
}

void USARTSerial::blockOnOverrun(bool block)
{
  _blocking = block;
 80a3492:	7441      	strb	r1, [r0, #17]
 80a3494:	4770      	bx	lr

080a3496 <_ZN11USARTSerial17availableForWriteEv>:
}


int USARTSerial::availableForWrite(void)
{
 80a3496:	b508      	push	{r3, lr}
  return std::max(0, (int)HAL_USART_Available_Data_For_Write(_serial));
 80a3498:	7c00      	ldrb	r0, [r0, #16]
 80a349a:	f7fe f91d 	bl	80a16d8 <HAL_USART_Available_Data_For_Write>
}
 80a349e:	ea20 70e0 	bic.w	r0, r0, r0, asr #31
 80a34a2:	bd08      	pop	{r3, pc}

080a34a4 <_ZN11USARTSerial9availableEv>:

int USARTSerial::available(void)
{
 80a34a4:	b508      	push	{r3, lr}
  return std::max(0, (int)HAL_USART_Available_Data(_serial));
 80a34a6:	7c00      	ldrb	r0, [r0, #16]
 80a34a8:	f7fe f8ee 	bl	80a1688 <HAL_USART_Available_Data>
}
 80a34ac:	ea20 70e0 	bic.w	r0, r0, r0, asr #31
 80a34b0:	bd08      	pop	{r3, pc}

080a34b2 <_ZN11USARTSerial4peekEv>:

int USARTSerial::peek(void)
{
 80a34b2:	b508      	push	{r3, lr}
  return std::max(-1, (int)HAL_USART_Peek_Data(_serial));
 80a34b4:	7c00      	ldrb	r0, [r0, #16]
 80a34b6:	f7fe f8f7 	bl	80a16a8 <HAL_USART_Peek_Data>
}
 80a34ba:	ea30 0020 	bics.w	r0, r0, r0, asr #32
 80a34be:	bf28      	it	cs
 80a34c0:	f04f 30ff 	movcs.w	r0, #4294967295
 80a34c4:	bd08      	pop	{r3, pc}

080a34c6 <_ZN11USARTSerial4readEv>:

int USARTSerial::read(void)
{
 80a34c6:	b508      	push	{r3, lr}
  return std::max(-1, (int)HAL_USART_Read_Data(_serial));
 80a34c8:	7c00      	ldrb	r0, [r0, #16]
 80a34ca:	f7fe f8e5 	bl	80a1698 <HAL_USART_Read_Data>
}
 80a34ce:	ea30 0020 	bics.w	r0, r0, r0, asr #32
 80a34d2:	bf28      	it	cs
 80a34d4:	f04f 30ff 	movcs.w	r0, #4294967295
 80a34d8:	bd08      	pop	{r3, pc}

080a34da <_ZN11USARTSerial5flushEv>:

void USARTSerial::flush()
{
  HAL_USART_Flush_Data(_serial);
 80a34da:	7c00      	ldrb	r0, [r0, #16]
 80a34dc:	f7fe b8ec 	b.w	80a16b8 <HAL_USART_Flush_Data>

080a34e0 <_ZN11USARTSerialD0Ev>:
 80a34e0:	b510      	push	{r4, lr}
 80a34e2:	4604      	mov	r4, r0
 80a34e4:	2114      	movs	r1, #20
 80a34e6:	f000 fa7f 	bl	80a39e8 <_ZdlPvj>
 80a34ea:	4620      	mov	r0, r4
 80a34ec:	bd10      	pop	{r4, pc}

080a34ee <_ZN11USARTSerial5writeEh>:
}

size_t USARTSerial::write(uint8_t c)
{
 80a34ee:	b570      	push	{r4, r5, r6, lr}
  // attempt a write if blocking, or for non-blocking if there is room.
  if (_blocking || HAL_USART_Available_Data_For_Write(_serial) > 0) {
 80a34f0:	7c45      	ldrb	r5, [r0, #17]
{
  HAL_USART_Flush_Data(_serial);
}

size_t USARTSerial::write(uint8_t c)
{
 80a34f2:	4604      	mov	r4, r0
 80a34f4:	460e      	mov	r6, r1
  // attempt a write if blocking, or for non-blocking if there is room.
  if (_blocking || HAL_USART_Available_Data_For_Write(_serial) > 0) {
 80a34f6:	b925      	cbnz	r5, 80a3502 <_ZN11USARTSerial5writeEh+0x14>
 80a34f8:	7c00      	ldrb	r0, [r0, #16]
 80a34fa:	f7fe f8ed 	bl	80a16d8 <HAL_USART_Available_Data_For_Write>
 80a34fe:	2800      	cmp	r0, #0
 80a3500:	dd05      	ble.n	80a350e <_ZN11USARTSerial5writeEh+0x20>
    // the HAL always blocks.
	  return HAL_USART_Write_Data(_serial, c);
 80a3502:	4631      	mov	r1, r6
 80a3504:	7c20      	ldrb	r0, [r4, #16]
  }
  return 0;
}
 80a3506:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
size_t USARTSerial::write(uint8_t c)
{
  // attempt a write if blocking, or for non-blocking if there is room.
  if (_blocking || HAL_USART_Available_Data_For_Write(_serial) > 0) {
    // the HAL always blocks.
	  return HAL_USART_Write_Data(_serial, c);
 80a350a:	f7fe b8b5 	b.w	80a1678 <HAL_USART_Write_Data>
  }
  return 0;
}
 80a350e:	4628      	mov	r0, r5
 80a3510:	bd70      	pop	{r4, r5, r6, pc}
	...

080a3514 <_ZN11USARTSerialC1E16HAL_USART_SerialP11Ring_BufferS2_>:
#include "spark_wiring_constants.h"
#include "module_info.h"

// Constructors ////////////////////////////////////////////////////////////////

USARTSerial::USARTSerial(HAL_USART_Serial serial, Ring_Buffer *rx_buffer, Ring_Buffer *tx_buffer)
 80a3514:	b510      	push	{r4, lr}
 80a3516:	4604      	mov	r4, r0
 80a3518:	4608      	mov	r0, r1
 80a351a:	4611      	mov	r1, r2
  protected:
    void setWriteError(int err = 1) { write_error = err; }
    size_t printf_impl(bool newline, const char* format, ...);

  public:
    Print() : write_error(0) {}
 80a351c:	2200      	movs	r2, #0
 80a351e:	6062      	str	r2, [r4, #4]
 80a3520:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
 80a3524:	60a2      	str	r2, [r4, #8]
 80a3526:	4a05      	ldr	r2, [pc, #20]	; (80a353c <_ZN11USARTSerialC1E16HAL_USART_SerialP11Ring_BufferS2_+0x28>)
{
  _serial = serial;
 80a3528:	7420      	strb	r0, [r4, #16]
#include "spark_wiring_constants.h"
#include "module_info.h"

// Constructors ////////////////////////////////////////////////////////////////

USARTSerial::USARTSerial(HAL_USART_Serial serial, Ring_Buffer *rx_buffer, Ring_Buffer *tx_buffer)
 80a352a:	6022      	str	r2, [r4, #0]
{
  _serial = serial;
  // Default is blocking mode
  _blocking = true;
 80a352c:	2201      	movs	r2, #1
 80a352e:	7462      	strb	r2, [r4, #17]
  HAL_USART_Init(serial, rx_buffer, tx_buffer);
 80a3530:	461a      	mov	r2, r3
 80a3532:	f7fe f891 	bl	80a1658 <HAL_USART_Init>
}
 80a3536:	4620      	mov	r0, r4
 80a3538:	bd10      	pop	{r4, pc}
 80a353a:	bf00      	nop
 80a353c:	080a4ce0 	.word	0x080a4ce0

080a3540 <_ZN11USARTSerial5beginEmm>:
  begin(baud, SERIAL_8N1);
}

void USARTSerial::begin(unsigned long baud, uint32_t config)
{
  HAL_USART_BeginConfig(_serial, baud, config, 0);
 80a3540:	2300      	movs	r3, #0
 80a3542:	7c00      	ldrb	r0, [r0, #16]
 80a3544:	f7fe b8d0 	b.w	80a16e8 <HAL_USART_BeginConfig>

080a3548 <_ZN11USARTSerial5beginEm>:
}
// Public Methods //////////////////////////////////////////////////////////////

void USARTSerial::begin(unsigned long baud)
{
  begin(baud, SERIAL_8N1);
 80a3548:	2200      	movs	r2, #0
 80a354a:	f7ff bff9 	b.w	80a3540 <_ZN11USARTSerial5beginEmm>

080a354e <_ZN11USARTSerial3endEv>:
  HAL_USART_BeginConfig(_serial, baud, config, 0);
}

void USARTSerial::end()
{
  HAL_USART_End(_serial);
 80a354e:	7c00      	ldrb	r0, [r0, #16]
 80a3550:	f7fe b88a 	b.w	80a1668 <HAL_USART_End>

080a3554 <_ZN11USARTSerial9isEnabledEv>:
USARTSerial::operator bool() {
  return true;
}

bool USARTSerial::isEnabled() {
  return HAL_USART_Is_Enabled(_serial);
 80a3554:	7c00      	ldrb	r0, [r0, #16]
 80a3556:	f7fe b8b7 	b.w	80a16c8 <HAL_USART_Is_Enabled>
	...

080a355c <_Z22__fetch_global_Serial1v>:
static Ring_Buffer* serial1_rx_buffer = NULL;
static Ring_Buffer* serial1_tx_buffer = NULL;
#endif

USARTSerial& __fetch_global_Serial1()
{
 80a355c:	b538      	push	{r3, r4, r5, lr}
#if ((MODULE_FUNCTION == MOD_FUNC_USER_PART) || (MODULE_FUNCTION == MOD_FUNC_MONO_FIRMWARE))
	static USARTSerial serial1(HAL_USART_SERIAL1, &serial1_rx_buffer, &serial1_tx_buffer);
 80a355e:	4d0c      	ldr	r5, [pc, #48]	; (80a3590 <_Z22__fetch_global_Serial1v+0x34>)
 80a3560:	6829      	ldr	r1, [r5, #0]
 80a3562:	f011 0401 	ands.w	r4, r1, #1
 80a3566:	d111      	bne.n	80a358c <_Z22__fetch_global_Serial1v+0x30>
 80a3568:	4628      	mov	r0, r5
 80a356a:	f7fc fda3 	bl	80a00b4 <__cxa_guard_acquire>
 80a356e:	b168      	cbz	r0, 80a358c <_Z22__fetch_global_Serial1v+0x30>
 80a3570:	4a08      	ldr	r2, [pc, #32]	; (80a3594 <_Z22__fetch_global_Serial1v+0x38>)
 80a3572:	4621      	mov	r1, r4
 80a3574:	4b08      	ldr	r3, [pc, #32]	; (80a3598 <_Z22__fetch_global_Serial1v+0x3c>)
 80a3576:	4809      	ldr	r0, [pc, #36]	; (80a359c <_Z22__fetch_global_Serial1v+0x40>)
 80a3578:	f7ff ffcc 	bl	80a3514 <_ZN11USARTSerialC1E16HAL_USART_SerialP11Ring_BufferS2_>
 80a357c:	4628      	mov	r0, r5
 80a357e:	f7fc fd9e 	bl	80a00be <__cxa_guard_release>
 80a3582:	4a07      	ldr	r2, [pc, #28]	; (80a35a0 <_Z22__fetch_global_Serial1v+0x44>)
 80a3584:	4907      	ldr	r1, [pc, #28]	; (80a35a4 <_Z22__fetch_global_Serial1v+0x48>)
 80a3586:	4805      	ldr	r0, [pc, #20]	; (80a359c <_Z22__fetch_global_Serial1v+0x40>)
 80a3588:	f000 fa20 	bl	80a39cc <__aeabi_atexit>
    serial1_tx_buffer = new Ring_Buffer();
  }
  static USARTSerial serial1(HAL_USART_SERIAL1, serial1_rx_buffer, serial1_tx_buffer);
#endif
	return serial1;
}
 80a358c:	4803      	ldr	r0, [pc, #12]	; (80a359c <_Z22__fetch_global_Serial1v+0x40>)
 80a358e:	bd38      	pop	{r3, r4, r5, pc}
 80a3590:	20000558 	.word	0x20000558
 80a3594:	2000055c 	.word	0x2000055c
 80a3598:	200004d4 	.word	0x200004d4
 80a359c:	200004c0 	.word	0x200004c0
 80a35a0:	20000074 	.word	0x20000074
 80a35a4:	080a3491 	.word	0x080a3491

080a35a8 <_ZN17SystemSleepResult22freeWakeupSourceMemoryEv.isra.2>:
    operator SleepResult() {
        return toSleepResult();
    }

private:
    void freeWakeupSourceMemory() {
 80a35a8:	b510      	push	{r4, lr}
 80a35aa:	4604      	mov	r4, r0
        if (wakeupSource_) {
 80a35ac:	6800      	ldr	r0, [r0, #0]
 80a35ae:	b118      	cbz	r0, 80a35b8 <_ZN17SystemSleepResult22freeWakeupSourceMemoryEv.isra.2+0x10>
            free(wakeupSource_);
 80a35b0:	f7fe f9ce 	bl	80a1950 <free>
            wakeupSource_ = nullptr;
 80a35b4:	2300      	movs	r3, #0
 80a35b6:	6023      	str	r3, [r4, #0]
 80a35b8:	bd10      	pop	{r4, pc}

080a35ba <_ZN11SystemClassD1Ev>:
    system_error_t error_;
    SleepResult compatResult_;
};


class SystemClass {
 80a35ba:	b510      	push	{r4, lr}
 80a35bc:	4604      	mov	r4, r0
        }
        return *this;
    }

    ~SystemSleepResult() {
        freeWakeupSourceMemory();
 80a35be:	f7ff fff3 	bl	80a35a8 <_ZN17SystemSleepResult22freeWakeupSourceMemoryEv.isra.2>
    system_error_t error_;
    SleepResult compatResult_;
};


class SystemClass {
 80a35c2:	4620      	mov	r0, r4
 80a35c4:	bd10      	pop	{r4, pc}
	...

080a35c8 <_GLOBAL__sub_I_System>:
    WAKEUP_REASON_PIN_OR_RTC = 3,
    WAKEUP_REASON_UNKNOWN = 4
};

struct SleepResult {
    SleepResult() {}
 80a35c8:	f64f 73ff 	movw	r3, #65535	; 0xffff
    return wokenUpByRtc();
}

system_error_t SleepResult::error() const {
    return err_;
 80a35cc:	b510      	push	{r4, lr}

class SystemSleepResult {
public:
    SystemSleepResult()
            : wakeupSource_(nullptr),
              error_(SYSTEM_ERROR_NONE) {
 80a35ce:	4c08      	ldr	r4, [pc, #32]	; (80a35f0 <_GLOBAL__sub_I_System+0x28>)
 80a35d0:	2000      	movs	r0, #0
 80a35d2:	6020      	str	r0, [r4, #0]
 80a35d4:	80a0      	strh	r0, [r4, #4]
    WAKEUP_REASON_PIN_OR_RTC = 3,
    WAKEUP_REASON_UNKNOWN = 4
};

struct SleepResult {
    SleepResult() {}
 80a35d6:	71a0      	strb	r0, [r4, #6]
 80a35d8:	8120      	strh	r0, [r4, #8]
 80a35da:	8163      	strh	r3, [r4, #10]

class SystemClass {
public:

    SystemClass(System_Mode_TypeDef mode = DEFAULT) {
        set_system_mode(mode);
 80a35dc:	f7fe f98c 	bl	80a18f8 <set_system_mode>

#if Wiring_LogConfig
extern void(*log_process_ctrl_request_callback)(ctrl_request* req);
#endif

SystemClass System;
 80a35e0:	4620      	mov	r0, r4
    return wokenUpByRtc();
}

system_error_t SleepResult::error() const {
    return err_;
 80a35e2:	e8bd 4010 	ldmia.w	sp!, {r4, lr}

#if Wiring_LogConfig
extern void(*log_process_ctrl_request_callback)(ctrl_request* req);
#endif

SystemClass System;
 80a35e6:	4a03      	ldr	r2, [pc, #12]	; (80a35f4 <_GLOBAL__sub_I_System+0x2c>)
 80a35e8:	4903      	ldr	r1, [pc, #12]	; (80a35f8 <_GLOBAL__sub_I_System+0x30>)
 80a35ea:	f000 b9ef 	b.w	80a39cc <__aeabi_atexit>
 80a35ee:	bf00      	nop
 80a35f0:	200005e0 	.word	0x200005e0
 80a35f4:	20000074 	.word	0x20000074
 80a35f8:	080a35bb 	.word	0x080a35bb

080a35fc <_ZN14RecursiveMutex6unlockEv>:
        }
    }

    void lock() { os_mutex_recursive_lock(handle_); }
    bool trylock() { return os_mutex_recursive_trylock(handle_)==0; }
    void unlock() { os_mutex_recursive_unlock(handle_); }
 80a35fc:	6800      	ldr	r0, [r0, #0]
 80a35fe:	f7fe b893 	b.w	80a1728 <os_mutex_recursive_unlock>

080a3602 <_ZN8SPIClassC1E17HAL_SPI_Interface>:
    }
    return particle::__SPISettings(info->clock, info->bit_order, info->data_mode);
}
} // namespace

SPIClass::SPIClass(HAL_SPI_Interface spi)
 80a3602:	b570      	push	{r4, r5, r6, lr}
 80a3604:	4604      	mov	r4, r0
 80a3606:	460e      	mov	r6, r1
    /**
     * Creates a shared mutex.
     */
    RecursiveMutex(os_mutex_recursive_t handle) : handle_(handle) {}

    RecursiveMutex() : handle_(nullptr)
 80a3608:	2500      	movs	r5, #0
 80a360a:	f840 5f08 	str.w	r5, [r0, #8]!
    {
        os_mutex_recursive_create(&handle_);
 80a360e:	f7fe f873 	bl	80a16f8 <os_mutex_recursive_create>
{
    _spi = spi;
    HAL_SPI_Init(_spi);
 80a3612:	4630      	mov	r0, r6
}
} // namespace

SPIClass::SPIClass(HAL_SPI_Interface spi)
{
    _spi = spi;
 80a3614:	7026      	strb	r6, [r4, #0]
    HAL_SPI_Init(_spi);
 80a3616:	f7fe f8b7 	bl	80a1788 <HAL_SPI_Init>
    _dividerReference = SPI_CLK_SYSTEM; // 0 indicates the system clock
 80a361a:	6065      	str	r5, [r4, #4]
}
 80a361c:	4620      	mov	r0, r4
 80a361e:	bd70      	pop	{r4, r5, r6, pc}

080a3620 <_ZN8SPIClass5beginEv>:

void SPIClass::begin()
{
 80a3620:	b538      	push	{r3, r4, r5, lr}
 80a3622:	4605      	mov	r5, r0
  int lock()
  {
#if HAL_PLATFORM_SPI_HAL_THREAD_SAFETY
    return HAL_SPI_Acquire(_spi, nullptr);
#elif PLATFORM_THREADING
    _mutex.lock();
 80a3624:	f100 0408 	add.w	r4, r0, #8
 80a3628:	4620      	mov	r0, r4
 80a362a:	f7fe ff3b 	bl	80a24a4 <_ZN14RecursiveMutex4lockEv>
    // TODO: Fetch default pin from HAL
    if (!lock())
    {
        HAL_SPI_Begin(_spi, SPI_DEFAULT_SS);
 80a362e:	7828      	ldrb	r0, [r5, #0]
 80a3630:	f64f 71ff 	movw	r1, #65535	; 0xffff
 80a3634:	f7fe f898 	bl	80a1768 <HAL_SPI_Begin>
  void unlock()
  {
#if HAL_PLATFORM_SPI_HAL_THREAD_SAFETY
    HAL_SPI_Release(_spi, nullptr);
#elif PLATFORM_THREADING
    _mutex.unlock();
 80a3638:	4620      	mov	r0, r4
 80a363a:	f7ff ffdf 	bl	80a35fc <_ZN14RecursiveMutex6unlockEv>
 80a363e:	bd38      	pop	{r3, r4, r5, pc}

080a3640 <_ZN8SPIClass14endTransactionEv>:

    return 0;
}

void SPIClass::endTransaction()
{
 80a3640:	b508      	push	{r3, lr}
 80a3642:	3008      	adds	r0, #8
 80a3644:	f7ff ffda 	bl	80a35fc <_ZN14RecursiveMutex6unlockEv>
 80a3648:	bd08      	pop	{r3, pc}
	...

080a364c <_ZN8SPIClass19computeClockDividerEjjRhRj>:
void SPIClass::computeClockDivider(unsigned reference, unsigned targetSpeed, uint8_t& divider,
                                   unsigned& clock)
{
    clock = reference;
    uint8_t scale = 0;
    clock >>= 1; // div2 is the first
 80a364c:	0840      	lsrs	r0, r0, #1
    }
}

void SPIClass::computeClockDivider(unsigned reference, unsigned targetSpeed, uint8_t& divider,
                                   unsigned& clock)
{
 80a364e:	b530      	push	{r4, r5, lr}
    clock = reference;
    uint8_t scale = 0;
    clock >>= 1; // div2 is the first
 80a3650:	6018      	str	r0, [r3, #0]
 80a3652:	2400      	movs	r4, #0
    while (clock > targetSpeed && scale < 7)
 80a3654:	6818      	ldr	r0, [r3, #0]
 80a3656:	b2e5      	uxtb	r5, r4
 80a3658:	4288      	cmp	r0, r1
 80a365a:	d906      	bls.n	80a366a <_ZN8SPIClass19computeClockDividerEjjRhRj+0x1e>
 80a365c:	3401      	adds	r4, #1
 80a365e:	2c08      	cmp	r4, #8
 80a3660:	d002      	beq.n	80a3668 <_ZN8SPIClass19computeClockDividerEjjRhRj+0x1c>
    {
        clock >>= 1;
 80a3662:	0840      	lsrs	r0, r0, #1
 80a3664:	6018      	str	r0, [r3, #0]
                                   unsigned& clock)
{
    clock = reference;
    uint8_t scale = 0;
    clock >>= 1; // div2 is the first
    while (clock > targetSpeed && scale < 7)
 80a3666:	e7f5      	b.n	80a3654 <_ZN8SPIClass19computeClockDividerEjjRhRj+0x8>
 80a3668:	2507      	movs	r5, #7
    {
        clock >>= 1;
        scale++;
    }
    divider = clock_divisors[scale];
 80a366a:	4b02      	ldr	r3, [pc, #8]	; (80a3674 <_ZN8SPIClass19computeClockDividerEjjRhRj+0x28>)
 80a366c:	5d5b      	ldrb	r3, [r3, r5]
 80a366e:	7013      	strb	r3, [r2, #0]
 80a3670:	bd30      	pop	{r4, r5, pc}
 80a3672:	bf00      	nop
 80a3674:	080a4d08 	.word	0x080a4d08

080a3678 <_ZN8SPIClass16beginTransactionERKN8particle13__SPISettingsE>:
{
    return lock();
}

int32_t SPIClass::beginTransaction(const particle::__SPISettings& settings)
{
 80a3678:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 80a367c:	4680      	mov	r8, r0
 80a367e:	b08f      	sub	sp, #60	; 0x3c
  int lock()
  {
#if HAL_PLATFORM_SPI_HAL_THREAD_SAFETY
    return HAL_SPI_Acquire(_spi, nullptr);
#elif PLATFORM_THREADING
    _mutex.lock();
 80a3680:	3008      	adds	r0, #8
 80a3682:	460e      	mov	r6, r1
 80a3684:	f7fe ff0e 	bl	80a24a4 <_ZN14RecursiveMutex4lockEv>
    // Lock peripheral
    CHECK(lock());

    // Collect existing SPI info
    hal_spi_info_t spi_info;
    querySpiInfo(_spi, &spi_info);
 80a3688:	f898 4000 	ldrb.w	r4, [r8]
 * \warning This method is NOT THREADSAFE and callers will need to utilize
 *          HAL synchronization primatives.
 */
static void querySpiInfo(HAL_SPI_Interface spi, hal_spi_info_t* info)
{
    memset(info, 0, sizeof(hal_spi_info_t));
 80a368c:	2214      	movs	r2, #20
 80a368e:	2100      	movs	r1, #0
 80a3690:	a809      	add	r0, sp, #36	; 0x24
 80a3692:	f000 fb39 	bl	80a3d08 <memset>
    info->version = HAL_SPI_INFO_VERSION_1;
 80a3696:	230b      	movs	r3, #11
    HAL_SPI_Info(spi, info, nullptr);
 80a3698:	4620      	mov	r0, r4
 80a369a:	2200      	movs	r2, #0
 80a369c:	a909      	add	r1, sp, #36	; 0x24
 *          HAL synchronization primatives.
 */
static void querySpiInfo(HAL_SPI_Interface spi, hal_spi_info_t* info)
{
    memset(info, 0, sizeof(hal_spi_info_t));
    info->version = HAL_SPI_INFO_VERSION_1;
 80a369e:	f8ad 3024 	strh.w	r3, [sp, #36]	; 0x24
    HAL_SPI_Info(spi, info, nullptr);
 80a36a2:	f7fe f881 	bl	80a17a8 <HAL_SPI_Info>
/**
 * \brief Extract SPI Settings from SPI Info Structure
 */
static particle::__SPISettings spiSettingsFromSpiInfo(hal_spi_info_t* info)
{
    if (!info || !info->enabled || info->default_settings)
 80a36a6:	f89d 402d 	ldrb.w	r4, [sp, #45]	; 0x2d
 80a36aa:	b14c      	cbz	r4, 80a36c0 <_ZN8SPIClass16beginTransactionERKN8particle13__SPISettingsE+0x48>
 80a36ac:	f89d 502c 	ldrb.w	r5, [sp, #44]	; 0x2c
 80a36b0:	b92d      	cbnz	r5, 80a36be <_ZN8SPIClass16beginTransactionERKN8particle13__SPISettingsE+0x46>
    {
        return particle::__SPISettings();
    }
    return particle::__SPISettings(info->clock, info->bit_order, info->data_mode);
 80a36b2:	9f0c      	ldr	r7, [sp, #48]	; 0x30
 80a36b4:	f89d 9034 	ldrb.w	r9, [sp, #52]	; 0x34
 80a36b8:	f89d 4035 	ldrb.w	r4, [sp, #53]	; 0x35
 80a36bc:	e003      	b.n	80a36c6 <_ZN8SPIClass16beginTransactionERKN8particle13__SPISettingsE+0x4e>
      dataMode_{dataMode}
  {
  }

  __SPISettings()
  {
 80a36be:	2400      	movs	r4, #0
 80a36c0:	46a1      	mov	r9, r4
 80a36c2:	4627      	mov	r7, r4
 80a36c4:	2501      	movs	r5, #1
 80a36c6:	7933      	ldrb	r3, [r6, #4]
  }

  bool operator==(const __SPISettings& other) const
  {
    if (default_ && other.default_)
 80a36c8:	b10d      	cbz	r5, 80a36ce <_ZN8SPIClass16beginTransactionERKN8particle13__SPISettingsE+0x56>
 80a36ca:	2b00      	cmp	r3, #0
 80a36cc:	d13f      	bne.n	80a374e <_ZN8SPIClass16beginTransactionERKN8particle13__SPISettingsE+0xd6>
      return true;

    if (default_ == other.default_ &&
 80a36ce:	429d      	cmp	r5, r3
 80a36d0:	d10b      	bne.n	80a36ea <_ZN8SPIClass16beginTransactionERKN8particle13__SPISettingsE+0x72>
 80a36d2:	68b2      	ldr	r2, [r6, #8]
 80a36d4:	42ba      	cmp	r2, r7
 80a36d6:	d108      	bne.n	80a36ea <_ZN8SPIClass16beginTransactionERKN8particle13__SPISettingsE+0x72>
        clock_ == other.clock_ &&
        bitOrder_ == other.bitOrder_ &&
 80a36d8:	f88d 9020 	strb.w	r9, [sp, #32]
 80a36dc:	f88d 4021 	strb.w	r4, [sp, #33]	; 0x21
 80a36e0:	f8bd 1020 	ldrh.w	r1, [sp, #32]
 80a36e4:	89b2      	ldrh	r2, [r6, #12]
 80a36e6:	4291      	cmp	r1, r2
 80a36e8:	d031      	beq.n	80a374e <_ZN8SPIClass16beginTransactionERKN8particle13__SPISettingsE+0xd6>
    particle::__SPISettings spi_settings = spiSettingsFromSpiInfo(&spi_info);

    // Reconfigure SPI peripheral (if necessary)
    if (settings != spi_settings)
    {
        if (settings.default_)
 80a36ea:	b13b      	cbz	r3, 80a36fc <_ZN8SPIClass16beginTransactionERKN8particle13__SPISettingsE+0x84>
        {
            HAL_SPI_Set_Settings(_spi, settings.default_, 0, 0, 0, nullptr);
 80a36ec:	2300      	movs	r3, #0
 80a36ee:	f898 0000 	ldrb.w	r0, [r8]
 80a36f2:	9301      	str	r3, [sp, #4]
 80a36f4:	9300      	str	r3, [sp, #0]
 80a36f6:	461a      	mov	r2, r3
 80a36f8:	2101      	movs	r1, #1
 80a36fa:	e016      	b.n	80a372a <_ZN8SPIClass16beginTransactionERKN8particle13__SPISettingsE+0xb2>
        }
        else
        {
            // Compute valid clock value and clock divider from supplied clock value
            uint8_t divisor = 0;
 80a36fc:	f88d 300f 	strb.w	r3, [sp, #15]
            unsigned int clock; // intentionally left uninitialized
            computeClockDivider((unsigned int)spi_info.system_clock, settings.clock_, divisor,
                                clock);
 80a3700:	68b1      	ldr	r1, [r6, #8]
 80a3702:	ab04      	add	r3, sp, #16
 80a3704:	f10d 020f 	add.w	r2, sp, #15
 80a3708:	980a      	ldr	r0, [sp, #40]	; 0x28
 80a370a:	f7ff ff9f 	bl	80a364c <_ZN8SPIClass19computeClockDividerEjjRhRj>
 80a370e:	7931      	ldrb	r1, [r6, #4]
    return false;
  }

  bool operator<=(const __SPISettings& other) const
  {
    if (default_ && other.default_)
 80a3710:	b105      	cbz	r5, 80a3714 <_ZN8SPIClass16beginTransactionERKN8particle13__SPISettingsE+0x9c>
 80a3712:	b9c9      	cbnz	r1, 80a3748 <_ZN8SPIClass16beginTransactionERKN8particle13__SPISettingsE+0xd0>
      return true;

    if (default_ == other.default_ &&
 80a3714:	42a9      	cmp	r1, r5
 80a3716:	d00b      	beq.n	80a3730 <_ZN8SPIClass16beginTransactionERKN8particle13__SPISettingsE+0xb8>

            // Ensure inequality aside from computed clock value
            if (!(spi_settings <= settings && clock == spi_settings.clock_))
            {
                HAL_SPI_Set_Settings(_spi, settings.default_, divisor, settings.bitOrder_,
                                     settings.dataMode_, nullptr);
 80a3718:	2400      	movs	r4, #0
 80a371a:	9401      	str	r4, [sp, #4]
 80a371c:	7b74      	ldrb	r4, [r6, #13]
 80a371e:	7b33      	ldrb	r3, [r6, #12]
 80a3720:	f89d 200f 	ldrb.w	r2, [sp, #15]
 80a3724:	f898 0000 	ldrb.w	r0, [r8]
 80a3728:	9400      	str	r4, [sp, #0]
 80a372a:	f7fe f845 	bl	80a17b8 <HAL_SPI_Set_Settings>
 80a372e:	e00e      	b.n	80a374e <_ZN8SPIClass16beginTransactionERKN8particle13__SPISettingsE+0xd6>
 80a3730:	68b3      	ldr	r3, [r6, #8]
 80a3732:	42bb      	cmp	r3, r7
 80a3734:	d3f0      	bcc.n	80a3718 <_ZN8SPIClass16beginTransactionERKN8particle13__SPISettingsE+0xa0>
        clock_ <= other.clock_ &&
        bitOrder_ == other.bitOrder_ &&
 80a3736:	f88d 9020 	strb.w	r9, [sp, #32]
 80a373a:	f88d 4021 	strb.w	r4, [sp, #33]	; 0x21
 80a373e:	f8bd 2020 	ldrh.w	r2, [sp, #32]
 80a3742:	89b3      	ldrh	r3, [r6, #12]
 80a3744:	429a      	cmp	r2, r3
 80a3746:	d1e7      	bne.n	80a3718 <_ZN8SPIClass16beginTransactionERKN8particle13__SPISettingsE+0xa0>
            unsigned int clock; // intentionally left uninitialized
            computeClockDivider((unsigned int)spi_info.system_clock, settings.clock_, divisor,
                                clock);

            // Ensure inequality aside from computed clock value
            if (!(spi_settings <= settings && clock == spi_settings.clock_))
 80a3748:	9b04      	ldr	r3, [sp, #16]
 80a374a:	42bb      	cmp	r3, r7
 80a374c:	d1e4      	bne.n	80a3718 <_ZN8SPIClass16beginTransactionERKN8particle13__SPISettingsE+0xa0>
            }
        }
    }

    return 0;
}
 80a374e:	2000      	movs	r0, #0
 80a3750:	b00f      	add	sp, #60	; 0x3c
 80a3752:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}

080a3756 <_ZN8SPIClass8transferEh>:

    return clock;
}

byte SPIClass::transfer(byte _data)
{
 80a3756:	b508      	push	{r3, lr}
    return static_cast<byte>(HAL_SPI_Send_Receive_Data(_spi, _data));
 80a3758:	7800      	ldrb	r0, [r0, #0]
 80a375a:	f7fe f80d 	bl	80a1778 <HAL_SPI_Send_Receive_Data>
}
 80a375e:	b2c0      	uxtb	r0, r0
 80a3760:	bd08      	pop	{r3, pc}

080a3762 <_ZN8SPIClass9isEnabledEv>:
bool SPIClass::isEnabled()
{
    // XXX: pinAvailable() will call this method potentially even from
    // interrupt context. `enabled` flag in HAL is usually just a volatile
    // variable, so it's fine not to acquire the lock here.
    return HAL_SPI_Is_Enabled(_spi);
 80a3762:	7800      	ldrb	r0, [r0, #0]
 80a3764:	f7fe b818 	b.w	80a1798 <HAL_SPI_Is_Enabled>

080a3768 <_ZN6StringC1EOS_>:
/*  Memory Management                        */
/*********************************************/

inline void String::init(void)
{
	buffer = NULL;
 80a3768:	2300      	movs	r3, #0
 80a376a:	6003      	str	r3, [r0, #0]
	capacity = 0;
 80a376c:	6043      	str	r3, [r0, #4]
	len = 0;
 80a376e:	6083      	str	r3, [r0, #8]
	flags = 0;
 80a3770:	7303      	strb	r3, [r0, #12]
	const char* cstr = reinterpret_cast<const char*>(pstr);
	if (cstr) copy(cstr, strlen(cstr));
}

#ifdef __GXX_EXPERIMENTAL_CXX0X__
String::String(String &&rval)
 80a3772:	b510      	push	{r4, lr}
			return;
		} else {
			free(buffer);
		}
	}
	buffer = rhs.buffer;
 80a3774:	680c      	ldr	r4, [r1, #0]
 80a3776:	6004      	str	r4, [r0, #0]
	capacity = rhs.capacity;
 80a3778:	684c      	ldr	r4, [r1, #4]
 80a377a:	6044      	str	r4, [r0, #4]
	len = rhs.len;
 80a377c:	688c      	ldr	r4, [r1, #8]
 80a377e:	6084      	str	r4, [r0, #8]
	rhs.buffer = NULL;
 80a3780:	600b      	str	r3, [r1, #0]
	rhs.capacity = 0;
 80a3782:	604b      	str	r3, [r1, #4]
	rhs.len = 0;
 80a3784:	608b      	str	r3, [r1, #8]
#ifdef __GXX_EXPERIMENTAL_CXX0X__
String::String(String &&rval)
{
	init();
	move(rval);
}
 80a3786:	bd10      	pop	{r4, pc}

080a3788 <_ZN6StringD1Ev>:
	init();
	char buf[33];
	dtoa(value, decimalPlaces, buf);
        *this = buf;
}
String::~String()
 80a3788:	b510      	push	{r4, lr}
 80a378a:	4604      	mov	r4, r0
{
	free(buffer);
 80a378c:	6800      	ldr	r0, [r0, #0]
 80a378e:	f7fe f8df 	bl	80a1950 <free>
}
 80a3792:	4620      	mov	r0, r4
 80a3794:	bd10      	pop	{r4, pc}

080a3796 <_ZN6String10invalidateEv>:
	len = 0;
	flags = 0;
}

void String::invalidate(void)
{
 80a3796:	b510      	push	{r4, lr}
 80a3798:	4604      	mov	r4, r0
	if (buffer) free(buffer);
 80a379a:	6800      	ldr	r0, [r0, #0]
 80a379c:	b108      	cbz	r0, 80a37a2 <_ZN6String10invalidateEv+0xc>
 80a379e:	f7fe f8d7 	bl	80a1950 <free>
	buffer = NULL;
 80a37a2:	2300      	movs	r3, #0
 80a37a4:	6023      	str	r3, [r4, #0]
	capacity = len = 0;
 80a37a6:	60a3      	str	r3, [r4, #8]
 80a37a8:	6063      	str	r3, [r4, #4]
 80a37aa:	bd10      	pop	{r4, pc}

080a37ac <_ZN6String12changeBufferEj>:
	}
	return 0;
}

unsigned char String::changeBuffer(unsigned int maxStrLen)
{
 80a37ac:	b538      	push	{r3, r4, r5, lr}
 80a37ae:	4604      	mov	r4, r0
 80a37b0:	460d      	mov	r5, r1
	char *newbuffer = (char *)realloc(buffer, maxStrLen + 1);
 80a37b2:	6800      	ldr	r0, [r0, #0]
 80a37b4:	3101      	adds	r1, #1
 80a37b6:	f7fe f8d3 	bl	80a1960 <realloc>
	if (newbuffer) {
 80a37ba:	b110      	cbz	r0, 80a37c2 <_ZN6String12changeBufferEj+0x16>
		buffer = newbuffer;
		capacity = maxStrLen;
 80a37bc:	e884 0021 	stmia.w	r4, {r0, r5}
		return 1;
 80a37c0:	2001      	movs	r0, #1
	}
	return 0;
}
 80a37c2:	bd38      	pop	{r3, r4, r5, pc}

080a37c4 <_ZN6String7reserveEj>:
	buffer = NULL;
	capacity = len = 0;
}

unsigned char String::reserve(unsigned int size)
{
 80a37c4:	b510      	push	{r4, lr}
	if (buffer && capacity >= size) return 1;
 80a37c6:	6803      	ldr	r3, [r0, #0]
	buffer = NULL;
	capacity = len = 0;
}

unsigned char String::reserve(unsigned int size)
{
 80a37c8:	4604      	mov	r4, r0
	if (buffer && capacity >= size) return 1;
 80a37ca:	b113      	cbz	r3, 80a37d2 <_ZN6String7reserveEj+0xe>
 80a37cc:	6843      	ldr	r3, [r0, #4]
 80a37ce:	428b      	cmp	r3, r1
 80a37d0:	d207      	bcs.n	80a37e2 <_ZN6String7reserveEj+0x1e>
	if (changeBuffer(size)) {
 80a37d2:	4620      	mov	r0, r4
 80a37d4:	f7ff ffea 	bl	80a37ac <_ZN6String12changeBufferEj>
 80a37d8:	b120      	cbz	r0, 80a37e4 <_ZN6String7reserveEj+0x20>
		if (len == 0) buffer[0] = 0;
 80a37da:	68a3      	ldr	r3, [r4, #8]
 80a37dc:	b90b      	cbnz	r3, 80a37e2 <_ZN6String7reserveEj+0x1e>
 80a37de:	6822      	ldr	r2, [r4, #0]
 80a37e0:	7013      	strb	r3, [r2, #0]
 80a37e2:	2001      	movs	r0, #1
		return 1;
	}
	return 0;
}
 80a37e4:	bd10      	pop	{r4, pc}

080a37e6 <_ZN6String4copyEPKcj>:
/*********************************************/
/*  Copy and Move                            */
/*********************************************/

String & String::copy(const char *cstr, unsigned int length)
{
 80a37e6:	b570      	push	{r4, r5, r6, lr}
 80a37e8:	460e      	mov	r6, r1
	if (!reserve(length)) {
 80a37ea:	4611      	mov	r1, r2
/*********************************************/
/*  Copy and Move                            */
/*********************************************/

String & String::copy(const char *cstr, unsigned int length)
{
 80a37ec:	4604      	mov	r4, r0
 80a37ee:	4615      	mov	r5, r2
	if (!reserve(length)) {
 80a37f0:	f7ff ffe8 	bl	80a37c4 <_ZN6String7reserveEj>
 80a37f4:	b918      	cbnz	r0, 80a37fe <_ZN6String4copyEPKcj+0x18>
		invalidate();
 80a37f6:	4620      	mov	r0, r4
 80a37f8:	f7ff ffcd 	bl	80a3796 <_ZN6String10invalidateEv>
		return *this;
 80a37fc:	e009      	b.n	80a3812 <_ZN6String4copyEPKcj+0x2c>
	}
	len = length;
	memcpy(buffer, cstr, length);
 80a37fe:	462a      	mov	r2, r5
 80a3800:	4631      	mov	r1, r6
{
	if (!reserve(length)) {
		invalidate();
		return *this;
	}
	len = length;
 80a3802:	60a5      	str	r5, [r4, #8]
	memcpy(buffer, cstr, length);
 80a3804:	6820      	ldr	r0, [r4, #0]
 80a3806:	f000 fa59 	bl	80a3cbc <memcpy>
	buffer[len] = 0;
 80a380a:	6822      	ldr	r2, [r4, #0]
 80a380c:	68a3      	ldr	r3, [r4, #8]
 80a380e:	2100      	movs	r1, #0
 80a3810:	54d1      	strb	r1, [r2, r3]
	return *this;
}
 80a3812:	4620      	mov	r0, r4
 80a3814:	bd70      	pop	{r4, r5, r6, pc}

080a3816 <_ZN6StringaSERKS_>:
}
#endif

String & String::operator = (const String &rhs)
{
	if (this == &rhs) return *this;
 80a3816:	4288      	cmp	r0, r1
	rhs.len = 0;
}
#endif

String & String::operator = (const String &rhs)
{
 80a3818:	b510      	push	{r4, lr}
 80a381a:	460b      	mov	r3, r1
 80a381c:	4604      	mov	r4, r0
	if (this == &rhs) return *this;
 80a381e:	d007      	beq.n	80a3830 <_ZN6StringaSERKS_+0x1a>

	if (rhs.buffer) copy(rhs.buffer, rhs.len);
 80a3820:	6809      	ldr	r1, [r1, #0]
 80a3822:	b119      	cbz	r1, 80a382c <_ZN6StringaSERKS_+0x16>
 80a3824:	689a      	ldr	r2, [r3, #8]
 80a3826:	f7ff ffde 	bl	80a37e6 <_ZN6String4copyEPKcj>
 80a382a:	e001      	b.n	80a3830 <_ZN6StringaSERKS_+0x1a>
	else invalidate();
 80a382c:	f7ff ffb3 	bl	80a3796 <_ZN6String10invalidateEv>

	return *this;
}
 80a3830:	4620      	mov	r0, r4
 80a3832:	bd10      	pop	{r4, pc}

080a3834 <_ZN6StringC1ERKS_>:
{
	init();
	if (cstr) copy(cstr, length);
}

String::String(const String &value)
 80a3834:	b510      	push	{r4, lr}
 80a3836:	4604      	mov	r4, r0
/*  Memory Management                        */
/*********************************************/

inline void String::init(void)
{
	buffer = NULL;
 80a3838:	2300      	movs	r3, #0
 80a383a:	6003      	str	r3, [r0, #0]
	capacity = 0;
 80a383c:	6043      	str	r3, [r0, #4]
	len = 0;
 80a383e:	6083      	str	r3, [r0, #8]
	flags = 0;
 80a3840:	7303      	strb	r3, [r0, #12]
}

String::String(const String &value)
{
	init();
	*this = value;
 80a3842:	f7ff ffe8 	bl	80a3816 <_ZN6StringaSERKS_>
}
 80a3846:	4620      	mov	r0, r4
 80a3848:	bd10      	pop	{r4, pc}
	...

080a384c <_Z17acquireWireBufferv>:
}

} // anonymous

HAL_I2C_Config __attribute__((weak)) acquireWireBuffer()
{
 80a384c:	b570      	push	{r4, r5, r6, lr}
 80a384e:	4604      	mov	r4, r0
		.version = HAL_I2C_CONFIG_VERSION_1,
		.rx_buffer = new (std::nothrow) uint8_t[I2C_BUFFER_LENGTH],
		.rx_buffer_size = I2C_BUFFER_LENGTH,
		.tx_buffer = new (std::nothrow) uint8_t[I2C_BUFFER_LENGTH],
		.tx_buffer_size = I2C_BUFFER_LENGTH
	};
 80a3850:	2514      	movs	r5, #20
 80a3852:	462a      	mov	r2, r5

HAL_I2C_Config defaultWireConfig() {
	HAL_I2C_Config config = {
		.size = sizeof(HAL_I2C_Config),
		.version = HAL_I2C_CONFIG_VERSION_1,
		.rx_buffer = new (std::nothrow) uint8_t[I2C_BUFFER_LENGTH],
 80a3854:	4e09      	ldr	r6, [pc, #36]	; (80a387c <_Z17acquireWireBufferv+0x30>)
		.rx_buffer_size = I2C_BUFFER_LENGTH,
		.tx_buffer = new (std::nothrow) uint8_t[I2C_BUFFER_LENGTH],
		.tx_buffer_size = I2C_BUFFER_LENGTH
	};
 80a3856:	2100      	movs	r1, #0
 80a3858:	f000 fa56 	bl	80a3d08 <memset>
 80a385c:	8025      	strh	r5, [r4, #0]
 80a385e:	2520      	movs	r5, #32

HAL_I2C_Config defaultWireConfig() {
	HAL_I2C_Config config = {
		.size = sizeof(HAL_I2C_Config),
		.version = HAL_I2C_CONFIG_VERSION_1,
		.rx_buffer = new (std::nothrow) uint8_t[I2C_BUFFER_LENGTH],
 80a3860:	4631      	mov	r1, r6
		.rx_buffer_size = I2C_BUFFER_LENGTH,
		.tx_buffer = new (std::nothrow) uint8_t[I2C_BUFFER_LENGTH],
		.tx_buffer_size = I2C_BUFFER_LENGTH
	};
 80a3862:	60a5      	str	r5, [r4, #8]
 80a3864:	6125      	str	r5, [r4, #16]

HAL_I2C_Config defaultWireConfig() {
	HAL_I2C_Config config = {
		.size = sizeof(HAL_I2C_Config),
		.version = HAL_I2C_CONFIG_VERSION_1,
		.rx_buffer = new (std::nothrow) uint8_t[I2C_BUFFER_LENGTH],
 80a3866:	4628      	mov	r0, r5
 80a3868:	f000 f8c0 	bl	80a39ec <_ZnajRKSt9nothrow_t>
		.rx_buffer_size = I2C_BUFFER_LENGTH,
		.tx_buffer = new (std::nothrow) uint8_t[I2C_BUFFER_LENGTH],
 80a386c:	4631      	mov	r1, r6
		.tx_buffer_size = I2C_BUFFER_LENGTH
	};
 80a386e:	6060      	str	r0, [r4, #4]
	HAL_I2C_Config config = {
		.size = sizeof(HAL_I2C_Config),
		.version = HAL_I2C_CONFIG_VERSION_1,
		.rx_buffer = new (std::nothrow) uint8_t[I2C_BUFFER_LENGTH],
		.rx_buffer_size = I2C_BUFFER_LENGTH,
		.tx_buffer = new (std::nothrow) uint8_t[I2C_BUFFER_LENGTH],
 80a3870:	4628      	mov	r0, r5
 80a3872:	f000 f8bb 	bl	80a39ec <_ZnajRKSt9nothrow_t>
		.tx_buffer_size = I2C_BUFFER_LENGTH
	};
 80a3876:	60e0      	str	r0, [r4, #12]
} // anonymous

HAL_I2C_Config __attribute__((weak)) acquireWireBuffer()
{
	return defaultWireConfig();
}
 80a3878:	4620      	mov	r0, r4
 80a387a:	bd70      	pop	{r4, r5, r6, pc}
 80a387c:	080a4d10 	.word	0x080a4d10

080a3880 <_Z19__fetch_global_Wirev>:
	return defaultWireConfig();
}
#endif

TwoWire& __fetch_global_Wire()
{
 80a3880:	b530      	push	{r4, r5, lr}
	static TwoWire wire(HAL_I2C_INTERFACE1, acquireWireBuffer());
 80a3882:	4d0e      	ldr	r5, [pc, #56]	; (80a38bc <_Z19__fetch_global_Wirev+0x3c>)
	return defaultWireConfig();
}
#endif

TwoWire& __fetch_global_Wire()
{
 80a3884:	b087      	sub	sp, #28
	static TwoWire wire(HAL_I2C_INTERFACE1, acquireWireBuffer());
 80a3886:	6829      	ldr	r1, [r5, #0]
 80a3888:	f011 0401 	ands.w	r4, r1, #1
 80a388c:	d113      	bne.n	80a38b6 <_Z19__fetch_global_Wirev+0x36>
 80a388e:	4628      	mov	r0, r5
 80a3890:	f7fc fc10 	bl	80a00b4 <__cxa_guard_acquire>
 80a3894:	b178      	cbz	r0, 80a38b6 <_Z19__fetch_global_Wirev+0x36>
 80a3896:	a801      	add	r0, sp, #4
 80a3898:	f7ff ffd8 	bl	80a384c <_Z17acquireWireBufferv>
 80a389c:	aa01      	add	r2, sp, #4
 80a389e:	4621      	mov	r1, r4
 80a38a0:	4807      	ldr	r0, [pc, #28]	; (80a38c0 <_Z19__fetch_global_Wirev+0x40>)
 80a38a2:	f7fe fb57 	bl	80a1f54 <_ZN7TwoWireC1E17HAL_I2C_InterfaceRK14HAL_I2C_Config>
 80a38a6:	4628      	mov	r0, r5
 80a38a8:	f7fc fc09 	bl	80a00be <__cxa_guard_release>
 80a38ac:	4a05      	ldr	r2, [pc, #20]	; (80a38c4 <_Z19__fetch_global_Wirev+0x44>)
 80a38ae:	4906      	ldr	r1, [pc, #24]	; (80a38c8 <_Z19__fetch_global_Wirev+0x48>)
 80a38b0:	4803      	ldr	r0, [pc, #12]	; (80a38c0 <_Z19__fetch_global_Wirev+0x40>)
 80a38b2:	f000 f88b 	bl	80a39cc <__aeabi_atexit>
	return wire;
}
 80a38b6:	4802      	ldr	r0, [pc, #8]	; (80a38c0 <_Z19__fetch_global_Wirev+0x40>)
 80a38b8:	b007      	add	sp, #28
 80a38ba:	bd30      	pop	{r4, r5, pc}
 80a38bc:	200005ec 	.word	0x200005ec
 80a38c0:	200005f0 	.word	0x200005f0
 80a38c4:	20000074 	.word	0x20000074
 80a38c8:	080a1efd 	.word	0x080a1efd

080a38cc <_GLOBAL__sub_I_INADDR_NONE>:
#include "spark_wiring_ipaddress.h"

#if !HAL_USE_SOCKET_HAL_POSIX
const IPAddress INADDR_NONE(0, 0, 0, 0);
 80a38cc:	b513      	push	{r0, r1, r4, lr}
 80a38ce:	4c08      	ldr	r4, [pc, #32]	; (80a38f0 <_GLOBAL__sub_I_INADDR_NONE+0x24>)
 80a38d0:	2300      	movs	r3, #0
 80a38d2:	461a      	mov	r2, r3
 80a38d4:	4619      	mov	r1, r3
 80a38d6:	9300      	str	r3, [sp, #0]
 80a38d8:	4620      	mov	r0, r4
 80a38da:	f7fe fc97 	bl	80a220c <_ZN9IPAddressC1Ehhhh>
 80a38de:	4620      	mov	r0, r4
 80a38e0:	4a04      	ldr	r2, [pc, #16]	; (80a38f4 <_GLOBAL__sub_I_INADDR_NONE+0x28>)
 80a38e2:	4905      	ldr	r1, [pc, #20]	; (80a38f8 <_GLOBAL__sub_I_INADDR_NONE+0x2c>)
 80a38e4:	b002      	add	sp, #8
 80a38e6:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 80a38ea:	f000 b86f 	b.w	80a39cc <__aeabi_atexit>
 80a38ee:	bf00      	nop
 80a38f0:	20000604 	.word	0x20000604
 80a38f4:	20000074 	.word	0x20000074
 80a38f8:	080a215d 	.word	0x080a215d

080a38fc <pinAvailable>:

/*
 * @brief Perform safety check on desired pin to see if it's already
 * being used.  Return 0 if used, otherwise return 1 if available.
 */
bool pinAvailable(uint16_t pin) {
 80a38fc:	b570      	push	{r4, r5, r6, lr}

template <HAL_SPI_Interface Interface>
class SpiProxy {
public:
    static SPIClass& instance() {
        static SPIClass instance(Interface);
 80a38fe:	4e1a      	ldr	r6, [pc, #104]	; (80a3968 <pinAvailable+0x6c>)
 80a3900:	4604      	mov	r4, r0
 80a3902:	6831      	ldr	r1, [r6, #0]
 80a3904:	f011 0501 	ands.w	r5, r1, #1
 80a3908:	d10f      	bne.n	80a392a <pinAvailable+0x2e>
 80a390a:	4630      	mov	r0, r6
 80a390c:	f7fc fbd2 	bl	80a00b4 <__cxa_guard_acquire>
 80a3910:	b158      	cbz	r0, 80a392a <pinAvailable+0x2e>
 80a3912:	4629      	mov	r1, r5
 80a3914:	4815      	ldr	r0, [pc, #84]	; (80a396c <pinAvailable+0x70>)
 80a3916:	f7ff fe74 	bl	80a3602 <_ZN8SPIClassC1E17HAL_SPI_Interface>
 80a391a:	4630      	mov	r0, r6
 80a391c:	f7fc fbcf 	bl	80a00be <__cxa_guard_release>
 80a3920:	4a13      	ldr	r2, [pc, #76]	; (80a3970 <pinAvailable+0x74>)
 80a3922:	4914      	ldr	r1, [pc, #80]	; (80a3974 <pinAvailable+0x78>)
 80a3924:	4811      	ldr	r0, [pc, #68]	; (80a396c <pinAvailable+0x70>)
 80a3926:	f000 f851 	bl	80a39cc <__aeabi_atexit>
    }
    void detachInterrupt() {
        instance().detachInterrupt();
    }
    bool isEnabled(void) {
        return instance().isEnabled();
 80a392a:	4810      	ldr	r0, [pc, #64]	; (80a396c <pinAvailable+0x70>)
 80a392c:	f7ff ff19 	bl	80a3762 <_ZN8SPIClass9isEnabledEv>

  // SPI safety check
#ifndef SPARK_WIRING_NO_SPI
  if(SPI.isEnabled() == true && (pin == SCK || pin == MOSI || pin == MISO))
 80a3930:	b128      	cbz	r0, 80a393e <pinAvailable+0x42>
 80a3932:	f1a4 030d 	sub.w	r3, r4, #13
 80a3936:	2b02      	cmp	r3, #2
 80a3938:	d801      	bhi.n	80a393e <pinAvailable+0x42>
  {
    return 0; // 'pin' is used
 80a393a:	2000      	movs	r0, #0
 80a393c:	bd70      	pop	{r4, r5, r6, pc}
  }
#endif
  // I2C safety check
#ifndef SPARK_WIRING_NO_I2C
  if(Wire.isEnabled() == true && (pin == SCL || pin == SDA))
 80a393e:	f7ff ff9f 	bl	80a3880 <_Z19__fetch_global_Wirev>
 80a3942:	f7fe fb31 	bl	80a1fa8 <_ZN7TwoWire9isEnabledEv>
 80a3946:	b108      	cbz	r0, 80a394c <pinAvailable+0x50>
 80a3948:	2c01      	cmp	r4, #1
 80a394a:	d9f6      	bls.n	80a393a <pinAvailable+0x3e>
    return 0; // 'pin' is used
  }
#endif
#ifndef SPARK_WIRING_NO_USART_SERIAL
  // Serial1 safety check
  if(Serial1.isEnabled() == true && (pin == RX || pin == TX))
 80a394c:	f7ff fe06 	bl	80a355c <_Z22__fetch_global_Serial1v>
 80a3950:	f7ff fe00 	bl	80a3554 <_ZN11USARTSerial9isEnabledEv>
 80a3954:	b118      	cbz	r0, 80a395e <pinAvailable+0x62>
 80a3956:	f1a4 0312 	sub.w	r3, r4, #18
 80a395a:	2b01      	cmp	r3, #1
 80a395c:	d9ed      	bls.n	80a393a <pinAvailable+0x3e>
  {
    return 0; // 'pin' is used
  }
#endif

  if (pin >= TOTAL_PINS)
 80a395e:	2c17      	cmp	r4, #23
 80a3960:	bf8c      	ite	hi
 80a3962:	2000      	movhi	r0, #0
 80a3964:	2001      	movls	r0, #1
    return 0;
  else
    return 1; // 'pin' is available
}
 80a3966:	bd70      	pop	{r4, r5, r6, pc}
 80a3968:	20000110 	.word	0x20000110
 80a396c:	20000114 	.word	0x20000114
 80a3970:	20000074 	.word	0x20000074
 80a3974:	080a03a5 	.word	0x080a03a5

080a3978 <pinMode>:
 * or INPUT_PULLDOWN
 */
void pinMode(uint16_t pin, PinMode setMode)
{

  if(pin >= TOTAL_PINS || setMode == PIN_MODE_NONE )
 80a3978:	2817      	cmp	r0, #23
/*
 * @brief Set the mode of the pin to OUTPUT, INPUT, INPUT_PULLUP,
 * or INPUT_PULLDOWN
 */
void pinMode(uint16_t pin, PinMode setMode)
{
 80a397a:	b538      	push	{r3, r4, r5, lr}
 80a397c:	4604      	mov	r4, r0
 80a397e:	460d      	mov	r5, r1

  if(pin >= TOTAL_PINS || setMode == PIN_MODE_NONE )
 80a3980:	d80a      	bhi.n	80a3998 <pinMode+0x20>
 80a3982:	29ff      	cmp	r1, #255	; 0xff
 80a3984:	d008      	beq.n	80a3998 <pinMode+0x20>
  {
    return;
  }

  // Safety check
  if( !pinAvailable(pin) ) {
 80a3986:	f7ff ffb9 	bl	80a38fc <pinAvailable>
 80a398a:	b128      	cbz	r0, 80a3998 <pinMode+0x20>
    return;
  }

  HAL_Pin_Mode(pin, setMode);
 80a398c:	4629      	mov	r1, r5
 80a398e:	4620      	mov	r0, r4
}
 80a3990:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  // Safety check
  if( !pinAvailable(pin) ) {
    return;
  }

  HAL_Pin_Mode(pin, setMode);
 80a3994:	f7fd bf20 	b.w	80a17d8 <HAL_Pin_Mode>
 80a3998:	bd38      	pop	{r3, r4, r5, pc}

080a399a <digitalWrite>:

/*
 * @brief Sets a GPIO pin to HIGH or LOW.
 */
void digitalWrite(pin_t pin, uint8_t value)
{
 80a399a:	b538      	push	{r3, r4, r5, lr}
 80a399c:	4604      	mov	r4, r0
 80a399e:	460d      	mov	r5, r1
    PinMode mode = HAL_Get_Pin_Mode(pin);
 80a39a0:	f7fd ff22 	bl	80a17e8 <HAL_Get_Pin_Mode>
    if (mode==PIN_MODE_NONE || is_input_mode(mode))
 80a39a4:	28ff      	cmp	r0, #255	; 0xff
 80a39a6:	d010      	beq.n	80a39ca <digitalWrite+0x30>
}

inline bool is_input_mode(PinMode mode) {
    return  mode == INPUT ||
            mode == INPUT_PULLUP ||
            mode == INPUT_PULLDOWN ||
 80a39a8:	2806      	cmp	r0, #6
 80a39aa:	d804      	bhi.n	80a39b6 <digitalWrite+0x1c>
 80a39ac:	234d      	movs	r3, #77	; 0x4d
 80a39ae:	fa23 f000 	lsr.w	r0, r3, r0
 80a39b2:	07c3      	lsls	r3, r0, #31
 80a39b4:	d409      	bmi.n	80a39ca <digitalWrite+0x30>
{
    PinMode mode = HAL_Get_Pin_Mode(pin);
    if (mode==PIN_MODE_NONE || is_input_mode(mode))
        return;
  // Safety check
  if( !pinAvailable(pin) ) {
 80a39b6:	4620      	mov	r0, r4
 80a39b8:	f7ff ffa0 	bl	80a38fc <pinAvailable>
 80a39bc:	b128      	cbz	r0, 80a39ca <digitalWrite+0x30>
    return;
  }

  HAL_GPIO_Write(pin, value);
 80a39be:	4629      	mov	r1, r5
 80a39c0:	4620      	mov	r0, r4
}
 80a39c2:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  // Safety check
  if( !pinAvailable(pin) ) {
    return;
  }

  HAL_GPIO_Write(pin, value);
 80a39c6:	f7fd bf17 	b.w	80a17f8 <HAL_GPIO_Write>
 80a39ca:	bd38      	pop	{r3, r4, r5, pc}

080a39cc <__aeabi_atexit>:
 80a39cc:	460b      	mov	r3, r1
 80a39ce:	4601      	mov	r1, r0
 80a39d0:	4618      	mov	r0, r3
 80a39d2:	f000 b965 	b.w	80a3ca0 <__cxa_atexit>
	...

080a39d8 <_ZSt15get_new_handlerv>:
 80a39d8:	4b02      	ldr	r3, [pc, #8]	; (80a39e4 <_ZSt15get_new_handlerv+0xc>)
 80a39da:	6818      	ldr	r0, [r3, #0]
 80a39dc:	f3bf 8f5f 	dmb	sy
 80a39e0:	4770      	bx	lr
 80a39e2:	bf00      	nop
 80a39e4:	20000620 	.word	0x20000620

080a39e8 <_ZdlPvj>:
 80a39e8:	f7fc bb57 	b.w	80a009a <_ZdlPv>

080a39ec <_ZnajRKSt9nothrow_t>:
 80a39ec:	f000 b800 	b.w	80a39f0 <_ZnwjRKSt9nothrow_t>

080a39f0 <_ZnwjRKSt9nothrow_t>:
 80a39f0:	b510      	push	{r4, lr}
 80a39f2:	2800      	cmp	r0, #0
 80a39f4:	bf14      	ite	ne
 80a39f6:	4604      	movne	r4, r0
 80a39f8:	2401      	moveq	r4, #1
 80a39fa:	4620      	mov	r0, r4
 80a39fc:	f7fd ffa0 	bl	80a1940 <malloc>
 80a3a00:	b920      	cbnz	r0, 80a3a0c <_ZnwjRKSt9nothrow_t+0x1c>
 80a3a02:	f7ff ffe9 	bl	80a39d8 <_ZSt15get_new_handlerv>
 80a3a06:	b108      	cbz	r0, 80a3a0c <_ZnwjRKSt9nothrow_t+0x1c>
 80a3a08:	4780      	blx	r0
 80a3a0a:	e7f6      	b.n	80a39fa <_ZnwjRKSt9nothrow_t+0xa>
 80a3a0c:	bd10      	pop	{r4, pc}
	...

080a3a10 <_GLOBAL__sub_I__ZNSt12ctype_bynameIcEC2ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEj>:
 80a3a10:	4b18      	ldr	r3, [pc, #96]	; (80a3a74 <_GLOBAL__sub_I__ZNSt12ctype_bynameIcEC2ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEj+0x64>)
 80a3a12:	681a      	ldr	r2, [r3, #0]
 80a3a14:	07d1      	lsls	r1, r2, #31
 80a3a16:	bf5c      	itt	pl
 80a3a18:	2201      	movpl	r2, #1
 80a3a1a:	601a      	strpl	r2, [r3, #0]
 80a3a1c:	4b16      	ldr	r3, [pc, #88]	; (80a3a78 <_GLOBAL__sub_I__ZNSt12ctype_bynameIcEC2ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEj+0x68>)
 80a3a1e:	681a      	ldr	r2, [r3, #0]
 80a3a20:	07d2      	lsls	r2, r2, #31
 80a3a22:	bf5c      	itt	pl
 80a3a24:	2201      	movpl	r2, #1
 80a3a26:	601a      	strpl	r2, [r3, #0]
 80a3a28:	4b14      	ldr	r3, [pc, #80]	; (80a3a7c <_GLOBAL__sub_I__ZNSt12ctype_bynameIcEC2ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEj+0x6c>)
 80a3a2a:	681a      	ldr	r2, [r3, #0]
 80a3a2c:	07d0      	lsls	r0, r2, #31
 80a3a2e:	bf5c      	itt	pl
 80a3a30:	2201      	movpl	r2, #1
 80a3a32:	601a      	strpl	r2, [r3, #0]
 80a3a34:	4b12      	ldr	r3, [pc, #72]	; (80a3a80 <_GLOBAL__sub_I__ZNSt12ctype_bynameIcEC2ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEj+0x70>)
 80a3a36:	681a      	ldr	r2, [r3, #0]
 80a3a38:	07d1      	lsls	r1, r2, #31
 80a3a3a:	bf5c      	itt	pl
 80a3a3c:	2201      	movpl	r2, #1
 80a3a3e:	601a      	strpl	r2, [r3, #0]
 80a3a40:	4b10      	ldr	r3, [pc, #64]	; (80a3a84 <_GLOBAL__sub_I__ZNSt12ctype_bynameIcEC2ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEj+0x74>)
 80a3a42:	681a      	ldr	r2, [r3, #0]
 80a3a44:	07d2      	lsls	r2, r2, #31
 80a3a46:	bf5c      	itt	pl
 80a3a48:	2201      	movpl	r2, #1
 80a3a4a:	601a      	strpl	r2, [r3, #0]
 80a3a4c:	4b0e      	ldr	r3, [pc, #56]	; (80a3a88 <_GLOBAL__sub_I__ZNSt12ctype_bynameIcEC2ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEj+0x78>)
 80a3a4e:	681a      	ldr	r2, [r3, #0]
 80a3a50:	07d0      	lsls	r0, r2, #31
 80a3a52:	bf5c      	itt	pl
 80a3a54:	2201      	movpl	r2, #1
 80a3a56:	601a      	strpl	r2, [r3, #0]
 80a3a58:	4b0c      	ldr	r3, [pc, #48]	; (80a3a8c <_GLOBAL__sub_I__ZNSt12ctype_bynameIcEC2ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEj+0x7c>)
 80a3a5a:	681a      	ldr	r2, [r3, #0]
 80a3a5c:	07d1      	lsls	r1, r2, #31
 80a3a5e:	bf5c      	itt	pl
 80a3a60:	2201      	movpl	r2, #1
 80a3a62:	601a      	strpl	r2, [r3, #0]
 80a3a64:	4b0a      	ldr	r3, [pc, #40]	; (80a3a90 <_GLOBAL__sub_I__ZNSt12ctype_bynameIcEC2ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEj+0x80>)
 80a3a66:	681a      	ldr	r2, [r3, #0]
 80a3a68:	07d2      	lsls	r2, r2, #31
 80a3a6a:	bf5c      	itt	pl
 80a3a6c:	2201      	movpl	r2, #1
 80a3a6e:	601a      	strpl	r2, [r3, #0]
 80a3a70:	4770      	bx	lr
 80a3a72:	bf00      	nop
 80a3a74:	20000640 	.word	0x20000640
 80a3a78:	2000063c 	.word	0x2000063c
 80a3a7c:	20000638 	.word	0x20000638
 80a3a80:	20000634 	.word	0x20000634
 80a3a84:	20000630 	.word	0x20000630
 80a3a88:	2000062c 	.word	0x2000062c
 80a3a8c:	20000628 	.word	0x20000628
 80a3a90:	20000624 	.word	0x20000624

080a3a94 <_GLOBAL__sub_I__ZNSt12ctype_bynameIwEC2ERKSsj>:
 80a3a94:	4b24      	ldr	r3, [pc, #144]	; (80a3b28 <_GLOBAL__sub_I__ZNSt12ctype_bynameIwEC2ERKSsj+0x94>)
 80a3a96:	681a      	ldr	r2, [r3, #0]
 80a3a98:	07d0      	lsls	r0, r2, #31
 80a3a9a:	bf5c      	itt	pl
 80a3a9c:	2201      	movpl	r2, #1
 80a3a9e:	601a      	strpl	r2, [r3, #0]
 80a3aa0:	4b22      	ldr	r3, [pc, #136]	; (80a3b2c <_GLOBAL__sub_I__ZNSt12ctype_bynameIwEC2ERKSsj+0x98>)
 80a3aa2:	681a      	ldr	r2, [r3, #0]
 80a3aa4:	07d1      	lsls	r1, r2, #31
 80a3aa6:	bf5c      	itt	pl
 80a3aa8:	2201      	movpl	r2, #1
 80a3aaa:	601a      	strpl	r2, [r3, #0]
 80a3aac:	4b20      	ldr	r3, [pc, #128]	; (80a3b30 <_GLOBAL__sub_I__ZNSt12ctype_bynameIwEC2ERKSsj+0x9c>)
 80a3aae:	681a      	ldr	r2, [r3, #0]
 80a3ab0:	07d2      	lsls	r2, r2, #31
 80a3ab2:	bf5c      	itt	pl
 80a3ab4:	2201      	movpl	r2, #1
 80a3ab6:	601a      	strpl	r2, [r3, #0]
 80a3ab8:	4b1e      	ldr	r3, [pc, #120]	; (80a3b34 <_GLOBAL__sub_I__ZNSt12ctype_bynameIwEC2ERKSsj+0xa0>)
 80a3aba:	681a      	ldr	r2, [r3, #0]
 80a3abc:	07d0      	lsls	r0, r2, #31
 80a3abe:	bf5c      	itt	pl
 80a3ac0:	2201      	movpl	r2, #1
 80a3ac2:	601a      	strpl	r2, [r3, #0]
 80a3ac4:	4b1c      	ldr	r3, [pc, #112]	; (80a3b38 <_GLOBAL__sub_I__ZNSt12ctype_bynameIwEC2ERKSsj+0xa4>)
 80a3ac6:	681a      	ldr	r2, [r3, #0]
 80a3ac8:	07d1      	lsls	r1, r2, #31
 80a3aca:	bf5c      	itt	pl
 80a3acc:	2201      	movpl	r2, #1
 80a3ace:	601a      	strpl	r2, [r3, #0]
 80a3ad0:	4b1a      	ldr	r3, [pc, #104]	; (80a3b3c <_GLOBAL__sub_I__ZNSt12ctype_bynameIwEC2ERKSsj+0xa8>)
 80a3ad2:	681a      	ldr	r2, [r3, #0]
 80a3ad4:	07d2      	lsls	r2, r2, #31
 80a3ad6:	bf5c      	itt	pl
 80a3ad8:	2201      	movpl	r2, #1
 80a3ada:	601a      	strpl	r2, [r3, #0]
 80a3adc:	4b18      	ldr	r3, [pc, #96]	; (80a3b40 <_GLOBAL__sub_I__ZNSt12ctype_bynameIwEC2ERKSsj+0xac>)
 80a3ade:	681a      	ldr	r2, [r3, #0]
 80a3ae0:	07d0      	lsls	r0, r2, #31
 80a3ae2:	bf5c      	itt	pl
 80a3ae4:	2201      	movpl	r2, #1
 80a3ae6:	601a      	strpl	r2, [r3, #0]
 80a3ae8:	4b16      	ldr	r3, [pc, #88]	; (80a3b44 <_GLOBAL__sub_I__ZNSt12ctype_bynameIwEC2ERKSsj+0xb0>)
 80a3aea:	681a      	ldr	r2, [r3, #0]
 80a3aec:	07d1      	lsls	r1, r2, #31
 80a3aee:	bf5c      	itt	pl
 80a3af0:	2201      	movpl	r2, #1
 80a3af2:	601a      	strpl	r2, [r3, #0]
 80a3af4:	4b14      	ldr	r3, [pc, #80]	; (80a3b48 <_GLOBAL__sub_I__ZNSt12ctype_bynameIwEC2ERKSsj+0xb4>)
 80a3af6:	681a      	ldr	r2, [r3, #0]
 80a3af8:	07d2      	lsls	r2, r2, #31
 80a3afa:	bf5c      	itt	pl
 80a3afc:	2201      	movpl	r2, #1
 80a3afe:	601a      	strpl	r2, [r3, #0]
 80a3b00:	4b12      	ldr	r3, [pc, #72]	; (80a3b4c <_GLOBAL__sub_I__ZNSt12ctype_bynameIwEC2ERKSsj+0xb8>)
 80a3b02:	681a      	ldr	r2, [r3, #0]
 80a3b04:	07d0      	lsls	r0, r2, #31
 80a3b06:	bf5c      	itt	pl
 80a3b08:	2201      	movpl	r2, #1
 80a3b0a:	601a      	strpl	r2, [r3, #0]
 80a3b0c:	4b10      	ldr	r3, [pc, #64]	; (80a3b50 <_GLOBAL__sub_I__ZNSt12ctype_bynameIwEC2ERKSsj+0xbc>)
 80a3b0e:	681a      	ldr	r2, [r3, #0]
 80a3b10:	07d1      	lsls	r1, r2, #31
 80a3b12:	bf5c      	itt	pl
 80a3b14:	2201      	movpl	r2, #1
 80a3b16:	601a      	strpl	r2, [r3, #0]
 80a3b18:	4b0e      	ldr	r3, [pc, #56]	; (80a3b54 <_GLOBAL__sub_I__ZNSt12ctype_bynameIwEC2ERKSsj+0xc0>)
 80a3b1a:	681a      	ldr	r2, [r3, #0]
 80a3b1c:	07d2      	lsls	r2, r2, #31
 80a3b1e:	bf5c      	itt	pl
 80a3b20:	2201      	movpl	r2, #1
 80a3b22:	601a      	strpl	r2, [r3, #0]
 80a3b24:	4770      	bx	lr
 80a3b26:	bf00      	nop
 80a3b28:	20000670 	.word	0x20000670
 80a3b2c:	2000066c 	.word	0x2000066c
 80a3b30:	20000668 	.word	0x20000668
 80a3b34:	20000664 	.word	0x20000664
 80a3b38:	20000660 	.word	0x20000660
 80a3b3c:	2000065c 	.word	0x2000065c
 80a3b40:	20000658 	.word	0x20000658
 80a3b44:	20000654 	.word	0x20000654
 80a3b48:	20000650 	.word	0x20000650
 80a3b4c:	2000064c 	.word	0x2000064c
 80a3b50:	20000648 	.word	0x20000648
 80a3b54:	20000644 	.word	0x20000644

080a3b58 <_GLOBAL__sub_I__ZNSt12ctype_bynameIcEC2ERKSsj>:
 80a3b58:	4b24      	ldr	r3, [pc, #144]	; (80a3bec <_GLOBAL__sub_I__ZNSt12ctype_bynameIcEC2ERKSsj+0x94>)
 80a3b5a:	681a      	ldr	r2, [r3, #0]
 80a3b5c:	07d0      	lsls	r0, r2, #31
 80a3b5e:	bf5c      	itt	pl
 80a3b60:	2201      	movpl	r2, #1
 80a3b62:	601a      	strpl	r2, [r3, #0]
 80a3b64:	4b22      	ldr	r3, [pc, #136]	; (80a3bf0 <_GLOBAL__sub_I__ZNSt12ctype_bynameIcEC2ERKSsj+0x98>)
 80a3b66:	681a      	ldr	r2, [r3, #0]
 80a3b68:	07d1      	lsls	r1, r2, #31
 80a3b6a:	bf5c      	itt	pl
 80a3b6c:	2201      	movpl	r2, #1
 80a3b6e:	601a      	strpl	r2, [r3, #0]
 80a3b70:	4b20      	ldr	r3, [pc, #128]	; (80a3bf4 <_GLOBAL__sub_I__ZNSt12ctype_bynameIcEC2ERKSsj+0x9c>)
 80a3b72:	681a      	ldr	r2, [r3, #0]
 80a3b74:	07d2      	lsls	r2, r2, #31
 80a3b76:	bf5c      	itt	pl
 80a3b78:	2201      	movpl	r2, #1
 80a3b7a:	601a      	strpl	r2, [r3, #0]
 80a3b7c:	4b1e      	ldr	r3, [pc, #120]	; (80a3bf8 <_GLOBAL__sub_I__ZNSt12ctype_bynameIcEC2ERKSsj+0xa0>)
 80a3b7e:	681a      	ldr	r2, [r3, #0]
 80a3b80:	07d0      	lsls	r0, r2, #31
 80a3b82:	bf5c      	itt	pl
 80a3b84:	2201      	movpl	r2, #1
 80a3b86:	601a      	strpl	r2, [r3, #0]
 80a3b88:	4b1c      	ldr	r3, [pc, #112]	; (80a3bfc <_GLOBAL__sub_I__ZNSt12ctype_bynameIcEC2ERKSsj+0xa4>)
 80a3b8a:	681a      	ldr	r2, [r3, #0]
 80a3b8c:	07d1      	lsls	r1, r2, #31
 80a3b8e:	bf5c      	itt	pl
 80a3b90:	2201      	movpl	r2, #1
 80a3b92:	601a      	strpl	r2, [r3, #0]
 80a3b94:	4b1a      	ldr	r3, [pc, #104]	; (80a3c00 <_GLOBAL__sub_I__ZNSt12ctype_bynameIcEC2ERKSsj+0xa8>)
 80a3b96:	681a      	ldr	r2, [r3, #0]
 80a3b98:	07d2      	lsls	r2, r2, #31
 80a3b9a:	bf5c      	itt	pl
 80a3b9c:	2201      	movpl	r2, #1
 80a3b9e:	601a      	strpl	r2, [r3, #0]
 80a3ba0:	4b18      	ldr	r3, [pc, #96]	; (80a3c04 <_GLOBAL__sub_I__ZNSt12ctype_bynameIcEC2ERKSsj+0xac>)
 80a3ba2:	681a      	ldr	r2, [r3, #0]
 80a3ba4:	07d0      	lsls	r0, r2, #31
 80a3ba6:	bf5c      	itt	pl
 80a3ba8:	2201      	movpl	r2, #1
 80a3baa:	601a      	strpl	r2, [r3, #0]
 80a3bac:	4b16      	ldr	r3, [pc, #88]	; (80a3c08 <_GLOBAL__sub_I__ZNSt12ctype_bynameIcEC2ERKSsj+0xb0>)
 80a3bae:	681a      	ldr	r2, [r3, #0]
 80a3bb0:	07d1      	lsls	r1, r2, #31
 80a3bb2:	bf5c      	itt	pl
 80a3bb4:	2201      	movpl	r2, #1
 80a3bb6:	601a      	strpl	r2, [r3, #0]
 80a3bb8:	4b14      	ldr	r3, [pc, #80]	; (80a3c0c <_GLOBAL__sub_I__ZNSt12ctype_bynameIcEC2ERKSsj+0xb4>)
 80a3bba:	681a      	ldr	r2, [r3, #0]
 80a3bbc:	07d2      	lsls	r2, r2, #31
 80a3bbe:	bf5c      	itt	pl
 80a3bc0:	2201      	movpl	r2, #1
 80a3bc2:	601a      	strpl	r2, [r3, #0]
 80a3bc4:	4b12      	ldr	r3, [pc, #72]	; (80a3c10 <_GLOBAL__sub_I__ZNSt12ctype_bynameIcEC2ERKSsj+0xb8>)
 80a3bc6:	681a      	ldr	r2, [r3, #0]
 80a3bc8:	07d0      	lsls	r0, r2, #31
 80a3bca:	bf5c      	itt	pl
 80a3bcc:	2201      	movpl	r2, #1
 80a3bce:	601a      	strpl	r2, [r3, #0]
 80a3bd0:	4b10      	ldr	r3, [pc, #64]	; (80a3c14 <_GLOBAL__sub_I__ZNSt12ctype_bynameIcEC2ERKSsj+0xbc>)
 80a3bd2:	681a      	ldr	r2, [r3, #0]
 80a3bd4:	07d1      	lsls	r1, r2, #31
 80a3bd6:	bf5c      	itt	pl
 80a3bd8:	2201      	movpl	r2, #1
 80a3bda:	601a      	strpl	r2, [r3, #0]
 80a3bdc:	4b0e      	ldr	r3, [pc, #56]	; (80a3c18 <_GLOBAL__sub_I__ZNSt12ctype_bynameIcEC2ERKSsj+0xc0>)
 80a3bde:	681a      	ldr	r2, [r3, #0]
 80a3be0:	07d2      	lsls	r2, r2, #31
 80a3be2:	bf5c      	itt	pl
 80a3be4:	2201      	movpl	r2, #1
 80a3be6:	601a      	strpl	r2, [r3, #0]
 80a3be8:	4770      	bx	lr
 80a3bea:	bf00      	nop
 80a3bec:	200006a0 	.word	0x200006a0
 80a3bf0:	2000069c 	.word	0x2000069c
 80a3bf4:	20000698 	.word	0x20000698
 80a3bf8:	20000694 	.word	0x20000694
 80a3bfc:	20000690 	.word	0x20000690
 80a3c00:	2000068c 	.word	0x2000068c
 80a3c04:	20000688 	.word	0x20000688
 80a3c08:	20000684 	.word	0x20000684
 80a3c0c:	20000680 	.word	0x20000680
 80a3c10:	2000067c 	.word	0x2000067c
 80a3c14:	20000678 	.word	0x20000678
 80a3c18:	20000674 	.word	0x20000674

080a3c1c <_GLOBAL__sub_I__ZNSt12ctype_bynameIwEC2ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEj>:
 80a3c1c:	4b18      	ldr	r3, [pc, #96]	; (80a3c80 <_GLOBAL__sub_I__ZNSt12ctype_bynameIwEC2ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEj+0x64>)
 80a3c1e:	681a      	ldr	r2, [r3, #0]
 80a3c20:	07d1      	lsls	r1, r2, #31
 80a3c22:	bf5c      	itt	pl
 80a3c24:	2201      	movpl	r2, #1
 80a3c26:	601a      	strpl	r2, [r3, #0]
 80a3c28:	4b16      	ldr	r3, [pc, #88]	; (80a3c84 <_GLOBAL__sub_I__ZNSt12ctype_bynameIwEC2ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEj+0x68>)
 80a3c2a:	681a      	ldr	r2, [r3, #0]
 80a3c2c:	07d2      	lsls	r2, r2, #31
 80a3c2e:	bf5c      	itt	pl
 80a3c30:	2201      	movpl	r2, #1
 80a3c32:	601a      	strpl	r2, [r3, #0]
 80a3c34:	4b14      	ldr	r3, [pc, #80]	; (80a3c88 <_GLOBAL__sub_I__ZNSt12ctype_bynameIwEC2ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEj+0x6c>)
 80a3c36:	681a      	ldr	r2, [r3, #0]
 80a3c38:	07d0      	lsls	r0, r2, #31
 80a3c3a:	bf5c      	itt	pl
 80a3c3c:	2201      	movpl	r2, #1
 80a3c3e:	601a      	strpl	r2, [r3, #0]
 80a3c40:	4b12      	ldr	r3, [pc, #72]	; (80a3c8c <_GLOBAL__sub_I__ZNSt12ctype_bynameIwEC2ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEj+0x70>)
 80a3c42:	681a      	ldr	r2, [r3, #0]
 80a3c44:	07d1      	lsls	r1, r2, #31
 80a3c46:	bf5c      	itt	pl
 80a3c48:	2201      	movpl	r2, #1
 80a3c4a:	601a      	strpl	r2, [r3, #0]
 80a3c4c:	4b10      	ldr	r3, [pc, #64]	; (80a3c90 <_GLOBAL__sub_I__ZNSt12ctype_bynameIwEC2ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEj+0x74>)
 80a3c4e:	681a      	ldr	r2, [r3, #0]
 80a3c50:	07d2      	lsls	r2, r2, #31
 80a3c52:	bf5c      	itt	pl
 80a3c54:	2201      	movpl	r2, #1
 80a3c56:	601a      	strpl	r2, [r3, #0]
 80a3c58:	4b0e      	ldr	r3, [pc, #56]	; (80a3c94 <_GLOBAL__sub_I__ZNSt12ctype_bynameIwEC2ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEj+0x78>)
 80a3c5a:	681a      	ldr	r2, [r3, #0]
 80a3c5c:	07d0      	lsls	r0, r2, #31
 80a3c5e:	bf5c      	itt	pl
 80a3c60:	2201      	movpl	r2, #1
 80a3c62:	601a      	strpl	r2, [r3, #0]
 80a3c64:	4b0c      	ldr	r3, [pc, #48]	; (80a3c98 <_GLOBAL__sub_I__ZNSt12ctype_bynameIwEC2ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEj+0x7c>)
 80a3c66:	681a      	ldr	r2, [r3, #0]
 80a3c68:	07d1      	lsls	r1, r2, #31
 80a3c6a:	bf5c      	itt	pl
 80a3c6c:	2201      	movpl	r2, #1
 80a3c6e:	601a      	strpl	r2, [r3, #0]
 80a3c70:	4b0a      	ldr	r3, [pc, #40]	; (80a3c9c <_GLOBAL__sub_I__ZNSt12ctype_bynameIwEC2ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEj+0x80>)
 80a3c72:	681a      	ldr	r2, [r3, #0]
 80a3c74:	07d2      	lsls	r2, r2, #31
 80a3c76:	bf5c      	itt	pl
 80a3c78:	2201      	movpl	r2, #1
 80a3c7a:	601a      	strpl	r2, [r3, #0]
 80a3c7c:	4770      	bx	lr
 80a3c7e:	bf00      	nop
 80a3c80:	200006c0 	.word	0x200006c0
 80a3c84:	200006bc 	.word	0x200006bc
 80a3c88:	200006b8 	.word	0x200006b8
 80a3c8c:	200006b4 	.word	0x200006b4
 80a3c90:	200006b0 	.word	0x200006b0
 80a3c94:	200006ac 	.word	0x200006ac
 80a3c98:	200006a8 	.word	0x200006a8
 80a3c9c:	200006a4 	.word	0x200006a4

080a3ca0 <__cxa_atexit>:
 80a3ca0:	b510      	push	{r4, lr}
 80a3ca2:	4c05      	ldr	r4, [pc, #20]	; (80a3cb8 <__cxa_atexit+0x18>)
 80a3ca4:	4613      	mov	r3, r2
 80a3ca6:	b12c      	cbz	r4, 80a3cb4 <__cxa_atexit+0x14>
 80a3ca8:	460a      	mov	r2, r1
 80a3caa:	4601      	mov	r1, r0
 80a3cac:	2002      	movs	r0, #2
 80a3cae:	f3af 8000 	nop.w
 80a3cb2:	bd10      	pop	{r4, pc}
 80a3cb4:	4620      	mov	r0, r4
 80a3cb6:	bd10      	pop	{r4, pc}
 80a3cb8:	00000000 	.word	0x00000000

080a3cbc <memcpy>:
 80a3cbc:	b510      	push	{r4, lr}
 80a3cbe:	1e43      	subs	r3, r0, #1
 80a3cc0:	440a      	add	r2, r1
 80a3cc2:	4291      	cmp	r1, r2
 80a3cc4:	d004      	beq.n	80a3cd0 <memcpy+0x14>
 80a3cc6:	f811 4b01 	ldrb.w	r4, [r1], #1
 80a3cca:	f803 4f01 	strb.w	r4, [r3, #1]!
 80a3cce:	e7f8      	b.n	80a3cc2 <memcpy+0x6>
 80a3cd0:	bd10      	pop	{r4, pc}

080a3cd2 <memmove>:
 80a3cd2:	4288      	cmp	r0, r1
 80a3cd4:	b510      	push	{r4, lr}
 80a3cd6:	eb01 0302 	add.w	r3, r1, r2
 80a3cda:	d801      	bhi.n	80a3ce0 <memmove+0xe>
 80a3cdc:	1e42      	subs	r2, r0, #1
 80a3cde:	e00b      	b.n	80a3cf8 <memmove+0x26>
 80a3ce0:	4298      	cmp	r0, r3
 80a3ce2:	d2fb      	bcs.n	80a3cdc <memmove+0xa>
 80a3ce4:	1881      	adds	r1, r0, r2
 80a3ce6:	1ad2      	subs	r2, r2, r3
 80a3ce8:	42d3      	cmn	r3, r2
 80a3cea:	d004      	beq.n	80a3cf6 <memmove+0x24>
 80a3cec:	f813 4d01 	ldrb.w	r4, [r3, #-1]!
 80a3cf0:	f801 4d01 	strb.w	r4, [r1, #-1]!
 80a3cf4:	e7f8      	b.n	80a3ce8 <memmove+0x16>
 80a3cf6:	bd10      	pop	{r4, pc}
 80a3cf8:	4299      	cmp	r1, r3
 80a3cfa:	d004      	beq.n	80a3d06 <memmove+0x34>
 80a3cfc:	f811 4b01 	ldrb.w	r4, [r1], #1
 80a3d00:	f802 4f01 	strb.w	r4, [r2, #1]!
 80a3d04:	e7f8      	b.n	80a3cf8 <memmove+0x26>
 80a3d06:	bd10      	pop	{r4, pc}

080a3d08 <memset>:
 80a3d08:	4603      	mov	r3, r0
 80a3d0a:	4402      	add	r2, r0
 80a3d0c:	4293      	cmp	r3, r2
 80a3d0e:	d002      	beq.n	80a3d16 <memset+0xe>
 80a3d10:	f803 1b01 	strb.w	r1, [r3], #1
 80a3d14:	e7fa      	b.n	80a3d0c <memset+0x4>
 80a3d16:	4770      	bx	lr

080a3d18 <srand>:
 80a3d18:	b538      	push	{r3, r4, r5, lr}
 80a3d1a:	4b12      	ldr	r3, [pc, #72]	; (80a3d64 <srand+0x4c>)
 80a3d1c:	4605      	mov	r5, r0
 80a3d1e:	681c      	ldr	r4, [r3, #0]
 80a3d20:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 80a3d22:	b9d3      	cbnz	r3, 80a3d5a <srand+0x42>
 80a3d24:	2018      	movs	r0, #24
 80a3d26:	f7fd fe0b 	bl	80a1940 <malloc>
 80a3d2a:	f243 330e 	movw	r3, #13070	; 0x330e
 80a3d2e:	63a0      	str	r0, [r4, #56]	; 0x38
 80a3d30:	8003      	strh	r3, [r0, #0]
 80a3d32:	f64a 33cd 	movw	r3, #43981	; 0xabcd
 80a3d36:	8043      	strh	r3, [r0, #2]
 80a3d38:	f241 2334 	movw	r3, #4660	; 0x1234
 80a3d3c:	8083      	strh	r3, [r0, #4]
 80a3d3e:	f24e 636d 	movw	r3, #58989	; 0xe66d
 80a3d42:	80c3      	strh	r3, [r0, #6]
 80a3d44:	f64d 63ec 	movw	r3, #57068	; 0xdeec
 80a3d48:	8103      	strh	r3, [r0, #8]
 80a3d4a:	2305      	movs	r3, #5
 80a3d4c:	8143      	strh	r3, [r0, #10]
 80a3d4e:	230b      	movs	r3, #11
 80a3d50:	8183      	strh	r3, [r0, #12]
 80a3d52:	2201      	movs	r2, #1
 80a3d54:	2300      	movs	r3, #0
 80a3d56:	e9c0 2304 	strd	r2, r3, [r0, #16]
 80a3d5a:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 80a3d5c:	2200      	movs	r2, #0
 80a3d5e:	611d      	str	r5, [r3, #16]
 80a3d60:	615a      	str	r2, [r3, #20]
 80a3d62:	bd38      	pop	{r3, r4, r5, pc}
 80a3d64:	20000070 	.word	0x20000070

080a3d68 <strchr>:
 80a3d68:	b2c9      	uxtb	r1, r1
 80a3d6a:	4603      	mov	r3, r0
 80a3d6c:	f810 2b01 	ldrb.w	r2, [r0], #1
 80a3d70:	b11a      	cbz	r2, 80a3d7a <strchr+0x12>
 80a3d72:	4291      	cmp	r1, r2
 80a3d74:	d1f9      	bne.n	80a3d6a <strchr+0x2>
 80a3d76:	4618      	mov	r0, r3
 80a3d78:	4770      	bx	lr
 80a3d7a:	2900      	cmp	r1, #0
 80a3d7c:	bf0c      	ite	eq
 80a3d7e:	4618      	moveq	r0, r3
 80a3d80:	2000      	movne	r0, #0
 80a3d82:	4770      	bx	lr

080a3d84 <strchrnul>:
 80a3d84:	b510      	push	{r4, lr}
 80a3d86:	4604      	mov	r4, r0
 80a3d88:	f7ff ffee 	bl	80a3d68 <strchr>
 80a3d8c:	b918      	cbnz	r0, 80a3d96 <strchrnul+0x12>
 80a3d8e:	4620      	mov	r0, r4
 80a3d90:	f000 f80c 	bl	80a3dac <strlen>
 80a3d94:	4420      	add	r0, r4
 80a3d96:	bd10      	pop	{r4, pc}

080a3d98 <strcmp>:
 80a3d98:	f810 2b01 	ldrb.w	r2, [r0], #1
 80a3d9c:	f811 3b01 	ldrb.w	r3, [r1], #1
 80a3da0:	2a01      	cmp	r2, #1
 80a3da2:	bf28      	it	cs
 80a3da4:	429a      	cmpcs	r2, r3
 80a3da6:	d0f7      	beq.n	80a3d98 <strcmp>
 80a3da8:	1ad0      	subs	r0, r2, r3
 80a3daa:	4770      	bx	lr

080a3dac <strlen>:
 80a3dac:	4603      	mov	r3, r0
 80a3dae:	f813 2b01 	ldrb.w	r2, [r3], #1
 80a3db2:	2a00      	cmp	r2, #0
 80a3db4:	d1fb      	bne.n	80a3dae <strlen+0x2>
 80a3db6:	1a18      	subs	r0, r3, r0
 80a3db8:	3801      	subs	r0, #1
 80a3dba:	4770      	bx	lr

080a3dbc <strncmp>:
 80a3dbc:	b530      	push	{r4, r5, lr}
 80a3dbe:	b182      	cbz	r2, 80a3de2 <strncmp+0x26>
 80a3dc0:	1e45      	subs	r5, r0, #1
 80a3dc2:	3901      	subs	r1, #1
 80a3dc4:	f815 3f01 	ldrb.w	r3, [r5, #1]!
 80a3dc8:	f811 4f01 	ldrb.w	r4, [r1, #1]!
 80a3dcc:	42a3      	cmp	r3, r4
 80a3dce:	d106      	bne.n	80a3dde <strncmp+0x22>
 80a3dd0:	43ec      	mvns	r4, r5
 80a3dd2:	4414      	add	r4, r2
 80a3dd4:	42e0      	cmn	r0, r4
 80a3dd6:	d001      	beq.n	80a3ddc <strncmp+0x20>
 80a3dd8:	2b00      	cmp	r3, #0
 80a3dda:	d1f3      	bne.n	80a3dc4 <strncmp+0x8>
 80a3ddc:	461c      	mov	r4, r3
 80a3dde:	1b18      	subs	r0, r3, r4
 80a3de0:	bd30      	pop	{r4, r5, pc}
 80a3de2:	4610      	mov	r0, r2
 80a3de4:	bd30      	pop	{r4, r5, pc}

080a3de6 <strrchr>:
 80a3de6:	b538      	push	{r3, r4, r5, lr}
 80a3de8:	4603      	mov	r3, r0
 80a3dea:	460d      	mov	r5, r1
 80a3dec:	b141      	cbz	r1, 80a3e00 <strrchr+0x1a>
 80a3dee:	2400      	movs	r4, #0
 80a3df0:	4629      	mov	r1, r5
 80a3df2:	4618      	mov	r0, r3
 80a3df4:	f7ff ffb8 	bl	80a3d68 <strchr>
 80a3df8:	b130      	cbz	r0, 80a3e08 <strrchr+0x22>
 80a3dfa:	1c43      	adds	r3, r0, #1
 80a3dfc:	4604      	mov	r4, r0
 80a3dfe:	e7f7      	b.n	80a3df0 <strrchr+0xa>
 80a3e00:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
 80a3e04:	f7ff bfb0 	b.w	80a3d68 <strchr>
 80a3e08:	4620      	mov	r0, r4
 80a3e0a:	bd38      	pop	{r3, r4, r5, pc}

080a3e0c <_strtol_r>:
 80a3e0c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 80a3e10:	460f      	mov	r7, r1
 80a3e12:	4680      	mov	r8, r0
 80a3e14:	483f      	ldr	r0, [pc, #252]	; (80a3f14 <_strtol_r+0x108>)
 80a3e16:	f8d0 9000 	ldr.w	r9, [r0]
 80a3e1a:	463d      	mov	r5, r7
 80a3e1c:	f815 4b01 	ldrb.w	r4, [r5], #1
 80a3e20:	eb09 0004 	add.w	r0, r9, r4
 80a3e24:	7840      	ldrb	r0, [r0, #1]
 80a3e26:	f000 0008 	and.w	r0, r0, #8
 80a3e2a:	f000 06ff 	and.w	r6, r0, #255	; 0xff
 80a3e2e:	b108      	cbz	r0, 80a3e34 <_strtol_r+0x28>
 80a3e30:	462f      	mov	r7, r5
 80a3e32:	e7f2      	b.n	80a3e1a <_strtol_r+0xe>
 80a3e34:	2c2d      	cmp	r4, #45	; 0x2d
 80a3e36:	d103      	bne.n	80a3e40 <_strtol_r+0x34>
 80a3e38:	1cbd      	adds	r5, r7, #2
 80a3e3a:	787c      	ldrb	r4, [r7, #1]
 80a3e3c:	2601      	movs	r6, #1
 80a3e3e:	e003      	b.n	80a3e48 <_strtol_r+0x3c>
 80a3e40:	2c2b      	cmp	r4, #43	; 0x2b
 80a3e42:	bf04      	itt	eq
 80a3e44:	787c      	ldrbeq	r4, [r7, #1]
 80a3e46:	1cbd      	addeq	r5, r7, #2
 80a3e48:	b113      	cbz	r3, 80a3e50 <_strtol_r+0x44>
 80a3e4a:	2b10      	cmp	r3, #16
 80a3e4c:	d10a      	bne.n	80a3e64 <_strtol_r+0x58>
 80a3e4e:	e05b      	b.n	80a3f08 <_strtol_r+0xfc>
 80a3e50:	2c30      	cmp	r4, #48	; 0x30
 80a3e52:	d157      	bne.n	80a3f04 <_strtol_r+0xf8>
 80a3e54:	7828      	ldrb	r0, [r5, #0]
 80a3e56:	f000 00df 	and.w	r0, r0, #223	; 0xdf
 80a3e5a:	2858      	cmp	r0, #88	; 0x58
 80a3e5c:	d14d      	bne.n	80a3efa <_strtol_r+0xee>
 80a3e5e:	786c      	ldrb	r4, [r5, #1]
 80a3e60:	2310      	movs	r3, #16
 80a3e62:	3502      	adds	r5, #2
 80a3e64:	2e00      	cmp	r6, #0
 80a3e66:	bf14      	ite	ne
 80a3e68:	f04f 4c00 	movne.w	ip, #2147483648	; 0x80000000
 80a3e6c:	f06f 4c00 	mvneq.w	ip, #2147483648	; 0x80000000
 80a3e70:	fbbc faf3 	udiv	sl, ip, r3
 80a3e74:	2700      	movs	r7, #0
 80a3e76:	4638      	mov	r0, r7
 80a3e78:	fb03 cc1a 	mls	ip, r3, sl, ip
 80a3e7c:	eb09 0e04 	add.w	lr, r9, r4
 80a3e80:	f89e e001 	ldrb.w	lr, [lr, #1]
 80a3e84:	f01e 0f04 	tst.w	lr, #4
 80a3e88:	d001      	beq.n	80a3e8e <_strtol_r+0x82>
 80a3e8a:	3c30      	subs	r4, #48	; 0x30
 80a3e8c:	e00b      	b.n	80a3ea6 <_strtol_r+0x9a>
 80a3e8e:	f01e 0e03 	ands.w	lr, lr, #3
 80a3e92:	d01b      	beq.n	80a3ecc <_strtol_r+0xc0>
 80a3e94:	f1be 0f01 	cmp.w	lr, #1
 80a3e98:	bf0c      	ite	eq
 80a3e9a:	f04f 0e37 	moveq.w	lr, #55	; 0x37
 80a3e9e:	f04f 0e57 	movne.w	lr, #87	; 0x57
 80a3ea2:	ebce 0404 	rsb	r4, lr, r4
 80a3ea6:	42a3      	cmp	r3, r4
 80a3ea8:	dd10      	ble.n	80a3ecc <_strtol_r+0xc0>
 80a3eaa:	f1b7 3fff 	cmp.w	r7, #4294967295
 80a3eae:	d00a      	beq.n	80a3ec6 <_strtol_r+0xba>
 80a3eb0:	4550      	cmp	r0, sl
 80a3eb2:	d806      	bhi.n	80a3ec2 <_strtol_r+0xb6>
 80a3eb4:	d101      	bne.n	80a3eba <_strtol_r+0xae>
 80a3eb6:	4564      	cmp	r4, ip
 80a3eb8:	dc03      	bgt.n	80a3ec2 <_strtol_r+0xb6>
 80a3eba:	fb03 4000 	mla	r0, r3, r0, r4
 80a3ebe:	2701      	movs	r7, #1
 80a3ec0:	e001      	b.n	80a3ec6 <_strtol_r+0xba>
 80a3ec2:	f04f 37ff 	mov.w	r7, #4294967295
 80a3ec6:	f815 4b01 	ldrb.w	r4, [r5], #1
 80a3eca:	e7d7      	b.n	80a3e7c <_strtol_r+0x70>
 80a3ecc:	1c7b      	adds	r3, r7, #1
 80a3ece:	d10c      	bne.n	80a3eea <_strtol_r+0xde>
 80a3ed0:	2e00      	cmp	r6, #0
 80a3ed2:	f04f 0322 	mov.w	r3, #34	; 0x22
 80a3ed6:	bf14      	ite	ne
 80a3ed8:	f04f 4000 	movne.w	r0, #2147483648	; 0x80000000
 80a3edc:	f06f 4000 	mvneq.w	r0, #2147483648	; 0x80000000
 80a3ee0:	f8c8 3000 	str.w	r3, [r8]
 80a3ee4:	b92a      	cbnz	r2, 80a3ef2 <_strtol_r+0xe6>
 80a3ee6:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 80a3eea:	b106      	cbz	r6, 80a3eee <_strtol_r+0xe2>
 80a3eec:	4240      	negs	r0, r0
 80a3eee:	b172      	cbz	r2, 80a3f0e <_strtol_r+0x102>
 80a3ef0:	b107      	cbz	r7, 80a3ef4 <_strtol_r+0xe8>
 80a3ef2:	1e69      	subs	r1, r5, #1
 80a3ef4:	6011      	str	r1, [r2, #0]
 80a3ef6:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 80a3efa:	2430      	movs	r4, #48	; 0x30
 80a3efc:	2b00      	cmp	r3, #0
 80a3efe:	d1b1      	bne.n	80a3e64 <_strtol_r+0x58>
 80a3f00:	2308      	movs	r3, #8
 80a3f02:	e7af      	b.n	80a3e64 <_strtol_r+0x58>
 80a3f04:	230a      	movs	r3, #10
 80a3f06:	e7ad      	b.n	80a3e64 <_strtol_r+0x58>
 80a3f08:	2c30      	cmp	r4, #48	; 0x30
 80a3f0a:	d0a3      	beq.n	80a3e54 <_strtol_r+0x48>
 80a3f0c:	e7aa      	b.n	80a3e64 <_strtol_r+0x58>
 80a3f0e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 80a3f12:	bf00      	nop
 80a3f14:	2000000c 	.word	0x2000000c

080a3f18 <strtol>:
 80a3f18:	4613      	mov	r3, r2
 80a3f1a:	460a      	mov	r2, r1
 80a3f1c:	4601      	mov	r1, r0
 80a3f1e:	4802      	ldr	r0, [pc, #8]	; (80a3f28 <strtol+0x10>)
 80a3f20:	6800      	ldr	r0, [r0, #0]
 80a3f22:	f7ff bf73 	b.w	80a3e0c <_strtol_r>
 80a3f26:	bf00      	nop
 80a3f28:	20000070 	.word	0x20000070

080a3f2c <dynalib_user>:
 80a3f2c:	080a001d 080a005d 080a0089 080a008d     ....]...........
 80a3f3c:	00000000                                ....

080a3f40 <_ZTVN5spark10LogHandlerE>:
	...
 80a3f50:	080a00a1 080a00c5                       ........

080a3f58 <_ZTVN5spark16SerialLogHandlerE>:
	...
 80a3f60:	080a00d1 080a0105 080a3041 080a00c7     ........A0......
 80a3f70:	31445353 20363033 6f6c6c61 69746163     SSD1306 allocati
 80a3f80:	66206e6f 656c6961 00000064              on failed...

080a3f8c <_ZTVN8particle13__SPISettingsE>:
	...
 80a3f94:	080a034d                                M...

080a3f98 <_ZZN16Adafruit_SSD130621drawFastVLineInternalEssstE8postmask>:
 80a3f98:	07030100 7f3f1f0f 61666564 20746c75     ......?.default 
 80a3fa8:	42534d00 42534c00 50533c00 74655349     .MSB.LSB.<SPISet
 80a3fb8:	676e6974 65642073 6c756166 3c003e74     tings default>.<
 80a3fc8:	53495053 69747465 2073676e 6c257325     SPISettings %s%l
 80a3fd8:	73252075 444f4d20 3e642545 80d5ae00              u %s MODE%d>.

080a3fe5 <_ZZN16Adafruit_SSD13065beginEhhbbE5init1>:
 80a3fe5:	a880d5ae                                ....

080a3fe9 <_ZZN16Adafruit_SSD13065beginEhhbbE5init2>:
 80a3fe9:	8d4000d3                                ..@.

080a3fed <_ZZN16Adafruit_SSD13065beginEhhbbE5init3>:
 80a3fed:	c8a10020                                 ...

080a3ff1 <_ZZN16Adafruit_SSD13065beginEhhbbE5init5>:
 80a3ff1:	a6a440db 8000af2e                                .@....

080a3ff7 <_ZZN16Adafruit_SSD130621drawFastVLineInternalEssstE7premask>:
 80a3ff7:	e0c08000 fefcf8f0                       ........

080a3fff <_ZZN16Adafruit_SSD13067displayEvE6dlist1>:
 80a3fff:	21ff0022 00000000                                "..!.

080a4004 <_ZTV16Adafruit_SSD1306>:
	...
 80a400c:	080a03b5 080a03cd 080a1409 080a336d     ............m3..
 80a401c:	080a03e1 080a0e61 080a0e19 080a0e49     ....a.......I...
 80a402c:	080a0e25 080a0e37 080a0d59 080a0e61     %...7...Y...a...
 80a403c:	080a103f 080a0585 080a0bcb 080a0b7d     ?...........}...
 80a404c:	080a0edb 080a0f21 080a0f3d 080a0fbd     ....!...=.......

080a405c <_ZL12splash1_data>:
 80a405c:	00000000 00800100 00000000 00000000     ................
 80a406c:	00008003 00000000 07000000 000000c0     ................
 80a407c:	00000000 c0070000 00000000 00000000     ................
 80a408c:	00c00f00 00000000 00000000 0000e01f     ................
 80a409c:	00000000 1f000000 000000e0 00000000     ................
 80a40ac:	e03f0000 00000000 00000000 00f03f00     ..?..........?..
	...
 80a40c4:	0000f07f 00000000 7ff81f00 000000f0     ................
 80a40d4:	00000000 f07ffe3f 00000000 3f000000     ....?..........?
 80a40e4:	00f07fff 00000000 ff1f0000 0000e0fb     ................
 80a40f4:	00000000 f9ff0f00 0000c0ff 00000000     ................
 80a4104:	fff9ff0f 000000f8 07000000 fffff1ff     ................
 80a4114:	00000000 fc030000 80ffff73 00000000     ........s.......
 80a4124:	3ffe0100 0080ffff 00000000 0f1eff00     ...?............
 80a4134:	000000ff 00000000 fc1ffe7f 00000000     ................
 80a4144:	3f000000 00f8ffff 00000000 df0f0000     ...?............
 80a4154:	0000e0ff 00000000 ff191f00 000000c0     ................
 80a4164:	00000000 00ff3c3f 00000000 7e000000     ....?<.........~
 80a4174:	0000f87c 00000000 fe7f0000 0000007c     |...........|...
 80a4184:	00000000 fcffff00 00000000 00000000     ................
 80a4194:	00feffff 00000000 ff000000 0000feff     ................
 80a41a4:	00000000 efff0100 000000fe 00000000     ................
 80a41b4:	fecfff01 00000000 03000000 00fe07ff     ................
 80a41c4:	00000000 fc030000 0000fe07 00000000     ................
 80a41d4:	03f00300 000000fe 00000000 fe008001     ................
	...
 80a41ec:	007e0000 00000000 00000000 00003e00     ..~..........>..
	...
 80a4204:	0000000c 07000000 00fc0080 00c00300     ................
 80a4214:	80070000 0000fc01 0000c003 01800700     ................
 80a4224:	030000fc 000000c0 e0018007 1e000000     ................
 80a4234:	07000000 00e00180 001e0000 9ff7e37f     ................
 80a4244:	78e7fdf9 ffc0df7b fdbffff7 7b78fffd     ...x{.........x{
 80a4254:	f7ffc0df fdfdbfff df7b78ff 87f7f0c0     .........x{.....
 80a4264:	ffe13dbc 00de7b78 bc87f7f0 78f0e13d     .=..x{......=..x
 80a4274:	0000de7b 3d8087f7 7b78e0e1 f77f00de     {......=..x{....
 80a4284:	e1fd9f87 de7b78e0 87f7ff00 e0e1fdbf     .....x{.........
 80a4294:	00de7b78 bc87f7f0 78e0e13d f000de7b     x{......=..x{...
 80a42a4:	3dbc87f7 7b78e0e1 f7f000de e13dbc87     ...=..x{......=.
 80a42b4:	de7b78e0 fff7ff00 e0e1fdbf c0dffb7f     .x{.............
 80a42c4:	bffff7ff 7fe0e1fd 7cc0dffb 3d9ff3f3     ...........|...=
 80a42d4:	7b3ee0e1 0000c0cf 00000000 00000000     ..>{............
 80a42e4:	ffffff00 ffffffff c0ffffff ffffffff     ................
 80a42f4:	11db68fd ffc0311a fdffffff 6afb5a2b     .h...1......+Z.j
 80a4304:	ffffc0ef 4bfdffff 331a3b5b ffffffc0     .......K[;.3....
 80a4314:	5b6bfdff c0fd6adb                       ..k[.j..

080a431c <_ZL12splash2_data>:
 80a431c:	00600000 00000000 00000000 00000000     ..`.............
 80a432c:	0000e000 00000000 00000000 01000000     ................
 80a433c:	000000e0 00000000 00000000 f0010000     ................
	...
 80a4358:	00f00300 00000000 00000000 00000000     ................
 80a4368:	0000f007 00000000 00000000 07000000     ................
 80a4378:	000000f8 00000000 00000000 f80f0000     ................
 80a4388:	03000000 007e00c0 00e00100 00f80f7f     ......~.........
 80a4398:	c0030000 0000fe00 ff00e001 0000f8ef     ................
 80a43a8:	00c00300 010000fe ffff00e0 000000f8     ................
 80a43b8:	f000c003 0f000000 7ffe7f00 030000c0     ................
 80a43c8:	00f000c0 000f0000 f87ffe3f cffbf13f     ........?...?...
 80a43d8:	bcf3fefc 1fe0ef3d 7fff7ffe fedffffb     ....=...........
 80a43e8:	3dbcfffe c61fe0ef fb7fffff fefedfff     ...=............
 80a43f8:	ef3dbcff c7e30fe0 c37b78fe fff01ede     ..=......x{.....
 80a4408:	00ef3dbc fc87ff07 dec37b78 3cf8f01e     .=......x{.....<
 80a4418:	0100ef3d 00f0ffff 1ec0c37b 3d3cf0f0     =.......{.....<=
 80a4428:	f30100ef fb3fe07f f0fecfc3 ef3d3cf0     ......?......<=.
 80a4438:	3fe30300 c3fb7f80 f0f0fedf 00ef3d3c     ...?........<=..
 80a4448:	003ce707 dec37b78 3cf0f01e 0700ef3d     ..<.x{.....<=...
 80a4458:	7800beff 1edec37b 3d3cf0f0 ff0700ef     ...x{.....<=....
 80a4468:	7b7800fe f01edec3 ef3d3cf0 feff0f00     ..x{.....<=.....
 80a4478:	fffb7f00 f0f0fedf e0effd3f 00ffff0f     ........?.......
 80a4488:	dffffb7f 3ff0f0fe 0fe0effd 3e00fff9     .......?.......>
 80a4498:	9ecff979 3d1ff0f0 f11fe0e7 000000ff     y......=........
	...
 80a44b0:	ff801f00 ffff7f00 ffffffff e0ffffff     ................
 80a44c0:	007f001c ffffff7f 886db4fe 00e0188d     ..........m.....
 80a44d0:	7f001f00 feffffff b57dad95 0000e077     ..........}.w...
 80a44e0:	ff7f000f a5feffff 198d9dad 060000e0     ................
 80a44f0:	ffff7f00 adb5feff e07eb5ed              ..........~.

080a44fc <_ZTV12Adafruit_GFX>:
	...
 80a450c:	080a1409 080a336d 080a00a1 080a0e61     ....m3......a...
 80a451c:	080a0e19 080a0e49 080a0e25 080a0e37     ....I...%...7...
 80a452c:	080a0d59 080a0e61 080a103f 080a103d     Y...a...?...=...
 80a453c:	080a0e63 080a0ea1 080a0edb 080a0f21     c...........!...
 80a454c:	080a0f3d 080a0fbd                       =.......

080a4554 <_ZL4font>:
 80a4554:	00000000 4f5b3e00 6b3e3e5b 1c3e6b4f     .....>[O[>>kOk>.
 80a4564:	1c3e7c3e 3c7e3c18 7d571c18 5e1c1c57     >|>..<~<..W}W..^
 80a4574:	001c5e7f 00183c18 e7c3e7ff 241800ff     .^...<.........$
 80a4584:	e7ff0018 30ffe7db 0e063a48 29792926     .......0H:..&)y)
 80a4594:	057f4026 7f400705 5a3f2505 5a3ce73c     &@....@..%?Z<.<Z
 80a45a4:	1c1c3e7f 1c1c0808 22147f3e 5f14227f     .>......>.."."._
 80a45b4:	5f5f005f 017f0906 8966007f 60606a95     _.__......f..j``
 80a45c4:	94606060 94a2ffa2 047e0408 7e201008     ```.......~... ~
 80a45d4:	08081020 08081c2a 08082a1c 1010101e      ...*....*......
 80a45e4:	0c1e0c10 38300c1e 0630383e 060e3e0e     ......08>80..>..
 80a45f4:	00000000 5f000000 07000000 14000700     ......._........
 80a4604:	147f147f 2a7f2a24 08132312 49366264     ....$*.*.#..db6I
 80a4614:	00502056 00030708 41221c00 22410000     V P......."A..A"
 80a4624:	1c2a001c 082a1c7f 08083e08 30708000     ..*...*..>....p0
 80a4634:	08080800 00000808 20006060 02040810     ........``. ....
 80a4644:	4549513e 7f42003e 49720040 21464949     >QIE>.B.@.rIIIF!
 80a4654:	334d4941 7f121418 45452710 4a3c3945     AIM3.....'EEE9<J
 80a4664:	41314949 07091121 49494936 49494636     II1A!...6III6FII
 80a4674:	00001e29 00000014 00003440 22140800     ).......@4....."
 80a4684:	14141441 41001414 02081422 06095901     A......A"....Y..
 80a4694:	595d413e 11127c4e 497f7c12 3e364949     >A]YN|...|.III6>
 80a46a4:	22414141 4141417f 49497f3e 097f4149     AAA".AAA>.IIIA..
 80a46b4:	3e010909 73514141 0808087f 7f41007f     ...>AAQs......A.
 80a46c4:	40200041 7f013f41 41221408 4040407f     A. @A?...."A.@@@
 80a46d4:	1c027f40 047f7f02 3e7f1008 3e414141     @..........>AAA>
 80a46e4:	0909097f 51413e06 097f5e21 26462919     .....>AQ!^...)F&
 80a46f4:	32494949 017f0103 40403f03 201f3f40     III2.....?@@@?. 
 80a4704:	3f1f2040 3f403840 14081463 78040363     @ .?@8@?c...c..x
 80a4714:	59610304 00434d49 4141417f 10080402     ..aYIMC..AAA....
 80a4724:	41410020 02047f41 40040201 40404040      .AAA......@@@@@
 80a4734:	08070300 54542000 287f4078 38384444     ..... TTx@.(DD88
 80a4744:	28444444 28444438 5454387f 08001854     DDD(8DD(.8TTT...
 80a4754:	1802097e 789ca4a4 0404087f 7d440078     ~......x....x.D}
 80a4764:	40200040 7f003d40 00442810 407f4100     @. @@=...(D..A.@
 80a4774:	78047c00 087c7804 38780404 38444444     .|.x.x|...x8DDD8
 80a4784:	242418fc 24241818 087cfc18 48080404     ..$$..$$..|....H
 80a4794:	24545454 443f0404 40403c24 201c7c20     TTT$..?D$<@@ |. 
 80a47a4:	3c1c2040 3c403040 28102844 90904c44     @ .<@0@<D(.(DL..
 80a47b4:	64447c90 00444c54 00413608 00770000     .|DdTLD..6A...w.
 80a47c4:	36410000 01020008 3c020402 3c262326     ..A6.......<&#&<
 80a47d4:	61a1a11e 40403a12 54387a20 21595554     ...a.:@@ z8TTUY!
 80a47e4:	41795555 78545422 54552142 54204078     UUyA"TTxB!UTx@ T
 80a47f4:	0c407955 1272521e 55555539 54543959     Uy@..Rr.9UUUY9TT
 80a4804:	55395954 00585454 417c4500 7d450200     TY9UTTX..E|A..E}
 80a4814:	45010042 127d407c f07d1211 f0282528     B..E|@}...}.(%(.
 80a4824:	4555547c 54542000 0a7c547c 32497f09     |TUE. TT|T|...I2
 80a4834:	32494949 4444443a 484a323a 413a3048     III2:DDD:2JHH0:A
 80a4844:	3a7a2141 78204042 a0a09d00 42423d7d     A!z:B@ x....}=BB
 80a4854:	403d3d42 3c3d4040 2424ff24 43497e48     B==@@@=<$.$$H~IC
 80a4864:	fc2f2b66 09ff2b2f c020f629 03097e88     f+/./+..). ..~..
 80a4874:	79545420 44000041 4830417d 38324a48      TTyA..D}A0HHJ28
 80a4884:	7a224040 0a0a7a00 190d7d72 29267d31     @@"z.z..r}..1}&)
 80a4894:	26282f29 26292929 404d4830 08083820     )/(&)))&0HM@ 8..
 80a48a4:	08080808 2f380808 baacc810 3428102f     ......8/..../.(4
 80a48b4:	7b0000fa 14080000 2222142a 08142a14     ...{....*."".*..
 80a48c4:	00550055 aa55aa55 55ffaa55 00ff55ff     U.U.U.U.U..U.U..
 80a48d4:	00ff0000 ff101010 14141400 101000ff     ................
 80a48e4:	10ff00ff f010f010 fc141414 f7141400     ................
 80a48f4:	0000ff00 14ff00ff fc04f414 10171414     ................
 80a4904:	1f10101f 14141f10 10001f14 00f01010     ................
 80a4914:	1f000000 10101010 1010101f 0010f010     ................
 80a4924:	10ff0000 10101010 10101010 000010ff     ................
 80a4934:	0014ff00 ff00ff00 101f0000 fc000017     ................
 80a4944:	1414f404 14171017 f404f414 00ff0000     ................
 80a4954:	141414f7 14141414 14f700f7 14171414     ................
 80a4964:	101f1010 1414141f 101014f4 00f010f0     ................
 80a4974:	1f101f00 1f000000 00000014 000014fc     ................
 80a4984:	10f010f0 ff10ff10 ff141414 10101014     ................
 80a4994:	0000001f ff10f000 ffffffff f0f0f0f0     ................
 80a49a4:	fffffff0 00000000 0fffff00 0f0f0f0f     ................
 80a49b4:	38444438 4a4afc44 027e344a 02060602     8DD8D.JJJ4~.....
 80a49c4:	027e027e 41495563 44443863 7e40043c     ~.~.cUIAc8DD<.@~
 80a49d4:	06201e20 02027e02 a5e7a599 492a1c99      . ..~........*I
 80a49e4:	724c1c2a 304c7201 304d4d4a 48784830     *.Lr.rL0JMM00HxH
 80a49f4:	5a62bc30 493e3d46 7e004949 7e010101     0.bZF=>III.~...~
 80a4a04:	2a2a2a2a 5f44442a 51404444 4040444a     *****DD_DD@QJD@@
 80a4a14:	40514a44 01ff0000 ff80e003 08080000     DJQ@............
 80a4a24:	36086b6b 36243612 0f090f06 18000006     kk.6.6$6........
 80a4a34:	00000018 30001010 0101ff40 01011f00     .......0@.......
 80a4a44:	1d19001e 3c001217 003c3c3c 00000000     .......<<<<.....
 80a4a54:	00302e30 736c6166 72740065 25006575     0.0.false.true.%
 80a4a64:	75250064 2a2e2500 2500666c 756e0067     d.%u.%.*lf.%g.nu
 80a4a74:	75006c6c 78343025 00000000              ll.u%04x....

080a4a80 <_ZTVN5spark12NetworkClassE>:
	...
 80a4a88:	080a1d6f 080a1d79 080a1d83 080a1d8d     o...y...........
 80a4a98:	080a1d97 080a1da3 080a1daf 080a1dbb     ................
 80a4aa8:	080a1dc3 080a1dcd 080a1dd9              ............

080a4ab4 <_ZTVN5spark9WiFiClassE>:
	...
 80a4abc:	080a1edf 080a1ed5 080a1ecb 080a1e3d     ............=...
 80a4acc:	080a1ebf 080a1eb3 080a1ea7 080a1e9f     ................
 80a4adc:	080a1e95 080a1e8b 080a1e47              ........G...

080a4ae8 <_ZTV7TwoWire>:
	...
 80a4af0:	080a1efd 080a1f47 080a1f1f 080a1eff     ....G...........
 80a4b00:	080a1f27 080a1f2f 080a1f37 080a1f3f     '.../...7...?...

080a4b10 <_ZTV9USBSerial>:
	...
 80a4b18:	080a1fb5 080a2005 080a2013 080a336d     ..... ... ..m3..
 80a4b28:	080a1ff1 080a1fb7 080a1fcd 080a1fff     ................
 80a4b38:	080a1fe3 080a1fb1                       ........

080a4b40 <_ZTV9IPAddress>:
	...
 80a4b48:	080a216d 080a215d 080a215f 2b25005a     m!..]!.._!..Z.%+
 80a4b58:	3a643330 75323025 2d592500 252d6d25     03d:%02u.%Y-%m-%
 80a4b68:	48255464 3a4d253a 7a255325 63736100     dT%H:%M:%S%z.asc
 80a4b78:	656d6974 00000000                       time....

080a4b80 <_ZTVN5spark16JSONStreamWriterE>:
	...
 80a4b88:	080a23e7 080a240d 080a23c1 080a19af     .#...$...#......

080a4b98 <_ZTVN5spark20JSONStreamLogHandlerE>:
	...
 80a4ba0:	080a289d 080a28b1 080a31f5 080a23c9     .(...(...1...#..
 80a4bb0:	64756162 72655300 006c6169 53425355     baud.Serial.USBS
 80a4bc0:	61697265 7400316c 00657079 61726170     erial1.type.para
 80a4bd0:	6d63006d 64690064 646e6800 72747300     m.cmd.id.hnd.str
 80a4be0:	6966006d 6c00746c 61006c76 61486464     m.filt.lvl.addHa
 80a4bf0:	656c646e 65720072 65766f6d 646e6148     ndler.removeHand
 80a4c00:	0072656c 6d756e65 646e6148 7372656c     ler.enumHandlers
 80a4c10:	4f534a00 7274534e 4c6d6165 6148676f     .JSONStreamLogHa
 80a4c20:	656c646e 70610072 30250070 20753031     ndler.app.%010u 
 80a4c30:	00205d00 2800202c 00203a29 63005b20     .] ., .(): . [.c
 80a4c40:	2065646f 2500203d 65640069 6c696174     ode = .%i.detail
 80a4c50:	203d2073 000a0d00 66006e6c 6f63006e     s = ....ln.fn.co
 80a4c60:	64006564 69617465 6f6e006c 7400656e     de.detail.none.t
 80a4c70:	65636172 666e6900 6177006f 65006e72     race.info.warn.e
 80a4c80:	726f7272 6e617000 61006369 00006c6c     rror.panic.all..

080a4c90 <_ZTVN5spark16StreamLogHandlerE>:
	...
 80a4c98:	080a2871 080a2889 080a3041 080a00c7     q(...(..A0......

080a4ca8 <_ZTVN5spark24DefaultLogHandlerFactoryE>:
	...
 80a4cb0:	080a23e5 080a241b 080a2f69 080a23cb     .#...$..i/...#..

080a4cc0 <_ZTVN5spark26DefaultOutputStreamFactoryE>:
	...
 80a4cc8:	080a23e3 080a2429 080a2795 080a2437     .#..)$...'..7$..

080a4cd8 <_ZTV11USARTSerial>:
	...
 80a4ce0:	080a3491 080a34e1 080a34ef 080a336d     .4...4...4..m3..
 80a4cf0:	080a34a5 080a34c7 080a34b3 080a34db     .4...4...4...4..
 80a4d00:	080a3493 080a3497                       .4...4..

080a4d08 <_ZN12_GLOBAL__N_1L14clock_divisorsE>:
 80a4d08:	18100800 38302820                       .... (08

080a4d10 <_ZSt7nothrow>:
	...

080a4d11 <_ctype_>:
 80a4d11:	20202000 20202020 28282020 20282828     .         ((((( 
 80a4d21:	20202020 20202020 20202020 20202020                     
 80a4d31:	10108820 10101010 10101010 10101010      ...............
 80a4d41:	04040410 04040404 10040404 10101010     ................
 80a4d51:	41411010 41414141 01010101 01010101     ..AAAAAA........
 80a4d61:	01010101 01010101 01010101 10101010     ................
 80a4d71:	42421010 42424242 02020202 02020202     ..BBBBBB........
 80a4d81:	02020202 02020202 02020202 10101010     ................
 80a4d91:	00000020 00000000 00000000 00000000      ...............
	...

080a4e14 <__sf_fake_stdin>:
	...

080a4e34 <__sf_fake_stdout>:
	...

080a4e54 <__sf_fake_stderr>:
	...
 80a4e74:	00000043                                         C.

080a4e76 <link_const_variable_data_end>:
	...

080a4e78 <link_constructors_location>:
 80a4e78:	080a027d 	.word	0x080a027d
 80a4e7c:	080a0d49 	.word	0x080a0d49
 80a4e80:	080a0d4d 	.word	0x080a0d4d
 80a4e84:	080a0d51 	.word	0x080a0d51
 80a4e88:	080a0d55 	.word	0x080a0d55
 80a4e8c:	080a1507 	.word	0x080a1507
 80a4e90:	080a150b 	.word	0x080a150b
 80a4e94:	080a150f 	.word	0x080a150f
 80a4e98:	080a1e29 	.word	0x080a1e29
 80a4e9c:	080a1ee9 	.word	0x080a1ee9
 80a4ea0:	080a2391 	.word	0x080a2391
 80a4ea4:	080a23ad 	.word	0x080a23ad
 80a4ea8:	080a3031 	.word	0x080a3031
 80a4eac:	080a35c9 	.word	0x080a35c9
 80a4eb0:	080a38cd 	.word	0x080a38cd
 80a4eb4:	080a3a11 	.word	0x080a3a11
 80a4eb8:	080a3a95 	.word	0x080a3a95
 80a4ebc:	080a3b59 	.word	0x080a3b59
 80a4ec0:	080a3c1d 	.word	0x080a3c1d

080a4ec4 <link_constructors_end>:
	...
